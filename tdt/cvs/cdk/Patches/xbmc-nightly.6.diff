diff -Nur xbmc-nightly.org/configure.in xbmc-nightly/configure.in
--- xbmc-nightly.org/configure.in	2014-01-24 22:02:26.798856176 -0800
+++ xbmc-nightly/configure.in	2014-02-14 18:27:05.175594267 -0800
@@ -157,6 +157,8 @@
 libusb_disabled_udev_found="== libusb disabled. =="
 libcec_enabled="== libcec enabled. =="
 libcec_disabled="== libcec disabled. CEC adapter support will not be available. =="
+gstreamer_not_found="== GStreamer libraries not found. GStreamer support disabled. =="
+gstreamer_disabled="== GStreamer support manually disabled. =="
 
 # External library message strings
 external_libraries_enabled="== Use of all supported external libraries enabled. =="
@@ -222,6 +224,12 @@
   [use_gles=$enableval],
   [use_gles=no])
 
+AC_ARG_ENABLE([glesv1],
+  [AS_HELP_STRING([--enable-glesv1],
+  [enable OpenGLESv1 rendering (default is no)])],
+  [use_glesv1=$enableval],
+  [use_glesv1=no])
+
 AC_ARG_ENABLE([sdl],
   [AS_HELP_STRING([--enable-sdl],
   [enable SDL (default is auto)])],
@@ -264,6 +272,12 @@
   [use_openmax=$enableval],
   [use_openmax=auto])
 
+AC_ARG_ENABLE([gstreamer],
+  [AS_HELP_STRING([--enable-gstreamer],
+  [enable GStreamer support (default is auto)])],
+  [use_gstreamer=$enableval],
+  [use_gstreamer=auto])
+
 AC_ARG_ENABLE([tegra],
   [AS_HELP_STRING([--enable-tegra],
   [enable Tegra2 arm (default is no)])],
@@ -426,6 +440,24 @@
   [use_mysql=$enableval],
   [use_mysql=yes])
 
+AC_ARG_ENABLE([dvdplayer],
+  [AS_HELP_STRING([--disable-dvdplayer],
+  [disable dvdplayer])],
+  [use_dvdplayer=$enableval],
+  [use_dvdplayer=yes])
+
+AC_ARG_ENABLE([paplayer],
+  [AS_HELP_STRING([--disable-paplayer],
+  [disable paplayer])],
+  [use_paplayer=$enableval],
+  [use_paplayer=yes])
+
+AC_ARG_ENABLE([gstplayer],
+  [AS_HELP_STRING([--enable-gstplayer],
+  [enable gstplayer])],
+  [use_gstplayer=$enableval],
+  [use_gstplayer=no])
+
 AC_ARG_ENABLE([webserver],
   [AS_HELP_STRING([--disable-webserver],
   [disable webserver])],
@@ -625,6 +657,16 @@
      use_arch="arm"
      AC_SUBST(ARCH_DEFINES, "-DTARGET_POSIX -DTARGET_LINUX -D_LINUX")
      ;;
+  sh*-*-linux-gnu*)
+     use_texturepacker=yes
+     use_texturepacker_native=yes
+     USE_TEXTUREPACKER_NATIVE_ROOT="$TEXTUREPACKER_NATIVE_ROOT"
+     ARCH="sh"
+     use_arch="sh"
+     use_hardcoded_tables="yes"
+     use_alsa="no"
+     AC_SUBST(ARCH_DEFINES, "-DTARGET_POSIX -DTARGET_LINUX -D_LINUX")
+     ;;
   arm*-*linux-android*)
      target_platform=target_android
      use_arch="arm"
@@ -898,8 +940,19 @@
       AC_CHECK_LIB([GLU], [main],, AC_MSG_ERROR($missing_library))
     fi
   else
-    AC_MSG_RESULT(== WARNING: OpenGL support is disabled. XBMC will run VERY slow. ==)
-    AC_CHECK_LIB([SDL_gfx],[main])
+    if test "$use_glesv1" = "yes"; then
+      if test "$host_alias" = "sh4-linux" ; then
+        AC_DEFINE([HAVE_LIBEGL],[1],["Define to 1 if you have the `EGL' library (-lEGL)."])
+        AC_DEFINE([HAVE_LIBGLES],[1],["Define to 1 if you have the `GLES' library (-lGLES)."])
+        
+        PKG_CHECK_MODULES([STGLES],  [libstgles],
+	  INCLUDES="$INCLUDES $STGLES_CFLAGS"; LIBS="$LIBS $STGLES_LIBS"; use_stgles=yes],
+          AC_MSG_NOTICE($stgles_not_found); use_stgles=no)
+      fi
+    else
+      AC_MSG_RESULT(== WARNING: OpenGL support is disabled. XBMC will run VERY slow. ==)
+      AC_CHECK_LIB([SDL_gfx],[main])
+    fi
   fi
 fi
 
@@ -1790,6 +1843,44 @@
   fi
 fi
 
+# GSTREAMER
+if test "x$use_gstreamer" != "xno"; then
+  if test "$host_vendor" = "apple" ; then
+    if test "x$use_gstreamer" = "xyes"; then
+      AC_MSG_ERROR([GStreamer not supported on this platform])
+    else
+      use_gstreamer="no"
+      AC_MSG_NOTICE($gstreamer_disabled)
+    fi
+    USE_GSTREAMER=0
+  else
+    AC_SUBST(gstreamer_req, 0.10.0)
+    AC_SUBST(gstreamer_plugins_base_req, 0.10.0)
+    PKG_CHECK_MODULES(GSTREAMER, gstreamer-0.10 >= $gstreamer_req, HAVE_GSTREAMER=1, HAVE_GSTREAMER=0)
+    PKG_CHECK_MODULES(GSTREAMER_BASE, gstreamer-base-0.10 >= $gstreamer_req, HAVE_GSTREAMER_BASE=1, HAVE_GSTREAMER_BASE=0)
+    PKG_CHECK_MODULES(GSTREAMER_PLUGINS_BASE, gstreamer-plugins-base-0.10 >= $gstreamer_plugins_base_req, HAVE_GSTREAMER_PLUGINS_BASE=1, HAVE_GSTREAMER_PLUGINS_BASE=0)
+    HAVE_GSTREAMER_APP=1
+    AC_CHECK_LIB([gstapp-0.10], main, , HAVE_GSTREAMER_APP=0)
+
+    if test $HAVE_GSTREAMER -eq 1 -a $HAVE_GSTREAMER_BASE -eq 1 -a $HAVE_GSTREAMER_PLUGINS_BASE -eq 1 -a $HAVE_GSTREAMER_APP -eq 1; then
+      INCLUDES="$INCLUDES $GSTREAMER_CFLAGS $GSTREAMER_BASE_CFLAGS $GSTREAMER_PLUGINS_BASE_CFLAGS"
+      LIBS="$LIBS $GSTREAMER_LIBS $GSTREAMER_BASE_LIBS $GSTREAMER_PLUGINS_BASE_LIBS"
+      USE_GSTREAMER=1
+      AC_DEFINE([HAVE_LIBGSTREAMER], [1], [Define to 1 if you have the 'GStreamer' library.])
+    else
+      if test "x$use_gstreamer" = "xyes"; then
+        AC_MSG_ERROR([$gstreamer_not_found])
+      else
+        use_gstreamer="no"
+        USE_GSTREAMER=0
+        AC_MSG_RESULT($gstreamer_not_found)
+      fi
+    fi
+  fi
+else
+  USE_GSTREAMER=0
+  AC_MSG_NOTICE($gstreamer_disabled)
+fi
 # yajl version check (yajl_version.h was added in yajl 2.0)
 AC_CHECK_HEADERS([yajl/yajl_version.h], [], [
 AC_DEFINE(YAJL_MAJOR, 1, [yajl version 1])
@@ -1892,16 +1983,23 @@
 if test "$use_gles" = "yes"; then
   final_message="$final_message\n  OpenGLES:\tYes"
   USE_OPENGLES=1
+  USE_OPENGLESV1=0
   USE_OPENGL=0
 else
   USE_OPENGLES=0
   if test "$use_gl" = "yes"; then
     final_message="$final_message\n  OpenGL:\tYes"
     USE_OPENGL=1
+    USE_OPENGLESV1=0
   else
+    USE_OPENGL=0
+    final_message="$final_message\n  OpenGLESV1:\tYes"
+    if test "$use_glesv1" = "yes"; then
+      USE_OPENGLESV1=1
+    else
     final_message="$final_message\n  OpenGL:\tNo (Very Slow)"
     SDL_DEFINES="-DHAS_SDL_2D"
-    USE_OPENGL=0
+    fi
   fi
 fi
 
@@ -1956,6 +2054,12 @@
   final_message="$final_message\n  OpenMax:\tNo"
 fi
 
+if test "$use_gstreamer" != "no"; then
+  final_message="$final_message\n  GStreamer:\tYes"
+else
+  final_message="$final_message\n  GStreamer:\tNo"
+fi
+
 if test "$use_joystick" = "yes"; then
   final_message="$final_message\n  Joystick:\tYes"
   SDL_DEFINES="$SDL_DEFINES -DHAS_SDL_JOYSTICK"
@@ -2152,6 +2256,33 @@
   final_message="$final_message\n  MySQL:\tNo"
   USE_MYSQL=0
 fi
+
+if test "$use_dvdplayer" = "yes"; then
+  final_message="$final_message\n  dvdplayer:\tYes"
+  USE_DVDPLAYER=1
+  AC_DEFINE([HAVE_DVDPLAYER],[1],[""])
+else
+  final_message="$final_message\n  dvdplayer:\tNo"
+  USE_DVDPLAYER=0
+fi
+
+if test "$use_paplayer" = "yes"; then
+  final_message="$final_message\n  paplayer:\tYes"
+  USE_PAPLAYER=1
+  AC_DEFINE([HAVE_PAPLAYER],[1],[""])
+else
+  final_message="$final_message\n  paplayer:\tNo"
+  USE_PAPLAYER=0
+fi
+
+if test "$use_gstplayer" = "yes"; then
+  final_message="$final_message\n  gstplayer:\tYes"
+  USE_GSTPLAYER=1
+  AC_DEFINE([HAVE_GSTPLAYER],[1],[""])
+else
+  final_message="$final_message\n  gstplayer:\tNo"
+  USE_GSTPLAYER=0
+fi
 if test "$use_webserver" = "yes"; then
   final_message="$final_message\n  Webserver:\tYes"
   USE_WEB_SERVER=1
@@ -2310,6 +2441,7 @@
     xbmc/cores/dvdplayer/DVDSubtitles/Makefile \
     xbmc/cores/AudioEngine/Makefile \
     xbmc/cores/paplayer/Makefile \
+    xbmc/cores/gstplayer/Makefile \
     xbmc/cores/amlplayer/Makefile \
     xbmc/cores/omxplayer/Makefile \
     lib/timidity/Makefile \
@@ -2403,6 +2535,7 @@
 AC_SUBST_FILE(XBMC_STANDALONE_SH_PULSE)
 AC_SUBST(USE_OPENGL)
 AC_SUBST(USE_OPENGLES)
+AC_SUBST(USE_OPENGLESV1)
 AC_SUBST(USE_VDPAU)
 AC_SUBST(USE_VAAPI)
 AC_SUBST(USE_CRYSTALHD)
@@ -2412,6 +2545,7 @@
 AC_SUBST(USE_AIRPLAY)
 AC_SUBST(USE_VDA)
 AC_SUBST(USE_OPENMAX)
+AC_SUBST(USE_GSTREAMER)
 AC_SUBST(USE_PULSE)
 AC_SUBST(USE_XRANDR)
 AC_SUBST(USE_ALSA)
@@ -2423,6 +2557,9 @@
 AC_SUBST(USE_LIBUSB)
 AC_SUBST(USE_LIBCEC)
 AC_SUBST(USE_MYSQL)
+AC_SUBST(USE_DVDPLAYER)
+AC_SUBST(USE_PAPLAYER)
+AC_SUBST(USE_GSTPLAYER)
 AC_SUBST(USE_WEB_SERVER)
 AC_SUBST(USE_UPNP)
 AC_SUBST(USE_OMXLIB)
diff -Nur xbmc-nightly.org/configure.in.orig xbmc-nightly/configure.in.orig
--- xbmc-nightly.org/configure.in.orig	1969-12-31 16:00:00.000000000 -0800
+++ xbmc-nightly/configure.in.orig	2014-01-24 22:02:26.798856176 -0800
@@ -0,0 +1,2758 @@
+#                                               -*- Autoconf -*-
+# Process this file with autoconf to produce a configure script.
+
+AC_PREREQ(2.59)
+AC_INIT([xbmc], [12.3], [http://trac.xbmc.org])
+AC_CONFIG_HEADERS([xbmc/config.h])
+AH_TOP([#pragma once])
+m4_include([m4/ax_python_devel.m4])
+
+AC_CONFIG_AUX_DIR([build-aux])
+AM_INIT_AUTOMAKE([foreign])
+AC_CANONICAL_HOST
+
+tolower(){
+  echo "$@" | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz
+}
+
+# check for enabling additional players
+AC_DEFUN([XB_ADD_PLAYER],
+[
+  AC_MSG_CHECKING([for $2])
+  case $add_players in
+    *$2*)
+      AC_SUBST([USE_$1], 1)
+      AC_DEFINE([HAS_$1], 1, [using $2])
+      AC_MSG_RESULT([enabling $2])
+      ;;
+    *)
+      AC_MSG_RESULT([$2 is not enabled])
+  esac
+])
+
+# check for library basenames
+AC_DEFUN([XB_FIND_SONAME],
+[
+  if echo "$host" | grep -q freebsd ; then
+    AC_MSG_CHECKING([for lib$2 soname])
+    $1_SONAME=[`ldconfig -r | sed -n "s;.* \(/.*lib$2\.so.*\)$;\1;p" | head -n 1`]
+    if test x$$1_SONAME != x ; then
+      $1_SONAME=[`basename $$1_SONAME`]
+    fi
+  elif [[ "$host_vendor" != "apple" ]]; then
+    AC_MSG_CHECKING([for lib$2 soname])
+    $1_FILENAME=$($CC -nostdlib -o /dev/null $LDFLAGS -l$2 -Wl,-M 2>/dev/null | grep "^LOAD.*$2" | awk '{V=2; print $V}')
+    if [[ -z $$1_FILENAME ]]; then
+      #try gold linker syntax
+      $1_FILENAME=$($CC -nostdlib -o /dev/null $LDFLAGS -l$2 -Wl,-t 3>&1 1>&2 2>&3 | grep "$2")
+    fi
+    if [[ ! -z $$1_FILENAME ]]; then
+      $1_SONAME=$($OBJDUMP -p $$1_FILENAME | grep "SONAME.*$2" | awk '{V=2; print $V}')
+    fi
+  else
+    AC_MSG_CHECKING([for lib$2 dylib])
+    gcc_lib_path=[`$CC -print-search-dirs 2>/dev/null | fgrep libraries: | sed 's/[^=]*=\(.*\)/\1/' | sed 's/:/ /g'`]
+    env_lib_path=[`echo $LDFLAGS | sed 's/-L[ ]*//g'`]
+    if test "$cross_compiling" = yes; then
+      host_lib_path=""
+    else
+      host_lib_path="/usr/lib /usr/local/lib"
+    fi
+    for path in $gcc_lib_path $env_lib_path $host_lib_path; do
+      lib=[`ls -- $path/lib$2.dylib 2>/dev/null`]
+      if test x$lib != x; then
+        # we want the path/name that is embedded in the dylib 
+        $1_SONAME=[`otool -L $lib | grep -v lib$2.dylib | grep lib$2 | awk '{V=1; print $V}'`]
+        $1_SONAME=[`basename $$1_SONAME`]
+      fi
+    done
+  fi
+  if [[ -z "$$1_SONAME" ]]; then
+    AC_MSG_RESULT([no])
+    if test -z "$3" || test "x${$3}" = "xyes"; then
+      AC_MSG_ERROR([Unable to determine soname of lib$2 library])
+    else
+      AC_MSG_WARN([Unable to determine soname of lib$2 library])
+      $3=no
+      AC_MSG_WARN([lib$2 support disabled])
+    fi
+  else
+    AC_MSG_RESULT([$$1_SONAME])
+    AC_SUBST($1_SONAME)
+  fi
+])
+
+# Function to push and pop libs and includes for a command
+AC_DEFUN([XB_PUSH_FLAGS], [
+  SAVE_LIBS="$LIBS"
+  SAVE_INCLUDES="$INCLUDES"
+  LIBS="[$2]"
+  INCLUDES="[$1]"
+  [$3]
+  LIBS="$SAVE_LIBS"
+  INCLUDES="$SAVE_INCLUDES"
+])
+
+# General message strings
+configure_debug="ERROR: this is a configure debug statement"
+missing_library="Could not find a required library. Please see the README for your platform."
+missing_headers="Could not find some required headers. Please see the README for your platform."
+missing_program="Could not find a required program. Please see the README for your platform."
+xrandr_not_found="== Could not find libXRandR. SDL will be used for resolution support. =="
+xrandr_disabled="== XRandR support disabled. SDL will be used for resolution support. =="
+goom_enabled="== GOOM enabled. =="
+goom_disabled="== GOOM disabled. =="
+alsa_disabled="== ALSA support disabled. =="
+rsxs_enabled="== RSXS enabled. =="
+rsxs_disabled="== RSXS disabled. =="
+projectm_enabled="== ProjectM enabled. =="
+projectm_disabled="== ProjectM disabled. =="
+x11_enabled="== X11 enabled. =="
+x11_disabled="== X11 disabled. =="
+pulse_not_found="== Could not find libpulse. PulseAudio support disabled. =="
+pulse_disabled="== PulseAudio support manually disabled. =="
+dvdcss_enabled="== DVDCSS support enabled. =="
+dvdcss_disabled="== DVDCSS support disabled. =="
+hal_not_found="== Could not find hal. HAL support disabled. =="
+halstorage_not_found="== Could not find hal-storage. HAL support disabled. =="
+hal_disabled="== HAL support disabled. =="
+avahi_not_found="== Could not find libavahi-common or libavahi-client. Avahi support disabled. =="
+avahi_disabled="== Avahi support disabled. =="
+vdpau_not_found="== Could not find libvdpau. VDPAU support disabled. =="
+vdpau_disabled="== VDPAU support manually disabled. =="
+vaapi_not_found="== Could not find libva. VAAPI support disabled. =="
+vaapi_disabled="== VAAPI support manually disabled. =="
+crystalhd_not_found="== Could not find libcrystalhd. CrystalHD support disabled. =="
+crystalhd_disabled="== CrystalHD support manually disabled. =="
+vdadecoder_enabled="== VDADecoder support enabled. =="
+vdadecoder_disabled="== VDADecoder support manually disabled. =="
+vtbdecoder_enabled="== VTBDecoder support enabled. =="
+vtbdecoder_disabled="== VTBDecoder support manually disabled. =="
+openmax_disabled="== OpenMax support manually disabled. =="
+openmax_not_found="== Could not find libnvomx. OpenMax support disabled. =="
+ssh_not_found="== Could not find libssh. =="
+ssh_disabled="== SSH SFTP disabled. =="
+librtmp_not_found="== Could not find libRTMP. RTMP support disabled. =="
+librtmp_disabled="== RTMP support disabled. =="
+libnfs_not_found="== Could not find libnfs. NFS client support disabled. =="
+libnfs_disabled="== NFS support disabled. =="
+libafpclient_not_found="== Could not find libafpclient. AFP client support disabled. =="
+libafpclient_disabled="== AFP support disabled. =="
+libshairport_not_found="== Could not find libshairport. AirTunes support disabled. =="
+libshairport_disabled="== AirTunes support disabled. =="
+samba_disabled="== SAMBA support disabled. =="
+libplist_not_found="== Could not find libplist. AirPlay support disabled. =="
+libplist_disabled="== AirPlay support disabled. =="
+alsa_not_found="== Could not find ALSA. ALSA support disabled. =="
+dbus_not_found="== Could not find DBUS. DBUS support disabled. =="
+libcap_disabled="== Capabilities detection support disabled. =="
+libcap_not_found="== Could not find libcap. Capabilities detection support disabled. =="
+gtest_enabled="== Google Test Framework will be configured. =="
+gtest_disabled="== Google Test Framework will not be configured. =="
+
+libudev_not_found="== Could not find libudev. Will use polling to check for device changes. =="
+libudev_disabled="== udev support disabled. Will use polling to check for device changes. =="
+libusb_not_found="== Could not find libusb. Plug and play USB device support will not be available. =="
+libusb_disabled="== libusb disabled. Plug and play USB device support will not be available. =="
+libusb_disabled_udev_found="== libusb disabled. =="
+libcec_enabled="== libcec enabled. =="
+libcec_disabled="== libcec disabled. CEC adapter support will not be available. =="
+
+# External library message strings
+external_libraries_enabled="== Use of all supported external libraries enabled. =="
+external_libraries_disabled="== Use of all supported external libraries disabled. =="
+external_ffmpeg_enabled="== Use of external ffmpeg enabled. =="
+external_ffmpeg_disabled="== Use of external ffmpeg disabled. =="
+ffmpeg_vdpau_not_supported="== External ffmpeg doesn't support VDPAU. VDPAU support disabled. =="
+dashes="------------------------"
+final_message="\n  XBMC Configuration:"
+final_message="\n$dashes$final_message\n$dashes"
+
+AC_ARG_ENABLE([shared-lib],
+  [AS_HELP_STRING([--enable-shared-lib],
+  [build libxbmc. helpful for tests (default is no)])],
+  [build_shared_lib=$enableval],
+  [build_shared_lib=no])
+
+AC_ARG_ENABLE([debug],
+  [AS_HELP_STRING([--enable-debug],
+  [enable debugging information (default is yes)])],
+  [use_debug=$enableval],
+  [use_debug=yes])
+
+AC_ARG_WITH([arch],
+  [AS_HELP_STRING([--with-arch],
+  [build with given arch passing to internal ffmpeg (default is no, needed for crosscompiling)])],
+  [use_arch=$withval],
+  [use_arch=no])
+
+AC_ARG_WITH([platform],
+  [AS_HELP_STRING([--with-platform],
+  [use a pre-configured config for common arm boards])],
+  [use_platform=$withval],
+  [use_platform=none])
+
+AC_ARG_WITH([cpu],
+  [AS_HELP_STRING([--with-cpu],
+  [build with given cpu passing to ffmpeg (default is no)])],
+  [use_cpu=$withval],
+  [use_cpu=no])
+
+AC_ARG_ENABLE([neon],
+  [AS_HELP_STRING([--enable-neon],
+  [enable neon passing to ffmpeg (default is no)])],
+  [use_neon=$enableval],
+  [use_neon=no])
+
+AC_ARG_ENABLE([optimizations],
+  [AS_HELP_STRING([--enable-optimizations],
+  [enable optimization (default is yes)])],
+  [use_optimizations=$enableval],
+  [use_optimizations=yes])
+
+AC_ARG_ENABLE([gl],
+  [AS_HELP_STRING([--enable-gl],
+  [enable OpenGL rendering (default is yes)])],
+  [use_gl=$enableval],
+  [use_gl=yes])
+
+AC_ARG_ENABLE([gles],
+  [AS_HELP_STRING([--enable-gles],
+  [enable OpenGLES rendering (default is no)])],
+  [use_gles=$enableval],
+  [use_gles=no])
+
+AC_ARG_ENABLE([sdl],
+  [AS_HELP_STRING([--enable-sdl],
+  [enable SDL (default is auto)])],
+  [use_sdl=$enableval],
+  [use_sdl=auto])
+
+AC_ARG_ENABLE([vdpau],
+  [AS_HELP_STRING([--enable-vdpau],
+  [enable VDPAU decoding (default is auto)])],
+  [use_vdpau=$enableval],
+  [use_vdpau=auto])
+
+AC_ARG_ENABLE([vaapi],
+  [AS_HELP_STRING([--enable-vaapi],
+  [enable VAAPI decoding (default is auto)])],
+  [use_vaapi=$enableval],
+  [use_vaapi=auto])
+
+AC_ARG_ENABLE([crystalhd],
+  [AS_HELP_STRING([--enable-crystalhd],
+  [enable CrystalHD decoding (default is auto)])],
+  [use_crystalhd=$enableval],
+  [use_crystalhd=auto])
+
+AC_ARG_ENABLE([vdadecoder],
+  [AS_HELP_STRING([--enable-vdadecoder],
+  [enable VDADecoder decoding (default is auto)])],
+  [use_vdadecoder=$enableval],
+  [use_vdadecoder=auto])
+
+AC_ARG_ENABLE([vtbdecoder],
+  [AS_HELP_STRING([--enable-vtbdecoder],
+  [enable VTBDecoder decoding (default is auto)])],
+  [use_vtbdecoder=$enableval],
+  [use_vtbdecoder=auto])
+
+AC_ARG_ENABLE([openmax],
+  [AS_HELP_STRING([--enable-openmax],
+  [enable OpenMax decoding (default is auto, requires OpenGLES)])],
+  [use_openmax=$enableval],
+  [use_openmax=auto])
+
+AC_ARG_ENABLE([tegra],
+  [AS_HELP_STRING([--enable-tegra],
+  [enable Tegra2 arm (default is no)])],
+  [use_tegra=$enableval],
+  [use_tegra=no])
+
+AC_ARG_ENABLE([profiling],
+  [AS_HELP_STRING([--enable-profiling],
+  [enable gprof profiling (default is no)])],
+  [use_profiling=$enableval],
+  [use_profiling=no])
+
+AC_ARG_ENABLE([joystick],
+  [AS_HELP_STRING([--enable-joystick],
+  [enable SDL joystick support (default is yes)])],
+  [use_joystick=$enableval],
+  [use_joystick=yes])
+
+AC_ARG_ENABLE([xrandr],
+  [AS_HELP_STRING([--enable-xrandr],
+  [enable XRandR support (default is yes)])],
+  [use_xrandr=$enableval],
+  [use_xrandr=yes])
+
+AC_ARG_ENABLE([goom],
+  [AS_HELP_STRING([--enable-goom],
+  [enable GOOM visualisation (default is no)])],
+  [use_goom=$enableval],
+  [use_goom=no])
+
+AC_ARG_ENABLE([rsxs],
+  [AS_HELP_STRING([--enable-rsxs],
+  [enable really slick X screensavers (default is yes)])],
+  [use_rsxs=$enableval],
+  [use_rsxs=yes])
+
+AC_ARG_ENABLE([projectm],
+  [AS_HELP_STRING([--enable-projectm],
+  [enable ProjectM visualisation (default is yes)])],
+  [use_projectm=$enableval],
+  [use_projectm=yes])
+
+AC_ARG_ENABLE([x11],
+  [AS_HELP_STRING([--enable-x11],
+  [enable x11 (default is yes) 'Linux Only'])],
+  [use_x11=$enableval],
+  [use_x11=yes])
+
+AC_ARG_ENABLE([ccache],
+  [AS_HELP_STRING([--enable-ccache],
+  [enable building with ccache feature (default is auto)])],
+  [use_ccache=$enableval],
+  [use_ccache=auto])
+
+AC_ARG_ENABLE([alsa],
+  [AS_HELP_STRING([--disable-alsa],
+  [disable ALSA support (only for linux/freebsd)])],
+  [use_alsa=$enableval],
+  [use_alsa=yes])
+
+AC_ARG_ENABLE([pulse],
+  [AS_HELP_STRING([--enable-pulse],
+  [enable PulseAudio support (default is no)])],
+  [use_pulse=$enableval],
+  [use_pulse=no])
+
+AC_ARG_ENABLE([ssh],
+  [AS_HELP_STRING([--disable-ssh],
+  [disable SSH SFTP support (default is enabled)])],
+  [use_ssh=$enableval],
+  [use_ssh=yes])
+
+AC_ARG_ENABLE([rtmp],
+  [AS_HELP_STRING([--enable-rtmp],
+  [enable RTMP support via librtmp (default is auto)])],
+  [use_librtmp=$enableval],
+  [use_librtmp=auto])
+
+AC_ARG_ENABLE([samba],
+  [AS_HELP_STRING([--disable-samba],
+  [disable SAMBA support (default is enabled)])],
+  [use_samba=$enableval],
+  [use_samba=yes])
+
+AC_ARG_ENABLE([nfs],
+  [AS_HELP_STRING([--enable-nfs],
+  [enable NFS support via libnfs (default is auto)])],
+  [use_libnfs=$enableval],
+  [use_libnfs=auto])
+
+AC_ARG_ENABLE([afpclient],
+  [AS_HELP_STRING([--enable-afpclient],
+  [enable AFP support via libafpclient (default is auto)])],
+  [use_libafpclient=$enableval],
+  [use_libafpclient=auto])
+
+AC_ARG_ENABLE([airplay],
+  [AS_HELP_STRING([--enable-airplay],
+  [enable AirPlay support(default is auto)])],
+  [use_airplay=$enableval],
+  [use_airplay=auto])
+
+AC_ARG_ENABLE([airtunes],
+  [AS_HELP_STRING([--enable-airtunes],
+  [enable AirTunes support(default is auto)])],
+  [use_airtunes=$enableval],
+  [use_airtunes=auto])
+
+AC_ARG_ENABLE([upnp],
+  [AS_HELP_STRING([--disable-upnp],
+  [disable UPnP support (default is enabled)])],
+  [use_upnp=$enableval],
+  [use_upnp=yes])
+
+AC_ARG_ENABLE([ffmpeg_libvorbis],
+  [AS_HELP_STRING([--enable-ffmpeg-libvorbis],
+  [enable FFmpeg vorbis encoding (default is no)])],
+  [use_ffmpeg_libvorbis=$enableval],
+  [use_ffmpeg_libvorbis=no])
+
+AC_ARG_ENABLE([dvdcss],
+  [AS_HELP_STRING([--enable-dvdcss],
+  [enable DVDCSS support (default is yes)])],
+  [use_dvdcss=$enableval],
+  [use_dvdcss=yes])
+
+AC_ARG_ENABLE([mid],
+  [AS_HELP_STRING([--enable-mid],
+  [enable MID support (default is no)])],
+  [use_mid=$enableval],
+  [use_mid=no])
+
+AC_ARG_ENABLE([hal],
+  [AS_HELP_STRING([--disable-hal],
+  [disable HAL support (default is enabled if hal and hal-storage is found)])],
+  [use_hal=$enableval],
+  [use_hal=yes])
+
+AC_ARG_ENABLE([avahi],
+  [AS_HELP_STRING([--disable-avahi],
+  [disable Avahi support (default is enabled if libavahi-common and libavahi-client is found)])],
+  [use_avahi=$enableval],
+  [use_avahi=yes])
+
+AC_ARG_ENABLE([non-free],
+  [AS_HELP_STRING([--disable-non-free],
+  [disable componentents with non-compliant licenses])],
+  [use_nonfree=$enableval],
+  [use_nonfree=yes])
+
+AC_ARG_ENABLE([asap-codec],
+  [AS_HELP_STRING([--enable-asap-codec],
+  [enable ASAP ADPCM support])],
+  [use_asap=$enableval],
+  [use_asap=no])
+
+AC_ARG_ENABLE([mysql],
+  [AS_HELP_STRING([--disable-mysql],
+  [disable mysql])],
+  [use_mysql=$enableval],
+  [use_mysql=yes])
+
+AC_ARG_ENABLE([webserver],
+  [AS_HELP_STRING([--disable-webserver],
+  [disable webserver])],
+  [use_webserver=$enableval],
+  [use_webserver=yes])
+
+AC_ARG_ENABLE([optical-drive],
+  [AS_HELP_STRING([--disable-optical-drive],
+  [disable optical drive])],
+  [use_optical_drive=$enableval],
+  [use_optical_drive=yes])
+
+AC_ARG_ENABLE([libbluray],
+  [AS_HELP_STRING([--enable-libbluray],
+  [enable libbluray support])],
+  [use_libbluray=$enableval],
+  [use_libbluray=auto])
+
+AC_ARG_ENABLE([texturepacker],
+  [AS_HELP_STRING([--enable-texturepacker],
+  [enable texturepacker support (default is yes)])],
+  [use_texturepacker=$enableval],
+  [use_texturepacker=auto])
+
+AC_ARG_WITH([lirc-device],
+  [AS_HELP_STRING([--with-lirc-device=file],
+  [specify the default LIRC device (default is /dev/lircd)])],
+  [lirc_device=$withval],
+  [lirc_device=/dev/lircd])
+AC_DEFINE_UNQUOTED([LIRC_DEVICE], ["$lirc_device"], [Default LIRC device])
+
+AC_ARG_ENABLE([udev],
+  [AS_HELP_STRING([--enable-udev],
+  [enable udev support (default is auto)])],
+  [use_libudev=$enableval],
+  [use_libudev=auto])
+
+AC_ARG_ENABLE([libusb],
+  [AS_HELP_STRING([--enable-libusb],
+  [enable libusb support (default is auto)])],
+  [use_libusb=$enableval],
+  [use_libusb=auto])
+
+AC_ARG_ENABLE([libcec],
+  [AS_HELP_STRING([--enable-libcec],
+  [enable libcec support (default is auto)])],
+  [use_libcec=$enableval],
+  [use_libcec=auto])
+
+AC_ARG_ENABLE([libmp3lame],
+  [AS_HELP_STRING([--enable-libmp3lame],
+  [enable lame mp3 encoder support (default is auto)])],
+  [use_libmp3lame=$enableval],
+  [use_libmp3lame=auto])
+
+AC_ARG_ENABLE([libvorbisenc],
+  [AS_HELP_STRING([--enable-libvorbisenc],
+  [enable vorbis encoder support (default is auto)])],
+  [use_libvorbisenc=$enableval],
+  [use_libvorbisenc=auto])
+
+AC_ARG_ENABLE([libcap],
+  [AS_HELP_STRING([--enable-libcap],
+  [enable libcap support (default is auto)])],
+  [use_libcap=$enableval],
+  [use_libcap=auto])
+
+AC_ARG_ENABLE([player],
+  [AS_HELP_STRING([--enable-player],
+  [enable additional players from a list of comma separated names, (default is none, choices are amlplayer, omxplayer)])],
+  [add_players=$enableval],
+  [add_players=no])
+
+AC_ARG_ENABLE([gtest],
+  [AS_HELP_STRING([--enable-gtest],
+  [configure Google Test Framework (default is no)])],
+  [configure_gtest=$enableval],
+  [configure_gtest=no])
+
+### External libraries options
+AC_ARG_ENABLE([external-libraries],
+  [AS_HELP_STRING([--enable-external-libraries],
+  [enable use of all supported external libraries (default is no) 'Linux only'])],
+  [use_external_libraries=$enableval],
+  [use_external_libraries=no])
+
+AC_ARG_ENABLE([external-ffmpeg],
+  [AS_HELP_STRING([--enable-external-ffmpeg],
+  [enable use of external ffmpeg libraries (default is no) 'Linux only'])],
+  [use_external_ffmpeg=$enableval],
+  [use_external_ffmpeg=$use_external_libraries])
+
+### End of external library options
+
+if test "x$host_vendor" != "xapple"; then
+  DEFAULT_COMPILE_FLAGS="-fPIC -DPIC -D_REENTRANT"
+  DEFAULT_COMPILE_FLAGS="$DEFAULT_COMPILE_FLAGS -D_LARGEFILE64_SOURCE -D_FILE_OFFSET_BITS=64"
+fi
+
+# Checks for programs.
+PASSED_CXXFLAGS=$CXXFLAGS # Hack to override autoconf default values
+AC_PROG_CXX
+CXXFLAGS="$PASSED_CXXFLAGS $DEFAULT_COMPILE_FLAGS"
+PASSED_CFLAGS=$CFLAGS # Hack to override autoconf default values
+AC_PROG_CC
+AC_PROG_LIBTOOL
+CFLAGS="$PASSED_CFLAGS $DEFAULT_COMPILE_FLAGS"
+AC_PROG_AWK
+AC_PROG_LN_S
+AC_PROG_MAKE_SET
+MAKE="${MAKE:-make}"
+OBJDUMP="${OBJDUMP:-objdump}"
+
+# ffmpeg needs the output of uname -s (e.x. linux, darwin) for the target_os
+# there is no autoconf variable which will give
+# the correct output format when doing cross compilation
+# so we have to use our own var here
+# defaults to the build side target_os
+# and should be overridden for cross below (see android)
+ffmpeg_target_os=$(tolower $(uname -s))
+
+# host detection and setup
+case $host in
+  i*86*-android-linux-gnu*)
+     target_platform=target_android
+     ARCH="i486-linux"
+     use_arch="x86"
+     use_cpu="i686"
+     ffmpeg_target_os=linux
+     ;;
+  i*86*-linux-gnu*)
+     ARCH="i486-linux"
+     AC_SUBST(ARCH_DEFINES, "-DTARGET_POSIX -DTARGET_LINUX -D_LINUX")
+     ;;
+  x86_64-*-linux-gnu*)
+     ARCH="x86_64-linux"
+     AC_SUBST(ARCH_DEFINES, "-DTARGET_POSIX -DTARGET_LINUX -D_LINUX")
+     ;;
+  i386-*-freebsd*)
+     ARCH="x86-freebsd"
+     MAKE="gmake"
+     AC_SUBST(ARCH_DEFINES, "-DTARGET_POSIX -DTARGET_FREEBSD -D_LINUX")
+     ;;
+  amd64-*-freebsd*)
+     ARCH="x86_64-freebsd"
+     MAKE="gmake"
+     AC_SUBST(ARCH_DEFINES, "-DTARGET_POSIX -DTARGET_FREEBSD -D_LINUX")
+     ;;
+  arm-apple-darwin*)
+     use_joystick=no
+     use_neon=yes
+     use_libcec=no
+     use_crystalhd=no
+     use_vdadecoder=no
+     use_vtbdecoder=yes
+     use_optical_drive=no
+     use_dvdcss=no
+     use_gles=yes
+     use_cpu=cortex-a8
+     use_texturepacker_native=yes
+     ARCH="arm-osx"
+     use_arch="arm"
+     PYTHON_VERSION="2.6"
+     PYTHON_LDFLAGS="-L${prefix}/lib -lpython2.6"
+     PYTHON_CPPFLAGS="-I${prefix}/include/python2.6"
+     PYTHON_SITE_PKG="${prefix}/lib/python2.6/site-packages"
+     PYTHON_NOVERSIONCHECK="no-check"
+     AC_SUBST(ARCH_DEFINES, "-DTARGET_POSIX -DTARGET_DARWIN -DTARGET_DARWIN_IOS -D_LINUX")
+     ;;
+  *86*-apple-darwin*)
+     use_joystick=no
+     use_vtbdecoder=no
+     use_texturepacker_native=yes
+     ARCH="x86-osx"
+     AC_SUBST(ARCH_DEFINES, "-DTARGET_POSIX -DTARGET_DARWIN -DTARGET_DARWIN_OSX -D_LINUX")
+     ;;
+  powerpc-apple-darwin*)
+     use_joystick=no
+     use_vdadecoder=no
+     use_vtbdecoder=no
+     use_crystalhd=no
+     ARCH="powerpc-osx"
+     use_arch="ppc"
+     AC_SUBST(ARCH_DEFINES, "-DTARGET_POSIX -DTARGET_DARWIN -DTARGET_DARWIN_OSX -D_LINUX")
+     ;;
+  powerpc-*-linux-gnu*)
+     ARCH="powerpc-linux"
+     AC_SUBST(ARCH_DEFINES, "-DTARGET_POSIX -DTARGET_LINUX -D_LINUX -D_POWERPC")
+     ;;
+  powerpc64-*-linux-gnu*)
+     ARCH="powerpc64-linux"
+     AC_SUBST(ARCH_DEFINES, "-DTARGET_POSIX -DTARGET_LINUX -D_LINUX -D_POWERPC64")
+     ;;
+  arm*-*-linux-gnu*)
+     use_texturepacker=no
+     ARCH="arm"
+     use_arch="arm"
+     AC_SUBST(ARCH_DEFINES, "-DTARGET_POSIX -DTARGET_LINUX -D_LINUX")
+     ;;
+  arm*-*linux-android*)
+     target_platform=target_android
+     use_arch="arm"
+     use_cpu=cortex-a9
+     ARCH="arm"
+     ffmpeg_target_os=linux
+     ;;
+  *)
+     AC_MSG_ERROR(unsupported host ($host))
+esac
+AC_SUBST([ARCH])
+
+
+check_sdl_arch=[`file $USE_TEXTUREPACKER_NATIVE_ROOT/lib/libSDL_image.dylib | awk '{print $NF}'`]
+if test "x$check_sdl_arch" = "xi386" ; then
+  DARWIN_NATIVE_ARCH=-m32
+elif test "x$check_sdl_arch" = "xx86_64" ; then
+  DARWIN_NATIVE_ARCH=-m64
+fi
+AC_SUBST([DARWIN_NATIVE_ARCH])
+
+if test "$target_platform" = "target_android" ; then
+  USE_ANDROID=1
+  use_texturepacker_native=yes
+  webserver_checkdepends=yes
+  AC_SUBST(ARCH_DEFINES, "-DTARGET_POSIX -DTARGET_LINUX -D_LINUX -DTARGET_ANDROID")
+  CFLAGS="$CFLAGS -Wno-psabi"
+  CXXFLAGS="$CXXFLAGS -Wno-psabi"
+  AC_DEFINE(HAS_EGLGLES, [1], [Define if supporting EGL based GLES Framebuffer])
+fi
+
+case $use_platform in
+  raspberry-pi)
+     target_platform=target_raspberry_pi
+     use_neon=no
+     use_texturepacker=yes
+     use_texturepacker_native=yes
+     use_arch="arm"
+     use_cpu=arm1176jzf-s
+     use_hardcoded_tables="yes"
+     use_alsa="no"
+     USE_TEXTUREPACKER_NATIVE_ROOT="$TEXTUREPACKER_NATIVE_ROOT"
+     ARCH="arm"
+     AC_SUBST(ARCH_DEFINES, "-DTARGET_POSIX -DTARGET_LINUX -D_LINUX -D_ARMEL -DTARGET_RASPBERRY_PI")
+     AC_DEFINE(HAS_EGLGLES, [1], [Define if supporting EGL based GLES Framebuffer])
+     USE_OMXLIB=1; AC_DEFINE([HAVE_OMXLIB],[1],["Define to 1 if OMX libs is enabled"])
+     CFLAGS="$CFLAGS"
+     CXXFLAGS="$CXXFLAGS"
+     ffmpeg_target_os=linux
+     ;;
+esac
+
+if test "$build_shared_lib" = "yes"; then
+  final_message="$final_message\n Shared lib\tYes"
+  AC_SUBST(USE_LIBXBMC,1)
+fi
+
+
+# platform debug flags
+if test "$use_debug" = "yes"; then
+  final_message="$final_message\n  Debugging:\tYes"
+  if test "$use_profiling" = "yes"; then
+    final_message="$final_message\n  Profiling:\tYes"
+    DEBUG_FLAGS="-g -pg -D_DEBUG -Wall"
+  else
+    final_message="$final_message\n  Profiling:\tNo"
+    DEBUG_FLAGS="-g -D_DEBUG -Wall"
+  fi
+else
+  final_message="$final_message\n  Debugging:\tNo"
+  if test "$use_profiling" = "yes"; then
+    final_message="$final_message\n  Profiling:\tYes"
+    DEBUG_FLAGS="-pg -DNDEBUG=1"
+  else
+    final_message="$final_message\n  Profiling:\tNo"
+    DEBUG_FLAGS="-DNDEBUG=1"
+  fi
+fi
+CFLAGS="$CFLAGS $DEBUG_FLAGS"
+CXXFLAGS="$CXXFLAGS $DEBUG_FLAGS"
+
+
+if test "$use_optimizations" = "yes"; then
+  final_message="$final_message\n  Optimization:\tYes"
+  if test "$target_platform" = "target_raspberry_pi"; then
+    CXXFLAGS="$CXXFLAGS"
+    CFLAGS="$CFLAGS"
+  else
+    CXXFLAGS="-O2 $CXXFLAGS"
+    CFLAGS="-O2 $CFLAGS"
+  fi
+else
+  final_message="$final_message\n  Optimization:\tNo"
+fi
+
+
+# platform specific flags
+if echo "$ARCH" | grep -q "freebsd" ; then
+  LOCALBASE="${LOCALBASE:-/usr/local}"
+  CFLAGS="$CFLAGS -I$LOCALBASE/include"
+  CXXFLAGS="$CXXFLAGS -I$LOCALBASE/include"
+  CPPFLAGS="$CPPFLAGS -I$LOCALBASE/include"
+  LDFLAGS="$LDFLAGS -L$LOCALBASE/lib"
+  FFMPEG_EXTRACFLAGS="-I$LOCALBASE/include"
+fi
+if test "$host_vendor" = "apple" ; then
+  # standard xbmc paths
+  INCLUDES="$INCLUDES -I\$(abs_top_srcdir)/xbmc/osx"
+  if test "$use_arch" != "arm"; then
+    LIBS="$LIBS -framework ApplicationServices"
+    LIBS="$LIBS -framework AudioUnit"
+    LIBS="$LIBS -framework AudioToolbox"
+    LIBS="$LIBS -framework Cocoa"
+    LIBS="$LIBS -framework CoreAudio"
+    LIBS="$LIBS -framework CoreVideo"
+    LIBS="$LIBS -framework CoreServices"
+    LIBS="$LIBS -framework CoreFoundation"
+    LIBS="$LIBS -framework DiskArbitration"
+    LIBS="$LIBS -framework IOKit"
+    LIBS="$LIBS -framework IOSurface"
+    LIBS="$LIBS -framework QuartzCore"
+    LIBS="$LIBS -framework SystemConfiguration"
+  fi
+  USE_EXTERNAL_FFMPEG=1
+elif test "$target_platform" = "target_raspberry_pi"; then
+  ARCH="arm"
+  use_arch="arm"
+elif test "$use_arch" = "arm"; then
+  CFLAGS="$CFLAGS -mno-apcs-stack-check"
+  CXXFLAGS="$CXXFLAGS -mno-apcs-stack-check"
+  FFMPEG_EXTRACFLAGS=""
+  if test "$use_tegra" = "yes"; then
+    # Compile for ARMv7a architecture, need to test gcc for vfpv3-d16 support 
+    SAVE_CFLAGS="$CFLAGS"
+    CFLAGS="-mfpu=vfpv3-d16"
+    AC_COMPILE_IFELSE(
+      [AC_LANG_SOURCE([int foo;])],
+      [ CFLAGS="$SAVE_CFLAGS -Wno-psabi -Wa,-march=armv7a -mtune=cortex-a9 -mfpu=vfpv3-d16 -mthumb-interwork"
+        CXXFLAGS="$CXXFLAGS -Wno-psabi -Wa,-march=armv7a -mtune=cortex-a9 -mfpu=vfpv3-d16 -mthumb-interwork"
+        FFMPEG_EXTRACFLAGS="$FFMPEG_EXTRACFLAGS -mtune=cortex-a9 -mfpu=vfpv3-d16"
+        use_cpu=cortex-a9],
+      [ CFLAGS="$SAVE_CFLAGS -Wa,-march=armv6 -mtune=cortex-a8 -mthumb-interwork"
+        CXXFLAGS="$CXXFLAGS -Wa,-march=armv6 -mtune=cortex-a8 -mthumb-interwork"    
+        use_cpu=cortex-a8])
+  else
+    if test "$use_neon" = "yes"; then 
+      CFLAGS="$CFLAGS -mfpu=neon -mvectorize-with-neon-quad"
+      CXXFLAGS="$CXXFLAGS -mfpu=neon -mvectorize-with-neon-quad"
+      FFMPEG_EXTRACFLAGS="$FFMPEG_EXTRACFLAGS -mfpu=neon"
+    fi
+  fi
+fi
+
+# Checks for library functions.
+AC_FUNC_ALLOCA
+AC_FUNC_CHOWN
+AC_FUNC_CLOSEDIR_VOID
+AC_FUNC_ERROR_AT_LINE
+AC_FUNC_FSEEKO
+AC_PROG_GCC_TRADITIONAL
+AC_FUNC_LSTAT
+AC_FUNC_LSTAT_FOLLOWS_SLASHED_SYMLINK
+AC_FUNC_MEMCMP
+AC_FUNC_MKTIME
+AC_FUNC_MMAP
+# Boxee is apparently having compile problems
+# if HAVE_REALLOC is defined.  Sort this later.
+#AC_FUNC_REALLOC
+AC_FUNC_SELECT_ARGTYPES
+AC_FUNC_SETVBUF_REVERSED
+AC_TYPE_SIGNAL
+AC_FUNC_STAT
+AC_FUNC_STRCOLL
+AC_FUNC_STRFTIME
+AC_FUNC_STRTOD
+AC_FUNC_UTIME_NULL
+AC_FUNC_VPRINTF
+AC_CHECK_FUNCS([atexit dup2 fdatasync floor fs_stat_dev ftime ftruncate getcwd gethostbyaddr gethostbyname gethostname getpagesize getpass gettimeofday inet_ntoa lchown localeconv memchr memmove memset mkdir modf munmap pow rmdir select setenv setlocale socket sqrt strcasecmp strchr strcspn strdup strerror strncasecmp strpbrk strrchr strspn strstr strtol strtoul sysinfo tzset utime])
+
+# Check for various sizes
+AC_CHECK_SIZEOF([int])
+AC_CHECK_SIZEOF([size_t])
+
+# Check for intrinsics
+AC_MSG_CHECKING([for __sync_add_and_fetch(temp, 1)])
+AC_TRY_LINK([],[long* temp=0; long ret=__sync_add_and_fetch(temp, 1);],
+                [have_builtin_sync_add_and_fetch=yes],
+                [have_builtin_sync_add_and_fetch=no])
+AC_MSG_RESULT($have_builtin_sync_add_and_fetch)
+if test "x$have_builtin_sync_add_and_fetch" = "xyes"; then
+    AC_DEFINE(HAS_BUILTIN_SYNC_ADD_AND_FETCH, 1,
+        [Define to 1 if your compiler supports the __sync_add_and_fetch() intrinsic.])
+fi
+
+AC_MSG_CHECKING([for __sync_sub_and_fetch(temp, 1)])
+AC_TRY_LINK([],[long* temp=0; long ret=__sync_sub_and_fetch(temp, 1);],
+                [have_builtin_sync_sub_and_fetch=yes],
+                [have_builtin_sync_sub_and_fetch=no])
+AC_MSG_RESULT($have_builtin_sync_sub_and_fetch)
+if test "x$have_builtin_sync_sub_and_fetch" = "xyes"; then
+    AC_DEFINE(HAS_BUILTIN_SYNC_SUB_AND_FETCH, 1,
+        [Define to 1 if your compiler supports the __sync_sub_and_fetch() intrinsic.])
+fi
+
+AC_MSG_CHECKING([for __sync_val_compare_and_swap(temp, 1, 1)])
+AC_TRY_LINK([],[long *temp = 0; long ret=__sync_val_compare_and_swap(temp, 1, 1);],
+                [have_builtin_sync_val_compare_and_swap=yes],
+                [have_builtin_sync_val_compare_and_swap=no])
+AC_MSG_RESULT($have_builtin_sync_val_compare_and_swap)
+if test "x$have_builtin_sync_val_compare_and_swap" = "xyes"; then
+    AC_DEFINE(HAS_BUILTIN_SYNC_VAL_COMPARE_AND_SWAP, 1,
+        [Define to 1 if your compiler supports the __sync_val_compare_and_swap() intrinsic.])
+fi
+
+# Add top source directory for all builds so we can use config.h
+INCLUDES="-I\$(abs_top_srcdir) $INCLUDES" 
+
+# Check inotify availability
+AC_CHECK_HEADER([sys/inotify.h], AC_DEFINE([HAVE_INOTIFY],[1],[Define if we have inotify]),)
+
+# Checks for boost headers using CXX instead of CC
+AC_LANG_PUSH([C++])
+AC_CHECK_HEADER([boost/shared_ptr.hpp],, AC_MSG_ERROR($missing_library))
+AC_LANG_POP([C++])
+
+# Python
+if test -z "$PYTHON_NOVERSIONCHECK"; then
+  AX_PYTHON_DEVEL([>= 2.4])
+  PYTHON_VERSION=$ac_python_version
+fi
+
+if test -z "$PYTHON_VERSION"; then
+  AC_MSG_ERROR([Can't find a Python version.])
+else
+  LIBS="$LIBS $PYTHON_LDFLAGS"
+  AC_MSG_NOTICE([Using Python $PYTHON_VERSION])
+fi
+
+# Checks for platforms libraries.
+if test "$use_gles" = "yes"; then
+  use_gl="no"
+  # GLES overwrites GL if both set to yes.
+  if test "$host_vendor" = "apple" ; then
+    AC_DEFINE([HAVE_LIBEGL],[1],["Define to 1 if you have the `EGL' library (-lEGL)."])
+    AC_DEFINE([HAVE_LIBGLESV2],[1],["Define to 1 if you have the `GLESv2' library (-lGLESv2)."])
+    AC_MSG_RESULT(== WARNING: OpenGLES support is assumed.)
+  else
+    if test "$target_platform" = "target_raspberry_pi"; then
+      AC_DEFINE([HAVE_LIBEGL],[1],["Define to 1 if you have the `EGL' library (-lEGL)."])
+      AC_DEFINE([HAVE_LIBGLESV2],[1],["Define to 1 if you have the `GLESv2' library (-lGLESv2)."])
+      AC_MSG_RESULT(== WARNING: OpenGLES support is assumed.)
+      LIBS="$LIBS -lEGL -lGLESv2 -lbcm_host -lvcos -lvchiq_arm"
+    else
+      AC_CHECK_LIB([EGL],   [main],, AC_MSG_ERROR($missing_library))
+      AC_CHECK_LIB([GLESv2],[main],, AC_MSG_ERROR($missing_library))
+    fi
+  fi
+else
+  if test "$use_gl" = "yes"; then
+    if test "$host_vendor" = "apple" ; then
+      # linking to OpenGL.framework instead of libGL, libGLU so AC_CHECK_LIB will fail
+      LIBS="$LIBS -framework OpenGL"
+      AC_DEFINE([HAVE_LIBGL],[1],["Define to 1 if you have the `GL' library (-lGL)."])
+      AC_MSG_RESULT(== WARNING: OpenGL support is assumed.)
+      AC_DEFINE([HAVE_LIBGLU],[1],["Define to 1 if you have the `GLU' library (-lGLU)."])
+      AC_MSG_RESULT(== WARNING: OpenGLU support is assumed.)
+      AC_CHECK_LIB([GLEW],[main],, AC_MSG_ERROR($missing_library))
+    else
+      AC_CHECK_LIB([GL],  [main],, AC_MSG_ERROR($missing_library))
+      AC_CHECK_LIB([GLEW],[main],, AC_MSG_ERROR($missing_library))
+      AC_CHECK_LIB([GLU], [main],, AC_MSG_ERROR($missing_library))
+    fi
+  else
+    AC_MSG_RESULT(== WARNING: OpenGL support is disabled. XBMC will run VERY slow. ==)
+    AC_CHECK_LIB([SDL_gfx],[main])
+  fi
+fi
+
+# platform common libraries
+if test "$use_mysql" = "yes"; then
+  AC_PATH_PROG(MYSQL_CONFIG, mysql_config,"no")
+  if test "x$MYSQL_CONFIG" != "xno"; then
+    AC_DEFINE([HAVE_MYSQL],[1],["Define to 1 if you have the `mysql' library (-lmysqlclient)."])
+    INCLUDES="$INCLUDES `$MYSQL_CONFIG --include`"
+    MYSQL_LIBS=`$MYSQL_CONFIG --libs`
+    LIBS="$LIBS $MYSQL_LIBS"
+    AC_SUBST(MYSQL_LIBS)
+  else
+    AC_MSG_ERROR($missing_program)
+  fi
+fi
+AC_CHECK_HEADER([ass/ass.h],, AC_MSG_ERROR($missing_library))
+AC_CHECK_HEADER([mpeg2dec/mpeg2.h],, AC_MSG_ERROR($missing_library))
+AC_CHECK_HEADER([mpeg2dec/mpeg2convert.h],, AC_MSG_ERROR($missing_library),
+  AC_INCLUDES_DEFAULT()
+  [#include <mpeg2dec/mpeg2.h>])
+AC_CHECK_HEADER([mad.h],,            AC_MSG_ERROR($missing_library))
+AC_CHECK_HEADER([jpeglib.h],,        AC_MSG_ERROR($missing_library))
+AC_CHECK_HEADER([samplerate.h],,     AC_MSG_ERROR($missing_library))
+AC_CHECK_HEADER([ogg/ogg.h],,        AC_MSG_ERROR($missing_library))
+AC_CHECK_HEADER([vorbis/vorbisfile.h],, AC_MSG_ERROR($missing_library))
+AC_CHECK_HEADER([libmodplug/modplug.h],, AC_MSG_ERROR($missing_library))
+AC_CHECK_HEADER([curl/curl.h],, AC_MSG_ERROR($missing_library))
+AC_CHECK_HEADER([FLAC/stream_decoder.h],, AC_MSG_ERROR($missing_library))
+
+# we need to check for the header because if it exists we set the openssl
+# and gcrypt MT callback hooks. This is mostly so that libcurl operates 
+# in MT manner correctly.
+AC_CHECK_HEADER([openssl/crypto.h], AC_DEFINE([HAVE_OPENSSL],[1],[Define if we have openssl]),)
+AC_CHECK_HEADER([gcrypt.h], gcrypt_headers_available=yes,gcrypt_headers_available=no)
+if test "$gcrypt_headers_available" = "yes"; then
+   # if we have the headers then we must have the lib
+   AC_CHECK_LIB([gpg-error],[main],, AC_MSG_ERROR($missing_library))
+   AC_CHECK_LIB([gcrypt],[gcry_control],, AC_MSG_ERROR($missing_library))
+   AC_DEFINE([HAVE_GCRYPT],[1],[Define if we have gcrypt])
+fi
+
+AC_CHECK_LIB([bz2],         [main],, AC_MSG_ERROR($missing_library))
+AC_CHECK_LIB([jpeg],        [main],, AC_MSG_ERROR($missing_library)) # check for cximage
+AC_CHECK_LIB([tiff],        [main],, AC_MSG_ERROR($missing_library))
+if echo "$ARCH" | grep -q freebsd; then
+AC_CHECK_LIB([pthread],     [main],LIBS="-pthread $LIBS", AC_MSG_ERROR($missing_library))
+AC_CHECK_LIB([pthread],     [pthread_set_name_np],
+  AC_DEFINE([HAVE_PTHREAD_SET_NAME_NP],[1],["Define to 1 if pthread has pthread_set_name_np"]),
+  AC_MSG_RESULT([Could not find pthread_set_name_np in pthread]))
+else
+if test "$target_platform" != "target_android" ; then
+  AC_CHECK_LIB([pthread],     [main],, AC_MSG_ERROR($missing_library))
+  AC_CHECK_LIB([pthread],     [pthread_setname_np],
+    AC_DEFINE([HAVE_PTHREAD_SETNAME_NP],[1],["Define to 1 if pthread has pthread_setname_np"]),
+    AC_MSG_RESULT([Could not find pthread_setname_np in pthread]))
+fi
+fi
+AC_CHECK_LIB([lzo2],        [main],, AC_MSG_ERROR($missing_library))
+AC_CHECK_LIB([z],           [main],, AC_MSG_ERROR($missing_library))
+AC_CHECK_LIB([crypto],      [main],, AC_MSG_ERROR($missing_library))
+AC_CHECK_LIB([ssl],         [main],, AC_MSG_ERROR($missing_library))
+if test "$use_mysql" = "yes"; then
+  AC_CHECK_LIB([mysqlclient], [main],, AC_MSG_ERROR($missing_library))
+fi
+AC_CHECK_LIB([bluetooth],   [hci_devid],, AC_MSG_RESULT([Could not find suitable version of libbluetooth]))
+AC_CHECK_LIB([yajl],        [main],, AC_MSG_ERROR($missing_library))
+AC_CHECK_LIB([tinyxml],     [main],, AC_MSG_ERROR($missing_library))
+if test "$target_platform" = "target_android" ; then
+  #android hack for static python. Required to maintain correct linking order.
+  AC_CHECK_LIB([python$PYTHON_VERSION],      [main],, AC_MSG_ERROR($missing_library))
+  AC_CHECK_LIB([android],     [main],, AC_MSG_ERROR($missing_library))
+fi
+PKG_CHECK_MODULES([FRIBIDI],    [fribidi],
+  [INCLUDES="$INCLUDES $FRIBIDI_CFLAGS"; LIBS="$LIBS $FRIBIDI_LIBS"],
+  AC_MSG_ERROR($missing_library))
+PKG_CHECK_MODULES([SQLITE3],    [sqlite3],
+  [INCLUDES="$INCLUDES $SQLITE3_CFLAGS"; LIBS="$LIBS $SQLITE3_LIBS"],
+  AC_MSG_ERROR($missing_library))
+PKG_CHECK_MODULES([PNG],        [libpng],
+  [INCLUDES="$INCLUDES $PNG_CFLAGS"; LIBS="$LIBS $PNG_LIBS"],
+  AC_MSG_ERROR($missing_library))
+PKG_CHECK_MODULES([PCRECPP],    [libpcrecpp],
+  [INCLUDES="$INCLUDES $PCRECPP_CFLAGS"; LIBS="$LIBS $PCRECPP_LIBS"]; \
+  AC_DEFINE([HAVE_LIBPCRECPP],[1],["Define to 1 if libpcrecpp is installed"]),
+  AC_MSG_ERROR($missing_library))
+PKG_CHECK_MODULES([PCRE],       [libpcre],
+  [INCLUDES="$INCLUDES $PCRE_CFLAGS"; LIBS="$LIBS $PCRE_LIBS"]; \
+  AC_DEFINE([HAVE_LIBPCRE],[1],["Define to 1 if libpcre is installed"]),
+  AC_MSG_ERROR($missing_library))
+PKG_CHECK_MODULES([CDIO],       [libcdio],
+  [INCLUDES="$INCLUDES $CDIO_CFLAGS"; LIBS="$LIBS $CDIO_LIBS"],
+  AC_MSG_ERROR($missing_library))
+PKG_CHECK_MODULES([SAMPLERATE], [samplerate],
+  [INCLUDES="$INCLUDES $SAMPLERATE_CFLAGS"; LIBS="$LIBS $SAMPLERATE_LIBS"],
+  AC_MSG_ERROR($missing_library))
+PKG_CHECK_MODULES([FREETYPE2],  [freetype2],
+  [INCLUDES="$INCLUDES $FREETYPE2_CFLAGS"; LIBS="$LIBS $FREETYPE2_LIBS"],
+  AC_MSG_ERROR($missing_library))
+PKG_CHECK_MODULES([TAGLIB],  [taglib >= 1.8],
+  [INCLUDES="$INCLUDES $TAGLIB_CFLAGS"; LIBS="$LIBS $TAGLIB_LIBS"],
+  AC_MSG_ERROR($missing_library))
+
+if test "$target_platform" = "target_android" ; then
+PKG_CHECK_MODULES([ZIP],       [libzip],
+  [INCLUDES="$INCLUDES $ZIP_CFLAGS"; LIBS="$LIBS $ZIP_LIBS"],
+  AC_MSG_ERROR($missing_library))
+fi
+
+# check for libbluray
+AS_CASE([x$use_libbluray],
+  [xyes],[
+    PKG_CHECK_MODULES([LIBBLURAY],[libbluray >= 0.2.1],[use_libbluray="yes"], AC_MSG_ERROR($missing_library))
+  ],
+  [xauto],[
+    PKG_CHECK_MODULES([LIBBLURAY],[libbluray >= 0.2.1],[use_libbluray="yes"], [use_libbluray="no"])
+  ])
+
+AS_CASE([x$use_libbluray],
+  [xyes],[
+    INCLUDES="$INCLUDES $LIBBLURAY_CFLAGS";
+    XB_FIND_SONAME([BLURAY], [bluray], [use_libbluray])
+    AC_DEFINE([HAVE_LIBBLURAY], 1, [System has libbluray library])
+    AC_SUBST([HAVE_LIBBLURAY], 1)
+  ],[
+    AC_SUBST([HAVE_LIBBLURAY], 0)
+  ]
+)
+
+# platform dependent libraries
+if test "$host_vendor" = "apple" ; then
+  AC_CHECK_LIB([iconv],     [main],, AC_MSG_ERROR($missing_library))
+  if test "$use_arch" != "arm"; then
+    AC_CHECK_LIB([SDL],      [main],, AC_MSG_ERROR($missing_library))
+    AC_DEFINE([HAVE_SDL],[1],["Define to 1 if using sdl"])
+  fi
+else
+  case $host_os in
+    linux*) AC_CHECK_LIB([dl], [main],, AC_MSG_ERROR($missing_library)) ;;
+    freebsd*) AC_CHECK_LIB([iconv], [main],, AC_MSG_ERROR($missing_library)) ;;
+  esac
+  case $host_os in
+    freebsd*) ;;
+    *)
+     if test "$target_platform" != "target_android" ; then
+        AC_CHECK_LIB([resolv],     [main],, AC_MSG_ERROR($missing_library))
+     fi
+  ;;
+  esac
+if test "$target_platform" != "target_android" ; then
+  AC_CHECK_LIB([jasper],     [main],, AC_MSG_ERROR($missing_library)) # check for cximage
+  AC_CHECK_LIB([rt],         [clock_gettime],, AC_MSG_ERROR($missing_library))
+fi
+if test "x$use_alsa" != "xno"; then
+  PKG_CHECK_MODULES([ALSA],  [alsa],
+    [INCLUDES="$INCLUDES $ALSA_CFLAGS"; LIBS="$LIBS $ALSA_LIBS"; use_alsa=yes],
+    AC_MSG_NOTICE($alsa_not_found); use_alsa=no)
+fi
+  PKG_CHECK_MODULES([DBUS],    [dbus-1],
+    [INCLUDES="$INCLUDES $DBUS_CFLAGS"; LIBS="$LIBS $DBUS_LIBS"; use_dbus=yes]; \
+    AC_DEFINE([HAVE_DBUS],[1],["Define to 1 if dbus is installed"]),
+    AC_MSG_NOTICE($missing_library); use_dbus=no)
+  if test "x$use_sdl" != "xno"; then
+    PKG_CHECK_MODULES([SDL],   [sdl],
+      [INCLUDES="$INCLUDES $SDL_CFLAGS"; LIBS="$LIBS $SDL_LIBS"],
+      AC_MSG_ERROR($missing_library))
+    AC_CHECK_LIB([SDL_image],  [main],, AC_MSG_ERROR($missing_library))
+    AC_DEFINE([HAVE_SDL],[1],["Define to 1 if using sdl"])
+  fi
+fi
+
+XB_FIND_SONAME([MAD],         [mad])
+XB_FIND_SONAME([OGG],         [ogg])
+XB_FIND_SONAME([CURL],        [curl])
+XB_FIND_SONAME([FLAC],        [FLAC])
+XB_FIND_SONAME([VORBIS],      [vorbis])
+XB_FIND_SONAME([VORBISFILE],  [vorbisfile])
+XB_FIND_SONAME([MODPLUG],     [modplug])
+XB_FIND_SONAME([ASS],         [ass])
+XB_FIND_SONAME([MPEG2],       [mpeg2])
+
+# Audio encoders
+if test "x$use_libmp3lame" != "xno"; then
+  XB_FIND_SONAME([LAMEENC], [mp3lame], [use_libmp3lame])
+  if test "x$use_libmp3lame" != "xno"; then
+    AC_CHECK_HEADER([lame/lame.h],, AC_MSG_ERROR($missing_headers))
+  fi
+fi
+AS_CASE([x$use_libmp3lame],
+  [xno],[
+    AC_SUBST([HAVE_LIBMP3LAME], 0)
+  ],
+  [
+    AC_DEFINE([HAVE_LIBMP3LAME], 1, [System has libmp3lame library])
+    AC_SUBST([HAVE_LIBMP3LAME], 1)
+  ]
+)
+if test "x$use_libvorbisenc" != "xno"; then
+  XB_FIND_SONAME([VORBISENC], [vorbisenc], [use_libvorbisenc])
+  if test "x$use_libvorbisenc" != "xno"; then
+    AC_CHECK_HEADER([vorbis/vorbisenc.h],, AC_MSG_ERROR($missing_headers))
+  fi
+fi
+AS_CASE([x$use_libvorbisenc],
+  [xno],[
+    AC_SUBST([HAVE_LIBVORBISENC], 0)
+  ],[
+    AC_DEFINE([HAVE_LIBVORBISENC], 1, [System has libvorbisenc library])
+    AC_SUBST([HAVE_LIBVORBISENC], 1)
+  ]
+)
+
+# WebServer
+if test "$use_webserver" = "yes"; then
+  AC_CHECK_LIB([microhttpd],  [main],, AC_MSG_ERROR($missing_library))
+fi
+
+# Optical
+if test "$use_optical_drive" = "yes"; then
+  AC_DEFINE([HAS_DVD_DRIVE], [1], [Define to 1 to have optical drive support])
+fi
+
+# Alsa
+if test "$use_alsa" = "yes" && test "$host_vendor" != "apple"; then
+  PKG_CHECK_MODULES([ALSA],  [alsa],
+    [INCLUDES="$INCLUDES $ALSA_CFLAGS"; LIBS="$LIBS $ALSA_LIBS"],
+    AC_MSG_ERROR($missing_library))
+  AC_DEFINE([HAS_ALSA], [1], [Define to 0 to disable ALSA support])
+else
+  use_alsa="no"
+  AC_MSG_RESULT($alsa_disabled)
+fi
+
+# PulseAudio
+if test "x$use_pulse" != "xno"; then
+  if test "$host_vendor" = "apple" ; then
+    if test "x$use_pulse" = "xyes"; then
+      AC_MSG_ERROR($pulse_disabled)
+    else
+      use_pulse="no"
+      AC_MSG_RESULT($pulse_disabled)
+    fi
+    USE_PULSE=0
+  else
+    AC_CHECK_LIB([pulse],[main],,pulse_found="no")
+    AC_CHECK_LIB([pulse-simple],[main],,pulse_found="no")
+
+    if test "x$pulse_found" != "xno"; then
+      USE_PULSE=1
+    elif test "x$use_pulse" = "xyes"; then
+      AC_MSG_ERROR($pulse_not_found)
+    else
+      use_pulse=no
+      USE_PULSE=0
+      AC_MSG_RESULT($pulse_not_found)
+    fi
+  fi
+else
+  AC_MSG_RESULT($pulse_disabled)
+  USE_PULSE=0
+fi
+
+# HAL
+if test "$host_vendor" = "apple" ; then
+  use_hal="no"
+  AC_MSG_RESULT($hal_disabled)
+else
+  if test "$use_hal" = "yes"; then
+    PKG_CHECK_MODULES([HAL], [hal],
+      [INCLUDES="$INCLUDES $HAL_CFLAGS"; LIBS="$LIBS $HAL_LIBS"],
+      use_hal=no;AC_MSG_RESULT($hal_not_found))
+    PKG_CHECK_MODULES([HAL_STORAGE], [hal-storage],
+      [INCLUDES="$INCLUDES $HAL_STORAGE_CFLAGS"; LIBS="$LIBS $HAL_STORAGE_LIBS"],
+      use_hal=no;AC_MSG_RESULT($halstorage_not_found))
+  else
+    AC_MSG_RESULT($hal_disabled)
+  fi
+  if test "$use_hal" = "yes"; then
+    AC_DEFINE([HAS_HAL], [1], [Define to 1 if you have HAL installed])
+  fi
+fi
+
+# avahi
+if test "$host_vendor" = "apple" ; then
+  use_avahi="no"
+  AC_MSG_RESULT($avahi_disabled)
+else
+  if test "$use_avahi" = "yes"; then
+    AC_CHECK_LIB([avahi-common], [main],,
+      use_avahi=no;AC_MSG_RESULT($avahi_not_found))
+    if test "$use_avahi" = "yes"; then
+      #either both libs or none
+      AC_CHECK_LIB([avahi-client], [main],,
+        use_avahi=no;AC_MSG_RESULT($avahi_not_found))
+    fi
+  else
+    AC_MSG_RESULT($avahi_disabled)
+  fi
+fi
+
+# X11
+if test "$use_x11" = "yes" && test "$host_vendor" != "apple"; then
+  AC_MSG_NOTICE($x11_enabled)
+  PKG_CHECK_MODULES([X11],    [x11],
+    [INCLUDES="$INCLUDES $X11_CFLAGS"; LIBS="$LIBS $X11_LIBS"],
+    AC_MSG_ERROR($missing_library))
+  PKG_CHECK_MODULES([XEXT],  [xext],
+    [INCLUDES="$INCLUDES $XEXT_CFLAGS"; LIBS="$LIBS $XEXT_LIBS"],
+    AC_MSG_ERROR($missing_library))
+  AC_DEFINE([HAVE_X11], [1], [Define to 1 if you have X11 libs installed.])
+else
+  AC_MSG_RESULT($x11_disabled)
+fi
+
+# XRandR
+if test "$host_vendor" = "apple" || test "$use_x11" = "no"; then
+  use_xrandr="no"
+  AC_MSG_RESULT($xrandr_disabled)
+else
+  if test "$use_xrandr" = "yes" ; then
+    AC_CHECK_LIB([Xrandr], [main],,
+      use_xrandr="no";AC_MSG_RESULT($xrandr_not_found))
+  else
+    AC_MSG_RESULT($xrandr_disabled)
+  fi
+fi
+
+# GOOM
+if test "$host_vendor" = "apple" ; then
+  AC_MSG_NOTICE($goom_disabled)
+  DISABLE_GOOM=1
+else
+  if test "$use_goom" = "yes" && test "$use_gl" = "yes"; then
+    AC_MSG_NOTICE($goom_enabled)
+    DISABLE_GOOM=0
+  else
+    AC_MSG_NOTICE($goom_disabled)
+    DISABLE_GOOM=1
+  fi
+fi
+
+# RSXS
+if test "$use_rsxs" = "no" || test "$use_gl" = "no"; then
+  AC_MSG_NOTICE($rsxs_disabled)
+  DISABLE_RSXS=1
+else
+  AC_MSG_NOTICE($rsxs_enabled)
+  DISABLE_RSXS=0
+  # darwin osx can do rsxs but does not use x11, so do not pkg-config check for them
+  if test "$host_vendor" != "apple" ; then
+    PKG_CHECK_MODULES([XT],    [xt],
+      [INCLUDES="$INCLUDES $XT_CFLAGS"; LIBS="$LIBS $XT_LIBS"],
+      AC_MSG_ERROR($missing_library))
+    PKG_CHECK_MODULES([XMU],   [xmu],
+      [INCLUDES="$INCLUDES $XMU_CFLAGS"; LIBS="$LIBS $XMU_LIBS"],
+      AC_MSG_ERROR($missing_library))
+  fi
+fi
+
+# PROJECTM
+if test "$use_projectm" = "no" || test "$use_gl" = "no"; then
+  AC_MSG_NOTICE($projectm_disabled)
+  DISABLE_PROJECTM=1
+else
+  AC_MSG_NOTICE($projectm_enabled)
+  DISABLE_PROJECTM=0
+fi
+
+# skin touched
+use_skin_touched=no
+if [[ -f "addons/skin.touched/addon.xml" ]]; then 
+  use_skin_touched=yes
+  USE_SKIN_TOUCHED=1
+  AC_DEFINE([HAS_SKIN_TOUCHED], [1], [Whether to build skin touched.])
+else
+  USE_SKIN_TOUCHED=0
+fi
+
+# libssh
+if test "x$use_ssh" = "xno"; then
+  AC_MSG_NOTICE($ssh_disabled)
+  use_libssh="no"
+else
+  AC_CHECK_LIB([ssh], [sftp_tell64],, AC_MSG_ERROR($ssh_not_found))
+  AC_DEFINE([HAVE_LIBSSH], [1], [Whether to use libSSH library.])
+fi
+
+# libRTMP
+if test "$use_librtmp" != "no"; then
+  AC_CHECK_HEADERS([librtmp/log.h librtmp/amf.h librtmp/rtmp.h],,
+   [if test "$use_librtmp" = "yes"; then
+      AC_MSG_ERROR($librtmp_not_found)
+    elif test "$use_librtmp" != "no"; then
+      AC_MSG_NOTICE($librtmp_not_found)
+      use_librtmp="no"
+    fi
+   ])
+  if test "$use_librtmp" != "no"; then
+    XB_FIND_SONAME([RTMP], [rtmp], [use_librtmp])
+  fi
+  if test "$use_librtmp" != "no"; then
+    AC_DEFINE([HAS_LIBRTMP], [1], [Whether to use libRTMP library.])
+  fi
+else
+  AC_MSG_NOTICE($librtmp_disabled)
+fi
+
+# samba
+if test "x$use_samba" != "xno"; then
+  AC_CHECK_LIB([smbclient], [main],,
+    use_samba=no;AC_MSG_ERROR($missing_library))
+    USE_LIBSMBCLIENT=0
+else
+  AC_MSG_RESULT($samba_disabled)
+  USE_LIBSMBCLIENT=0
+fi
+
+if test "x$use_samba" != "xno"; then
+  AC_DEFINE([HAVE_LIBSMBCLIENT], [1], [Define to 1 if you have Samba installed])
+  USE_LIBSMBCLIENT=1
+fi
+
+# libnfs
+if test "$use_libnfs" != "no"; then
+  AC_CHECK_HEADERS([nfsc/libnfs.h],,
+   [if test "$use_libnfs" = "yes"; then
+      AC_MSG_ERROR($libnfs_not_found)
+      USE_LIBNFS=0
+    elif test "$use_libnfs" != "no"; then
+      AC_MSG_NOTICE($libnfs_not_found)
+      use_libnfs="no"
+      USE_LIBNFS=0
+    fi
+   ])
+  if test "$use_libnfs" != "no"; then
+    XB_FIND_SONAME([NFS], [nfs], [use_libnfs])
+  fi
+  if test "$use_libnfs" != "no"; then
+    AC_DEFINE([HAVE_LIBNFS], [1], [Whether to use libnfs library.])
+    USE_LIBNFS=1
+  fi
+else
+  USE_LIBNFS=0
+  AC_MSG_NOTICE($libnfs_disabled)
+fi
+
+# libafpclient
+USE_LIBAFPCLIENT=0
+if test "x$use_libafpclient" != "xno"; then
+  AC_CHECK_HEADERS([afpfs-ng/libafpclient.h],,
+   [if test "x$use_libafpclient" = "xyes"; then
+      AC_MSG_ERROR($libafpclient_not_found)
+    elif test "x$use_libafpclient" != "xno"; then
+      AC_MSG_NOTICE($libafpclient_not_found)
+      use_libafpclient="no"
+    fi
+   ])
+  if test "x$use_libafpclient" != "xno"; then
+    XB_FIND_SONAME([AFPCLIENT], [afpclient], [use_libafpclient])
+    AC_DEFINE([HAVE_LIBAFPCLIENT], [1], [Whether to use libafpclient library.])
+    USE_LIBAFPCLIENT=1
+  fi
+else
+  AC_MSG_NOTICE($libafpclient_disabled)
+fi
+
+# libplist for airplay feature
+USE_AIRPLAY=0
+if test "$use_airplay" != "no"; then
+  AC_CHECK_HEADER([plist/plist.h],,
+   [if test "$use_airplay" = "yes"; then
+      AC_MSG_ERROR($libplist_not_found)
+    elif test "$use_airplay" != "no"; then
+      AC_MSG_NOTICE($libplist_not_found)
+      use_airplay="no"
+    fi
+   ])
+
+  if test "$use_airplay" != "no"; then
+    XB_FIND_SONAME([PLIST], [plist], [use_airplay])
+    USE_AIRPLAY=1
+    AC_DEFINE([HAVE_LIBPLIST],[1],["Define to 1 if you have libplist."])
+  fi
+fi
+
+# libshairport for AirTunes
+USE_AIRTUNES=0
+if test "x$use_airtunes" != "xno"; then
+  AC_CHECK_HEADERS([shairport/shairport.h],,
+   [if test "x$use_airtunes" = "xyes"; then
+      AC_MSG_ERROR($libshairport_not_found)
+    elif test "x$use_airtunes" != "xno"; then
+      AC_MSG_NOTICE($libshairport_not_found)
+      use_airtunes="no"
+    fi
+   ])
+
+  if test "x$use_airtunes" != "xno"; then
+    XB_FIND_SONAME([SHAIRPORT], [shairport], [use_airtunes])
+    USE_AIRTUNES=1
+    AC_CHECK_MEMBERS([struct AudioOutput.ao_set_metadata],,,
+                     [[#include <shairport/shairport.h>]])
+    AC_DEFINE([HAVE_LIBSHAIRPORT],[1],["Define to 1 if you have libshairport."])
+  fi
+fi
+
+# libudev
+USE_LIBUDEV=0
+if test "$host_vendor" = "apple" ; then
+  use_libudev="no"
+  AC_MSG_NOTICE($libudev_disabled)
+else
+  if test "$use_libudev" = "auto"; then
+    PKG_CHECK_MODULES([UDEV],[libudev],,[use_libudev="no";AC_MSG_RESULT($libudev_not_found)])
+  elif test "$use_libudev" = "yes" ; then
+    PKG_CHECK_MODULES([UDEV],[libudev],,[use_libudev="no";AC_MSG_ERROR($libudev_not_found)])
+  else
+    AC_MSG_NOTICE($libudev_disabled)
+  fi
+
+  if test "x$use_libudev" != "xno"; then
+    USE_LIBUDEV=1;INCLUDES="$INCLUDES $UDEV_CFLAGS";LIBS="$LIBS $UDEV_LIBS"
+    AC_DEFINE([HAVE_LIBUDEV],[1],["Define to 1 if libudev is installed"])
+  fi
+fi
+
+# libusb
+USE_LIBUSB=0
+
+# if libudev is available, we don't need libusb
+if test "x$use_libudev" != "xno"; then
+  use_libusb="no"
+  AC_MSG_NOTICE($libusb_disabled_udev_found)
+else
+  if test "$host_vendor" = "apple" ; then
+    use_libusb="no"
+    AC_MSG_NOTICE($libusb_disabled)
+  else
+    if echo "$ARCH" | grep -q freebsd ; then
+      AC_CHECK_LIB([usb],[main],
+	  	[use_libusb="yes";USB_LIBS="-lusb"],
+		[use_libusb="no";AC_MSG_RESULT($libusb_not_found)])
+    elif test "$use_libusb" = "auto"; then
+      PKG_CHECK_MODULES([USB],[libusb],,[use_libusb="no";AC_MSG_RESULT($libusb_not_found)])
+    elif test "$use_libusb" = "yes"; then
+      PKG_CHECK_MODULES([USB],[libusb],,[use_libusb="no";AC_MSG_ERROR($libusb_not_found)])
+    else
+      AC_MSG_NOTICE($libusb_disabled)
+    fi
+  
+    if test "x$use_libusb" != "xno"; then
+      USE_LIBUSB=1;INCLUDES="$INCLUDES $USB_CFLAGS";LIBS="$LIBS $USB_LIBS"
+      AC_DEFINE([HAVE_LIBUSB],[1],["Define to 1 if libusb is installed"])
+    fi
+  fi
+fi
+
+# libcec
+USE_LIBCEC=0
+if test "x$use_libcec" != "xno"; then
+  # libcec is dyloaded, so we need to check for its headers and link any depends.
+  if test "x$use_libcec" != "xno"; then
+    if test "x$use_libcec" != "xauto"; then
+      PKG_CHECK_MODULES([CEC],[libcec >= 2.1.0],,[use_libcec="no";AC_MSG_ERROR($libcec_disabled)])
+    else
+      PKG_CHECK_MODULES([CEC],[libcec >= 2.1.0],,[use_libcec="no";AC_MSG_RESULT($libcec_disabled)])
+    fi
+
+    if test "x$use_libcec" != "xno"; then
+      INCLUDES="$INCLUDES $CEC_CFLAGS"
+      USE_LIBCEC=1;AC_DEFINE([HAVE_LIBCEC],[1],["Define to 1 if libcec is installed"])
+      XB_FIND_SONAME([LIBCEC],[cec],[use_libcec])
+      AC_MSG_NOTICE($libcec_enabled)
+    else
+      use_libcec="no"
+      AC_MSG_NOTICE($libcec_disabled)
+    fi
+  fi
+else
+  use_libcec="no"
+  AC_MSG_NOTICE($libcec_disabled)
+fi
+
+# libcap
+if test "$use_libcap" != "no"; then
+  AC_CHECK_HEADERS([sys/capability.h],,
+   [if test "$use_libcap" = "yes"; then
+      AC_MSG_ERROR($libcap_not_found)
+    elif test "$use_libcap" != "no"; then
+      AC_MSG_NOTICE($libcap_not_found)
+      use_libcap="no"
+    fi
+   ])
+  if test "$use_libcap" != "no"; then
+    AC_CHECK_LIB([cap], main, LIBS="$LIBS -lcap", use_libcap=no)
+  fi
+  if test "$use_libcap" != "no"; then
+    AC_DEFINE([HAVE_LIBCAP], [1], [Whether to use libcap library.])
+  fi
+else
+  AC_MSG_NOTICE($libcap_disabled)
+fi
+
+### External libraries checks
+
+# External FFmpeg
+if test "$use_external_ffmpeg" = "yes"; then
+  FFMPEG_LIBNAMES="libavcodec libavfilter libavformat libavutil libpostproc libswscale"
+
+  # libavcore is optional
+  PKG_CHECK_EXISTS([libavcore], FFMPEG_LIBNAMES="$FFMPEG_LIBNAMES libavcore")
+
+  # one of libswresample or libavresample is needed
+  PKG_CHECK_EXISTS([libswresample], FFMPEG_LIBNAMES="$FFMPEG_LIBNAMES libswresample",
+                   [PKG_CHECK_EXISTS([libavresample],
+                                     FFMPEG_LIBNAMES="$FFMPEG_LIBNAMES libavresample",
+                                     AC_MSG_ERROR([You need either libswresample
+                                                   or libavresample.]))])
+
+  PKG_CHECK_MODULES([FFMPEG], [$FFMPEG_LIBNAMES],
+                    [INCLUDES="$INCLUDES $FFMPEG_CFLAGS"; LIBS="$LIBS $FFMPEG_LIBS"],
+                    AC_MSG_ERROR($missing_library))
+
+  # Determine whether AVPacket and relevant functions are defined in libavformat
+  # or libavcodec
+  AC_CHECK_LIB([avcodec], [av_free_packet],
+  [AC_MSG_NOTICE(== AVPacket and relevant functions defined in libavcodec. ==)],
+  [AC_MSG_NOTICE(== AVPacket and relevant functions defined in libavformat. ==)
+   AC_DEFINE([AVPACKET_IN_AVFORMAT], [1], [Whether AVPacket is in libavformat.])])
+
+  # in case the headers are in a custom directory
+  SAVE_CPPFLAGS="$CPPFLAGS"
+  CPPFLAGS="$CPPFLAGS $FFMPEG_CFLAGS"
+
+  # Possible places the ffmpeg headers may be
+  AC_CHECK_HEADERS([libavcodec/avcodec.h libavfilter/avfilter.h libavformat/avformat.h libavutil/avutil.h libpostproc/postprocess.h libswscale/swscale.h],,
+  [AC_CHECK_HEADERS([ffmpeg/avcodec.h ffmpeg/avfilter.h ffmpeg/avformat.h ffmpeg/avutil.h postproc/postprocess.h ffmpeg/swscale.h],,
+  [AC_MSG_ERROR($missing_headers)])])
+
+  # optional
+  AC_CHECK_HEADERS([libavcore/avcore.h libavcore/samplefmt.h libavutil/mem.h libavutil/samplefmt.h])
+
+  # old FFmpeg have this in libavcodec/opt.h instead:
+  AC_CHECK_HEADERS([libavutil/opt.h])
+
+  # new FFmpeg have math headers
+  AC_CHECK_HEADERS([libavutil/mathematics.h],,)
+
+  # We'll support the use of rgb2rgb.h if it exists.
+  AC_CHECK_HEADERS([libswscale/rgb2rgb.h],,)
+  AC_CHECK_HEADERS([ffmpeg/rgb2rgb.h],,)
+
+  # Check for libswresample or libavresample headers.
+  AC_CHECK_HEADERS([libswresample/swresample.h libavresample/avresample.h])
+
+  # Check if AVFilterBufferRefVideoProps AVRational member is named
+  # 'pixel_aspect' or 'sample_aspect_ratio'.
+  AC_CHECK_MEMBER([AVFilterBufferRefVideoProps.sample_aspect_ratio],
+    [AC_DEFINE([HAVE_AVFILTERBUFFERREFVIDEOPROPS_SAMPLE_ASPECT_RATIO],
+    [1],
+    [Define to 1 if AVFilterBufferRefVideoProps has member sample_aspect_ratio.])],
+      [AC_CHECK_MEMBER([AVFilterBufferRefVideoProps.sample_aspect_ratio],
+      [AC_DEFINE([HAVE_AVFILTERBUFFERREFVIDEOPROPS_SAMPLE_ASPECT_RATIO],
+      [1],
+      [Define to 1 if AVFilterBufferRefVideoProps has member sample_aspect_ratio.])],
+      ,
+      [[#include <ffmpeg/avfilter.h>]])],
+    [[#include <libavfilter/avfilter.h>]])
+
+  AC_MSG_NOTICE($external_ffmpeg_enabled)
+  USE_EXTERNAL_FFMPEG=1
+  AC_DEFINE([USE_EXTERNAL_FFMPEG], [1], [Whether to use external FFmpeg libraries.])
+
+  # Disable vdpau support if external libavcodec doesn't have it
+  AC_CHECK_LIB([avcodec], [ff_vdpau_vc1_decode_picture],,
+    [if test "x$use_vdpau" = "xyes"; then
+      AC_MSG_ERROR($ffmpeg_vdpau_not_supported)
+    else
+      use_vdpau=no
+      AC_MSG_RESULT($ffmpeg_vdpau_not_supported)
+    fi])
+
+  # Check for 'PIX_FMT_VDPAU_MPEG4' from libavutil
+  if test "x$use_vdpau" != "xno"; then
+    AC_LANG_PUSH([C++])
+    AC_LINK_IFELSE(
+      [AC_LANG_SOURCE([ #include <libavutil/pixfmt.h>
+        int main() { PixelFormat format = PIX_FMT_VDPAU_MPEG4; }])],
+      [AC_DEFINE([PIX_FMT_VDPAU_MPEG4_IN_AVUTIL], [1],
+      [Whether AVUtil defines PIX_FMT_VDPAU_MPEG4.])],)
+    AC_LANG_POP([C++])
+  fi
+  CPPFLAGS="$SAVE_CPPFLAGS"
+else
+  AC_MSG_NOTICE($external_ffmpeg_disabled)
+  USE_EXTERNAL_FFMPEG=0
+  AC_DEFINE([PIX_FMT_VDPAU_MPEG4_IN_AVUTIL], [1], [Whether AVUtil defines PIX_FMT_VDPAU_MPEG4.])
+fi
+
+echo "Checking for SWIG installation"
+AC_PATH_PROG(SWIG_EXE, swig, "none")
+if test "$SWIG_EXE" = "none"; then
+  AC_PATH_PROG(SWIG20_EXE, swig2.0, "none")
+  if test "$SWIG20_EXE" != "none" ; then
+    SWIG_EXE=$SWIG20_EXE
+  fi
+fi
+if test "$SWIG_EXE" = "none"; then
+  AC_MSG_ERROR($missing_program)
+fi
+final_message="$final_message\n  SWIG Available:\tYes"
+
+echo "Checking for a jre installation"
+AC_PATH_PROG(JAVA_EXE, java, "none")
+if test "$JAVA_EXE" = "none"; then
+  AC_MSG_ERROR($missing_program)
+fi
+final_message="$final_message\n  JRE Available:\tYes"
+
+echo "Checking for doxygen installation"
+AC_PATH_PROG(DOXYGEN_EXE, doxygen, "none")
+if test "$DOXYGEN_EXE" = "none"; then
+  AC_MSG_WARN([Unable to find doxygen installation. Will not be able to make docstrings for the python api])
+  final_message="$final_message\n  Doxygen Available:\tNo"
+  USE_DOXYGEN=0
+else
+  final_message="$final_message\n  Doxygen Available:\tYes"
+  USE_DOXYGEN=1
+fi
+
+# VDPAU
+if test "x$use_vdpau" != "xno"; then
+  if test "$host_vendor" = "apple" ; then
+    if test "x$use_vdpau" = "xyes"; then
+      AC_MSG_ERROR([VDPAU not supported on this platform])
+    else
+      use_vdpau="no"
+      AC_MSG_NOTICE($vdpau_disabled)
+    fi
+    USE_VDPAU=0
+  else
+    USE_VDPAU=1
+    AC_CHECK_HEADER([vdpau/vdpau.h],AC_DEFINE([HAVE_LIBVDPAU], [],
+      [Define to 1 if you have the 'vdpau' library (-lvdpau).]),
+    [if test "x$use_vdpau" = "xyes"; then
+      USE_VDPAU=0
+      AC_MSG_ERROR([$vdpau_not_found])
+    else
+      use_vdpau="no"
+      USE_VDPAU=0
+      AC_MSG_RESULT($vdpau_not_found)
+    fi])
+  fi
+else
+  USE_VDPAU=0
+  AC_MSG_NOTICE($vdpau_disabled)
+fi
+
+# VAAPI
+if test "x$use_vaapi" != "xno"; then
+  if test "$host_vendor" = "apple" ; then
+    if test "x$use_vaapi" = "xyes"; then
+      AC_MSG_ERROR([VAAPI not supported on this platform])
+    else
+      use_vaapi="no"
+      AC_MSG_NOTICE($vaapi_disabled)
+    fi
+    USE_VAAPI=0
+  else
+    initial_val=$use_vaapi
+    AC_CHECK_LIB([va], main, :, use_vaapi=no)
+    if test "x$use_vaapi" != "xno"; then
+      AC_CHECK_LIB([va-glx], main, LIBS="-lva -lva-glx $LIBS", use_vaapi=no, -lva)
+    fi
+
+    if test "x$use_vaapi" = "xno"; then
+      if test "x$initial_val" = "xyes"; then
+        AC_MSG_ERROR($vaapi_not_found)
+      else
+        AC_MSG_RESULT($vaapi_not_found)
+      fi
+      USE_VAAPI=0
+    else
+      AC_DEFINE([HAVE_LIBVA], [1], [Define to 1 if you have the 'vaapi' libraries (-lva AND -lva-glx)])
+      USE_VAAPI=1
+    fi
+  fi
+else
+  AC_MSG_NOTICE($vaapi_disabled)
+  USE_VAAPI=0
+fi
+
+# CrystalHD
+if test "x$use_crystalhd" != "xno"; then
+  SAVE_CFLAGS="$CFLAGS"
+  CFLAGS="-D__LINUX_USER__"
+  AC_CHECK_HEADER([libcrystalhd/libcrystalhd_if.h], [],
+    [ if test "x$use_crystalhd" = "xyes"; then
+        AC_MSG_ERROR($crystalhd_not_found)
+      else
+        use_crystalhd=no
+        AC_MSG_RESULT($crystalhd_not_found)
+      fi
+      USE_CRYSTALHD=0
+    ])
+    CFLAGS="$SAVE_CFLAGS"
+    if test "$host_vendor" != "apple"; then
+      XB_FIND_SONAME([CRYSTALHD], [crystalhd], [use_crystalhd])
+    fi
+    if test "x$use_crystalhd" != "xno"; then
+      SAVE_CFLAGS="$CFLAGS"
+      CFLAGS="-D__LINUX_USER__ -lcrystalhd"
+      # check for new crystalhd lib
+      AC_COMPILE_IFELSE(
+        [AC_LANG_SOURCE([#include <libcrystalhd/bc_dts_types.h>
+          #include <libcrystalhd/bc_dts_defs.h>
+          PBC_INFO_CRYSTAL bCrystalInfo;])],
+        [ AC_DEFINE([HAVE_LIBCRYSTALHD], [2], [Define to 2 if you have the 'New Broadcom Crystal HD' library.]) ], 
+        [ AC_DEFINE([HAVE_LIBCRYSTALHD], [1], [Define to 1 if you have the 'Old Broadcom Crystal HD' library.]) ])
+      CFLAGS="$SAVE_CFLAGS"
+      USE_CRYSTALHD=1
+    fi
+else
+  AC_MSG_NOTICE($crystalhd_disabled)
+  USE_CRYSTALHD=0
+fi
+
+# VDADecoder
+if test "x$use_vdadecoder" != "xno"; then
+  if test "$host_vendor" = "apple" ; then
+    HAVE_LIBVDADECODER=1
+    AC_DEFINE([HAVE_LIBVDADECODER], [1], [Define to 1 if you have the 'VDADecoder' library.])
+    AC_MSG_NOTICE($vdadecoder_enabled)
+    USE_VDA=1
+  else
+    if test "x$use_vdadecoder" = "xyes"; then
+      AC_MSG_ERROR([VDA Decoder not supported on this platform])
+    else
+      use_vdadecoder="no"
+      AC_MSG_NOTICE($vdadecoder_disabled)
+    fi
+    USE_VDA=0
+  fi
+else
+  AC_MSG_NOTICE($vdadecoder_disabled)
+fi
+
+# VTBDecoder
+if test "x$use_vtbdecoder" != "xno"; then
+  if test "$host_vendor" = "apple" ; then
+    HAVE_VIDEOTOOLBOXDECODER=1
+    AC_DEFINE([HAVE_VIDEOTOOLBOXDECODER], [1], [Define to 1 if you have the 'VTBDecoder' library.])
+    AC_MSG_NOTICE($vtbdecoder_enabled)
+  else
+    if test "x$use_vtbdecoder" = "xyes"; then
+      AC_MSG_ERROR([VTB Decoder not supported on this platform])
+    else
+      use_vtbdecoder="no"
+      AC_MSG_NOTICE($vtbdecoder_disabled)
+    fi
+  fi
+else
+  AC_MSG_NOTICE($vtbdecoder_disabled)
+fi
+
+# OpenMax
+if test "$host_vendor" = "apple" ; then
+  use_openmax="no"
+  USE_OPENMAX=0
+  AC_MSG_NOTICE($openmax_disabled)
+elif test "$target_platform" = "target_raspberry_pi"; then
+  use_openmax="no"
+  USE_OPENMAX=0
+  AC_MSG_NOTICE($openmax_disabled)
+else
+  if test "$use_gles" = "yes" && test "$use_openmax" = "auto"; then
+    PKG_CHECK_MODULES([OPENMAX], [libomxil-bellagio],
+                      USE_OPENMAX=1;[INCLUDES="$INCLUDES $OPENMAX_CFLAGS"; LIBS="$LIBS $OPENMAX_LIBS"],
+                      use_openmax=no;USE_OPENMAX=0;AC_MSG_RESULT($openmax_not_found))
+  elif test "$use_gles" = "yes" && test "$use_openmax" = "yes"; then
+    PKG_CHECK_MODULES([OPENMAX], [libomxil-bellagio],
+                      USE_OPENMAX=1;[INCLUDES="$INCLUDES $OPENMAX_CFLAGS"; LIBS="$LIBS $OPENMAX_LIBS"],
+                      AC_MSG_ERROR($openmax_not_found))
+  else
+    AC_MSG_NOTICE($openmax_disabled)
+    use_openmax=no
+    USE_OPENMAX=0
+  fi
+fi
+
+# yajl version check (yajl_version.h was added in yajl 2.0)
+AC_CHECK_HEADERS([yajl/yajl_version.h], [], [
+AC_DEFINE(YAJL_MAJOR, 1, [yajl version 1])
+], [])
+
+# additional internal players
+case $add_players in
+  *amlplayer*)
+      AC_CHECK_HEADER([amlplayer/amports/amstream.h],, AC_MSG_ERROR($missing_headers))
+      XB_ADD_PLAYER([AMLPLAYER], [amlplayer])
+      ;;
+  *omxplayer*)
+      XB_ADD_PLAYER([OMXPLAYER], [omxplayer])
+      ;;
+esac
+
+# platform specific bin utilities
+if test "$host_vendor" != "apple" ; then
+  AC_CHECK_PROG(HAVE_GAWK,gawk,"yes","no",)
+  if test "$HAVE_GAWK" = "no" ; then
+    AC_MSG_ERROR($missing_program)
+  fi
+fi
+
+if test "$use_arch" != "arm" ; then
+  AC_CHECK_PROG(HAVE_CMAKE,cmake,"yes","no",)
+  if test "$HAVE_CMAKE" = "no" ; then
+    AC_MSG_ERROR($missing_program)
+  fi
+fi
+
+AC_CHECK_PROG(HAVE_GPERF,gperf,"yes","no",)
+if test "$HAVE_GPERF" = "no" ; then
+  AC_MSG_ERROR($missing_program)
+fi
+
+AC_CHECK_PROG(HAVE_UNZIP,unzip,"yes","no",)
+if test "$HAVE_UNZIP" = "no" ; then
+  AC_MSG_ERROR($missing_program)
+fi
+
+AC_CHECK_PROG(HAVE_ZIP,zip,"yes","no",)
+if test "$HAVE_ZIP" = "no" ; then
+  AC_MSG_ERROR($missing_program)
+fi
+
+if test "$ARCH" = "i486-linux" || test "$ARCH" = "x86-freebsd"; then
+  AC_CHECK_PROG(HAVE_NASM,nasm,"yes","no",)
+  if test "$HAVE_NASM" = "no" ; then
+    AC_MSG_ERROR($missing_program)
+  fi
+fi
+
+AC_CHECK_PROG(HAVE_GIT,git,"yes","no",)
+
+# Checks for header files.
+AC_HEADER_DIRENT
+AC_HEADER_STDC
+AC_HEADER_SYS_WAIT
+AC_CHECK_HEADERS([arpa/inet.h fcntl.h float.h inttypes.h limits.h locale.h \
+  malloc.h memory.h netdb.h netinet/in.h stddef.h stdint.h stdlib.h string.h \
+  strings.h sys/file.h sys/ioctl.h sys/mount.h sys/param.h sys/socket.h \
+  sys/time.h sys/timeb.h sys/vfs.h termios.h unistd.h utime.h wchar.h wctype.h])
+AC_CHECK_HEADERS([cdio/iso9660.h],,AC_MSG_ERROR([$missing_headers]))
+
+# Checks for typedefs, structures, and compiler characteristics.
+AC_HEADER_STAT
+AC_HEADER_STDBOOL
+AC_C_CONST
+AC_TYPE_UID_T
+AC_C_INLINE
+AC_TYPE_INT8_T
+AC_TYPE_INT16_T
+AC_TYPE_INT32_T
+AC_TYPE_INT64_T
+AC_TYPE_MODE_T
+AC_TYPE_OFF_T
+AC_TYPE_PID_T
+AC_C_RESTRICT
+AC_TYPE_SIZE_T
+AC_TYPE_SSIZE_T
+AC_CHECK_MEMBERS([struct stat.st_rdev])
+AC_HEADER_TIME
+AC_STRUCT_TM
+AC_TYPE_UINT8_T
+AC_TYPE_UINT16_T
+AC_TYPE_UINT32_T
+AC_TYPE_UINT64_T
+AC_C_BIGENDIAN
+
+if test "$cross_compiling" = "yes"; then
+  final_message="$final_message\n  Crosscomp.:\tYes"
+else
+  final_message="$final_message\n  Crosscomp.:\tNo"
+fi
+
+final_message="$final_message\n  target ARCH:\t$use_arch"
+final_message="$final_message\n  target CPU:\t$use_cpu"
+
+if test "$use_gles" = "yes"; then
+  final_message="$final_message\n  OpenGLES:\tYes"
+  USE_OPENGLES=1
+  USE_OPENGL=0
+else
+  USE_OPENGLES=0
+  if test "$use_gl" = "yes"; then
+    final_message="$final_message\n  OpenGL:\tYes"
+    USE_OPENGL=1
+  else
+    final_message="$final_message\n  OpenGL:\tNo (Very Slow)"
+    SDL_DEFINES="-DHAS_SDL_2D"
+    USE_OPENGL=0
+  fi
+fi
+
+if test "$use_alsa" = "yes"; then
+  USE_ALSA=1
+  AC_DEFINE([USE_ALSA],[1],["Define to 1 if alsa is installed"])
+  final_message="$final_message\n  ALSA:\t\tYes"
+else
+  USE_ALSA=0
+  final_message="$final_message\n  ALSA:\t\tNo"
+fi
+
+if test "$use_dbus" = "yes"; then
+  final_message="$final_message\n  DBUS:\t\tYes"
+else
+  final_message="$final_message\n  DBUS:\t\tNo"
+fi
+
+if test "x$use_vdpau" != "xno"; then
+  final_message="$final_message\n  VDPAU:\tYes"
+else
+  final_message="$final_message\n  VDPAU:\tNo"
+fi
+
+if test "x$use_vaapi" != "xno"; then
+  final_message="$final_message\n  VAAPI:\tYes"
+else
+  final_message="$final_message\n  VAAPI:\tNo"
+fi
+
+if test "x$use_crystalhd" != "xno"; then
+  final_message="$final_message\n  CrystalHD:\tYes"
+else
+  final_message="$final_message\n  CrystalHD:\tNo"
+fi
+
+if test "x$use_vdadecoder" != "xno"; then
+  final_message="$final_message\n  VDADecoder:\tYes"
+else
+  final_message="$final_message\n  VDADecoder:\tNo"
+fi
+
+if test "x$use_vtbdecoder" != "xno"; then
+  final_message="$final_message\n  VTBDecoder:\tYes"
+else
+  final_message="$final_message\n  VTBDecoder:\tNo"
+fi
+
+if test "$use_openmax" != "no"; then
+  final_message="$final_message\n  OpenMax:\tYes"
+else
+  final_message="$final_message\n  OpenMax:\tNo"
+fi
+
+if test "$use_joystick" = "yes"; then
+  final_message="$final_message\n  Joystick:\tYes"
+  SDL_DEFINES="$SDL_DEFINES -DHAS_SDL_JOYSTICK"
+else
+  final_message="$final_message\n  Joystick:\tNo"
+fi
+
+if test "$use_xrandr" = "yes"; then
+  final_message="$final_message\n  XRandR:\tYes"
+  USE_XRANDR=1
+else
+  final_message="$final_message\n  XRandR:\tNo"
+  USE_XRANDR=0
+fi
+
+if test "$use_goom" = "yes"; then
+  final_message="$final_message\n  GOOM:\t\tYes"
+else
+  final_message="$final_message\n  GOOM:\t\tNo"
+fi
+
+if test "$use_rsxs" = "yes"; then
+  final_message="$final_message\n  RSXS:\t\tYes"
+else
+  final_message="$final_message\n  RSXS:\t\tNo"
+fi
+
+if test "$use_projectm" = "yes"; then
+  final_message="$final_message\n  ProjectM:\tYes"
+else
+  final_message="$final_message\n  ProjectM:\tNo"
+fi
+
+if test "$use_skin_touched" = "yes"; then
+  final_message="$final_message\n  Skin Touched:\tYes"
+else
+  final_message="$final_message\n  Skin Touched:\tNo"
+fi
+
+if test "$use_x11" = "yes"; then
+  final_message="$final_message\n  X11:\t\tYes"
+else
+  final_message="$final_message\n  X11:\t\tNo"
+fi
+
+if test "$use_libbluray" = "yes"; then
+  final_message="$final_message\n  Bluray:\tYes"
+else
+  final_message="$final_message\n  Bluray:\tNo"
+fi
+
+USE_TEXTUREPACKER_NATIVE=0
+if test "x$use_texturepacker" != "xno"; then
+  final_message="$final_message\n  TexturePacker:Yes"
+  USE_TEXTUREPACKER=1
+  if test "x$use_texturepacker_native" = "xyes"; then
+    USE_TEXTUREPACKER_NATIVE=1
+    if [[ ! -d "$USE_TEXTUREPACKER_NATIVE_ROOT" ]]; then 
+      USE_TEXTUREPACKER_NATIVE_ROOT= 
+    fi
+  fi
+else
+  final_message="$final_message\n  TexturePacker:No"
+  USE_TEXTUREPACKER=0
+fi
+
+if test "$use_mid" = "yes"; then
+  final_message="$final_message\n  MID Support:\tYes"
+  SDL_DEFINES="$SDL_DEFINES -DMID"
+else
+  final_message="$final_message\n  MID Support:\tNo"
+fi
+
+ORIGCC=$CC
+ORIGCXX=$CXX
+if test "x$use_ccache" != "xno"; then
+  AC_PATH_PROG(CCACHE,ccache,none)
+  if test "$ac_cv_path_CCACHE" = "none"; then
+    if test "x$use_ccache" = "xyes"; then
+      AC_MSG_ERROR([ccache not found.]);
+    else
+      AC_MSG_NOTICE([ccache not found. Falling back to default CC])
+      final_message="$final_message\n  ccache:\tNo"
+    fi
+  else
+    CC="$ac_cv_path_CCACHE $CC"
+    CXX="$ac_cv_path_CCACHE $CXX"
+    AC_MSG_NOTICE(enabling ccache)
+    final_message="$final_message\n  ccache:\tYes"
+  fi
+else
+  final_message="$final_message\n  ccache:\tNo"
+fi
+
+if test "$use_alsa" = "yes"; then
+  final_message="$final_message\n  ALSA Support:\tYes"
+else
+  final_message="$final_message\n  ALSA Support:\tNo"
+fi
+
+if test "x$use_pulse" != "xno"; then
+  XBMC_STANDALONE_SH_PULSE=tools/Linux/xbmc-standalone.sh.pulse
+  final_message="$final_message\n  PulseAudio:\tYes"
+else
+  XBMC_STANDALONE_SH_PULSE=/dev/null
+  final_message="$final_message\n  PulseAudio:\tNo"
+fi
+
+if test "$use_hal" = "yes"; then
+  final_message="$final_message\n  HAL Support:\tYes"
+else
+  final_message="$final_message\n  HAL Support:\tNo"
+fi
+
+# DVDCSS
+if test "$use_dvdcss" = "yes"; then
+  AC_MSG_NOTICE($dvdcss_enabled)
+  final_message="$final_message\n  DVDCSS:\tYes"
+  BUILD_DVDCSS=1
+  SKIP_CONFIG_DVDCSS=0
+  DVDREAD_CFLAGS="-D_XBMC -DHAVE_DVDCSS_DVDCSS_H"
+else
+  AC_MSG_NOTICE($dvdcss_disabled)
+  final_message="$final_message\n  DVDCSS:\tNo"
+  BUILD_DVDCSS=0
+  SKIP_CONFIG_DVDCSS=1
+  DVDREAD_CFLAGS="-D_XBMC -UHAVE_DVDCSS_DVDCSS_H"
+fi
+if test "$host_vendor" = "apple"; then
+ DVDREAD_CFLAGS="$DVDREAD_CFLAGS -D__DARWIN__"
+fi
+
+# Google Test Framework
+if test "$configure_gtest" = "yes"; then
+  AC_MSG_NOTICE($gtest_enabled)
+  final_message="$final_message\n  Google Test Framework Configured:\tYes"
+  GTEST_CONFIGURED=1
+  SKIP_CONFIG_GTEST=0
+else
+  AC_MSG_NOTICE($gtest_disabled)
+  final_message="$final_message\n  Google Test Framework Configured:\tNo"
+  GTEST_CONFIGURED=0
+  SKIP_CONFIG_GTEST=1
+fi
+
+if test "$use_avahi" = "yes"; then
+  final_message="$final_message\n  Avahi:\tYes"
+else
+  final_message="$final_message\n  Avahi:\tNo"
+fi
+
+if test "$HAVE_GIT" = "yes"; then
+  GIT_REV=$(git --no-pager log --abbrev=7 -n 1 --pretty=format:"%h %ci" HEAD | awk '{gsub("-", "");print $2"-"$1}')
+fi
+if test "$GIT_REV" = ""; then
+  GIT_REV="Unknown"
+fi
+if test "$host_vendor" = "apple"; then
+  echo "#define GIT_REV \"$GIT_REV\"" > git_revision.h
+else
+  SDL_DEFINES="$SDL_DEFINES -D'GIT_REV=\"$GIT_REV\"'"
+fi
+
+if test "$use_nonfree" = "yes"; then
+  final_message="$final_message\n  Non-free:\tYes"
+  HAVE_XBMC_NONFREE=1
+  AC_DEFINE([HAVE_XBMC_NONFREE], [1], [Define to 1 to enable non-free components.])
+else
+  HAVE_XBMC_NONFREE=0
+  final_message="$final_message\n  Non-free:\tNo"
+fi
+
+if test "$use_asap" = "yes"; then
+  AC_CHECK_PROGS(HAVE_GDC,gdc-4.4 gdc-4.3 gdc,"no")
+  if test "$HAVE_GDC" = "no"; then
+    AC_MSG_ERROR($missing_program);
+  fi
+  AC_CHECK_PROG(HAVE_FPC,fpc,"yes","no")
+  if test "$HAVE_FPC" = "no"; then
+    AC_MSG_ERROR($missing_program);
+  fi
+  USE_ASAP_CODEC=1
+  AC_DEFINE([USE_ASAP_CODEC], [1], [Define to 1 to enable ASAP codec.])
+  final_message="$final_message\n  ASAP Codec:\tYes"
+else
+  USE_ASAP_CODEC=0
+  final_message="$final_message\n  ASAP Codec:\tNo"
+fi
+
+if test "$use_mysql" = "yes"; then
+  final_message="$final_message\n  MySQL:\tYes"
+  USE_MYSQL=1
+else
+  final_message="$final_message\n  MySQL:\tNo"
+  USE_MYSQL=0
+fi
+if test "$use_webserver" = "yes"; then
+  final_message="$final_message\n  Webserver:\tYes"
+  USE_WEB_SERVER=1
+else
+  final_message="$final_message\n  Webserver:\tNo"
+  USE_WEB_SERVER=0
+fi
+
+if test "$use_libssh" != "no"; then
+  final_message="$final_message\n  libssh support:\tYes"
+else
+  final_message="$final_message\n  libssh support:\tNo"
+fi
+
+if test "$use_librtmp" != "no"; then
+  final_message="$final_message\n  libRTMP support:\tYes"
+else
+  final_message="$final_message\n  libRTMP support:\tNo"
+fi
+
+if test "x$use_samba" != "xno"; then
+  final_message="$final_message\n  libsmbclient support:\tYes"
+else
+  final_message="$final_message\n  libsmbclient support:\tNo"
+fi
+
+if test "$use_libnfs" != "no"; then
+  final_message="$final_message\n  libnfs client support:Yes"
+else
+  final_message="$final_message\n  libnfs client support:No"
+fi
+
+if test "x$use_libafpclient" != "xno"; then
+  final_message="$final_message\n  libafpclient support:\tYes"
+else  
+  final_message="$final_message\n  libafpclient support:\tNo"
+fi
+
+if test "$use_airplay" != "no"; then
+  final_message="$final_message\n  AirPlay support:\tYes"
+else
+  final_message="$final_message\n  AirPLay support:\tNo"
+fi
+
+if test "x$use_airtunes" != "xno"; then
+  final_message="$final_message\n  AirTunes support:\tYes"  
+else
+  final_message="$final_message\n  AirTunes support:\tNo"
+fi
+
+if test "x$use_upnp" != "xno"; then
+  final_message="$final_message\n  UPnP support:\t\tYes"
+  USE_UPNP=1
+  AC_DEFINE([USE_UPNP], [1], [Define to 1 to enable UPnP support.])
+else
+  USE_UPNP=0
+  final_message="$final_message\n  UPnP support:\t\tNo"
+fi
+
+if test "$use_optical_drive" = "yes"; then
+  final_message="$final_message\n  Optical drive:\tYes"
+else
+  final_message="$final_message\n  Optical drive:\tNo"
+fi
+
+if test "x$use_libudev" != "xno"; then
+  final_message="$final_message\n  libudev support:\tYes"
+else
+  final_message="$final_message\n  libudev support:\tNo"
+fi
+
+if test "x$use_libusb" != "xno"; then
+  final_message="$final_message\n  libusb support:\tYes"
+else
+  final_message="$final_message\n  libusb support:\tNo"
+fi
+
+if test "x$use_libcec" != "xno"; then
+  final_message="$final_message\n  libcec support:\tYes"
+else
+  final_message="$final_message\n  libcec support:\tNo"
+fi
+
+if test "x$use_libmp3lame" != "xno"; then
+  final_message="$final_message\n  libmp3lame support:\tYes"
+else
+  final_message="$final_message\n  libmp3lame support:\tNo"
+fi
+
+if test "x$use_libvorbisenc" != "xno"; then
+  final_message="$final_message\n  libvorbisenc support:\tYes"
+else
+  final_message="$final_message\n  libvorbisenc support:\tNo"
+fi
+
+if test "x$use_libcap" != "xno"; then
+  final_message="$final_message\n  libcap support:\tYes"
+else
+  final_message="$final_message\n  libcap support:\tNo"
+fi
+
+if test "x$add_players" != "xno"; then
+  final_message="$final_message\n  additional players:\tYes"
+else
+  final_message="$final_message\n  additional players:\tNo"
+fi
+
+### External libraries messages
+
+if test "$use_external_ffmpeg" = "yes"; then
+  final_message="$final_message\n  External FFmpeg:\tYes"
+else
+  final_message="$final_message\n  External FFmpeg:\tNo"
+fi
+
+if test "$host_vendor" = "apple" ; then
+  # built internal but referenced as external, we link directly to them.
+  # this MUST be the last thing before OUTPUT_FILES as they do not
+  # exist until after we build FFMpeg.
+  LIBS="$LIBS -L\$(abs_top_srcdir)/lib/ffmpeg/libavcodec -lavcodec"
+  LIBS="$LIBS -L\$(abs_top_srcdir)/lib/ffmpeg/libavfilter -lavfilter"
+  LIBS="$LIBS -L\$(abs_top_srcdir)/lib/ffmpeg/libswresample -lswresample"
+  LIBS="$LIBS -L\$(abs_top_srcdir)/lib/ffmpeg/libavformat -lavformat"
+  LIBS="$LIBS -L\$(abs_top_srcdir)/lib/ffmpeg/libavutil -lavutil"
+  LIBS="$LIBS -L\$(abs_top_srcdir)/lib/ffmpeg/libpostproc -lpostproc"
+  LIBS="$LIBS -L\$(abs_top_srcdir)/lib/ffmpeg/libswscale -lswscale"
+fi
+
+USE_PVR_ADDONS=0
+DISABLE_PVR_ADDON_CONFIG=1
+if [[ -f "pvr-addons/Makefile.am" ]]; then
+  final_message="$final_message\n  PVR add-ons:\t\tYes"
+  USE_PVR_ADDONS=1
+  DISABLE_PVR_ADDON_CONFIG=0
+else
+  final_message="$final_message\n  PVR add-ons:\t\tNo"
+fi
+
+OUTPUT_FILES="Makefile \
+    Makefile.include \
+    addons/skin.confluence/media/Makefile \
+    xbmc/Makefile \
+    xbmc/cdrip/Makefile \
+    xbmc/cores/Makefile \
+    xbmc/cores/VideoRenderers/Makefile \
+    xbmc/cores/dvdplayer/Makefile \
+    lib/Makefile \
+    lib/libdvd/Makefile \
+    xbmc/cores/DllLoader/Makefile \
+    xbmc/cores/DllLoader/exports/Makefile \
+    xbmc/cores/dvdplayer/DVDCodecs/Makefile \
+    xbmc/cores/dvdplayer/DVDCodecs/Audio/Makefile \
+    xbmc/cores/dvdplayer/DVDCodecs/Overlay/Makefile \
+    xbmc/cores/dvdplayer/DVDCodecs/Video/Makefile \
+    xbmc/cores/dvdplayer/DVDDemuxers/Makefile \
+    xbmc/cores/dvdplayer/DVDSubtitles/Makefile \
+    xbmc/cores/AudioEngine/Makefile \
+    xbmc/cores/paplayer/Makefile \
+    xbmc/cores/amlplayer/Makefile \
+    xbmc/cores/omxplayer/Makefile \
+    lib/timidity/Makefile \
+    lib/xbadpcm/Makefile \
+    lib/asap/Makefile \
+    lib/nosefart/Makefile \
+    lib/libsidplay2/Makefile \
+    lib/vgmstream/Makefile \
+    lib/snesapu/SNES/SNESAPU/Makefile \
+    lib/stsound/StSoundLibrary/Makefile \
+    xbmc/cores/playercorefactory/Makefile \
+    xbmc/music/karaoke/Makefile \
+    xbmc/osx/Makefile \
+    xbmc/guilib/Makefile \
+    xbmc/interfaces/Makefile \
+    xbmc/network/Makefile \
+    xbmc/network/upnp/Makefile \
+    lib/libRTV/Makefile \
+    lib/libexif/Makefile \
+    lib/libXDAAP/Makefile \
+    lib/cmyth/Makefile \
+    lib/libhdhomerun/Makefile \
+    lib/libsquish/Makefile \
+    lib/cximage-6.0/Makefile \
+    lib/addons/script.module.pil/Makefile \
+    lib/libUPnP/Makefile \
+    xbmc/DllPaths_generated.h \
+    xbmc/DllPaths_generated_android.h \
+    xbmc/freebsd/Makefile \
+    xbmc/linux/Makefile \
+    xbmc/filesystem/Makefile \
+    xbmc/screensavers/rsxs-0.9/xbmc/Makefile \
+    xbmc/visualizations/XBMCProjectM/Makefile \
+    xbmc/visualizations/Goom/Makefile \
+    xbmc/visualizations/OpenGLSpectrum/Makefile \
+    xbmc/visualizations/WaveForm/Makefile \
+    lib/addons/library.xbmc.addon/Makefile \
+    lib/addons/library.xbmc.gui/Makefile \
+    lib/addons/library.xbmc.pvr/Makefile \
+    xbmc/visualizations/EGLHelpers/Makefile \
+    tools/Linux/xbmc.sh \
+    tools/Linux/xbmc-standalone.sh \
+    tools/TexturePacker/Makefile \
+    tools/EventClients/Clients/OSXRemote/Makefile \
+    xbmc/peripherals/bus/Makefile \
+    xbmc/peripherals/devices/Makefile \
+    xbmc/android/activity/Makefile \
+    xbmc/android/loader/Makefile \
+    xbmc/main/Makefile"
+
+if test "$use_skin_touched" = "yes"; then
+OUTPUT_FILES="$OUTPUT_FILES addons/skin.touched/media/Makefile"
+fi
+
+OUTPUT_FILES="$OUTPUT_FILES \
+  xbmc/interfaces/python/Makefile \
+  xbmc/interfaces/python/test/Makefile"
+
+# Line below is used so we can use AM_INIT_AUTOMAKE. The corresponding
+# .dummy.am does nothing.
+AC_CONFIG_FILES([.dummy])
+
+AC_CONFIG_FILES([${OUTPUT_FILES}])
+OUTPUT_FILES="$OUTPUT_FILES \
+  .dummy"
+AC_SUBST(CFLAGS)
+AC_SUBST(CXXFLAGS)
+AC_SUBST(INCLUDES)
+AC_SUBST(LDFLAGS)
+AC_SUBST(SDL_DEFINES)
+AC_SUBST(BUILD_DVDCSS)
+AC_SUBST(DISABLE_GOOM)
+AC_SUBST(DISABLE_RSXS)
+AC_SUBST(DISABLE_PROJECTM)
+AC_SUBST(USE_SKIN_TOUCHED)
+AC_SUBST(USE_EXTERNAL_FFMPEG)
+AC_SUBST(PYTHON_VERSION)
+AC_SUBST(OUTPUT_FILES)
+AC_SUBST(HAVE_XBMC_NONFREE)
+AC_SUBST(USE_ASAP_CODEC)
+AC_SUBST(LIBCURL_BASENAME)
+AC_SUBST(LIBFLAC_BASENAME)
+AC_SUBST(LIBVORBISFILE_BASENAME)
+AC_SUBST(LIBMODPLUG_BASENAME)
+AC_SUBST(LIBMAD_BASENAME)
+AC_SUBST(LIBOGG_BASENAME)
+AC_SUBST(LIBVORBISENC_BASENAME)
+AC_SUBST(LIBVORBIS_BASENAME)
+AC_SUBST(LIBASS_BASENAME)
+AC_SUBST(LIBMEPG2_BASENAME)
+AC_SUBST_FILE(XBMC_STANDALONE_SH_PULSE)
+AC_SUBST(USE_OPENGL)
+AC_SUBST(USE_OPENGLES)
+AC_SUBST(USE_VDPAU)
+AC_SUBST(USE_VAAPI)
+AC_SUBST(USE_CRYSTALHD)
+AC_SUBST(USE_LIBSMBCLIENT)
+AC_SUBST(USE_LIBNFS)
+AC_SUBST(USE_LIBAFPCLIENT)
+AC_SUBST(USE_AIRPLAY)
+AC_SUBST(USE_VDA)
+AC_SUBST(USE_OPENMAX)
+AC_SUBST(USE_PULSE)
+AC_SUBST(USE_XRANDR)
+AC_SUBST(USE_ALSA)
+AC_SUBST(USE_TEXTUREPACKER)
+AC_SUBST(USE_TEXTUREPACKER_NATIVE)
+AC_SUBST(USE_TEXTUREPACKER_NATIVE_ROOT)
+AC_SUBST(USE_AIRTUNES)
+AC_SUBST(USE_LIBUDEV)
+AC_SUBST(USE_LIBUSB)
+AC_SUBST(USE_LIBCEC)
+AC_SUBST(USE_MYSQL)
+AC_SUBST(USE_WEB_SERVER)
+AC_SUBST(USE_UPNP)
+AC_SUBST(USE_OMXLIB)
+AC_SUBST(USE_ANDROID)
+AC_SUBST(GTEST_CONFIGURED)
+AC_SUBST(USE_DOXYGEN)
+AC_SUBST(USE_PVR_ADDONS)
+
+# pushd and popd are not available in other shells besides bash, so implement
+# our own pushd/popd functions
+XB_DIRSTACK="$PWD"
+xb_pushd()
+{
+  local dirname="$1"
+  if [[ -d "$dirname" ]] && [[ -x "$dirname" ]]; then
+    cd "$dirname"
+    XB_DIRSTACK="$dirname ${XB_DIRSTACK:-$PWD}"
+    return 0
+  else
+    AC_MSG_ERROR(xb_pushd: unable to change to $dirname)
+  fi
+}
+xb_popd()
+{
+  if [[ -n "$XB_DIRSTACK" ]]; then
+    XB_DIRSTACK="${XB_DIRSTACK#* }"
+    cd "${XB_DIRSTACK%% *}"
+    return 0
+  else
+    AC_MSG_ERROR(xb_popd: unable to go back to previous directory)
+  fi
+}
+
+# Function to run the configure scripts in our submodules
+# Consists of three paramaters, the path to the submodule, the configure command
+# with appropriate arguments, and a third parameter set to 1 if we are to skip
+# running the script, anything else if not.
+AC_DEFUN([XB_CONFIG_MODULE],[
+AC_CONFIG_COMMANDS_POST([
+if [[ $3 != "1" ]]; then
+    if [[ -d $1 ]]; then
+      xb_pushd $1
+      $2
+      if [[ $? -ne 0 ]]; then
+        xb_popd
+        AC_MSG_ERROR([[Submodule $1 failed to configure]])
+      else
+        xb_popd
+      fi
+    else
+      AC_MSG_ERROR([[Submodule $1 does not exist]])
+    fi
+else
+    AC_MSG_NOTICE([[Skipping configuration of submodule $1.]])
+fi
+])
+])
+
+XB_CONFIG_MODULE([lib/ffmpeg], [
+  if test "$host_vendor" = "apple" ; then
+    ffmpg_config="--target-os=$ffmpeg_target_os"
+    # handle disables first, we do individual enables later
+    ffmpg_config="$ffmpg_config --disable-muxers   --disable-encoders"
+    ffmpg_config="$ffmpg_config --disable-devices  --disable-doc"
+    ffmpg_config="$ffmpg_config --disable-ffplay   --disable-ffmpeg"
+    ffmpg_config="$ffmpg_config --disable-ffprobe  --disable-ffserver"
+    ffmpg_config="$ffmpg_config --disable-vda      --disable-crystalhd"
+    ffmpg_config="$ffmpg_config --disable-decoder=mpeg_xvmc"
+
+    # handle conditional enables/disables
+    if test "$use_debug" = "no"; then
+      ffmpg_config="$ffmpg_config --disable-debug"
+    fi
+    if test "$use_cpu"  != "no";  then
+      ffmpg_config="$ffmpg_config --cpu=$use_cpu"
+    fi
+    if test "$use_arch" != "no"; then
+      ffmpg_config="$ffmpg_config --arch=$use_arch --enable-cross-compile"
+    fi
+    if test "$use_arch"  = "arm"; then
+      ffmpg_config="$ffmpg_config --enable-pic"
+      ffmpg_config="$ffmpg_config --disable-armv5te --disable-armv6t2"
+      if test "$use_neon"  = "yes"; then
+        ffmpg_config="$ffmpg_config --enable-neon"
+      else
+        ffmpg_config="$ffmpg_config --disable-neon"
+      fi
+    else
+      ffmpg_config="$ffmpg_config --disable-amd3dnow"
+    fi
+    if test "$use_ffmpeg_libvorbis" = "yes"; then
+      ffmpg_config="$ffmpg_config --enable-libvorbis --enable-muxer=ogg --enable-encoder=libvorbis"
+    else
+      ffmpg_config="$ffmpg_config --disable-libvorbis"
+    fi
+
+    # handle individual enables
+    ffmpg_config="$ffmpg_config --enable-gpl"
+    ffmpg_config="$ffmpg_config --enable-postproc"
+    ffmpg_config="$ffmpg_config --enable-static      --enable-pthreads"
+    ffmpg_config="$ffmpg_config --enable-muxer=spdif --enable-muxer=adts"
+    ffmpg_config="$ffmpg_config --enable-encoder=ac3 --enable-encoder=aac"
+    ffmpg_config="$ffmpg_config --enable-protocol=http"
+    ffmpg_config="$ffmpg_config --enable-runtime-cpudetect"
+
+    # ffmpeg will not compile with llvm-gcc-4.2, use clang instead
+    case $CC in
+      *llvm-gcc-4.2*)
+        ffmpg_config="$ffmpg_config --cc=clang" ;;
+      *)
+        ffmpg_config="$ffmpg_config --cc=$CC" ;;
+    esac
+    
+    # extra-cflags must be passed alone or it gets expanded wrong by the ffmpeg configure
+    FFMPEG_EXTRACFLAGS="$CFLAGS $FFMPEG_EXTRACFLAGS -w -D_DARWIN_C_SOURCE -Dattribute_deprecated="
+
+    ./configure --extra-cflags="$FFMPEG_EXTRACFLAGS" $ffmpg_config --as="$AS"
+
+    # if using llvm-gcc-4.2 as assembler, -MMD is not enough to generate
+    # dependency files in the right place, replace it with something that works
+    case $AS in
+      *llvm-gcc-4.2*)
+        sed -ie "s#AS_DEPFLAGS=-MMD#AS_DEPFLAGS=-MMD -MF \$(\@:.o=.d) -MT \$\@#" config.mak ;;
+    esac
+
+    # ffmpeg will use yasm found at ${prefix}/bin during configure
+    # but then hardcodes 'yasm' in config.mak, fix it.
+    sed -ie "s#YASM=yasm#YASM=${prefix}/bin/yasm#" config.mak
+    sed -ie "s#YASMDEP=yasm#YASMDEP=${prefix}/bin/yasm#" config.mak
+    sed -ie "s# -D_ISOC99_SOURCE -D_POSIX_C_SOURCE=200112 # #" config.mak
+  else
+    CFLAGS="" \
+    CPPFLAGS="" \
+    CXXFLAGS="" \
+    LDFLAGS="$(echo "$LDFLAGS" | sed "s/-Wl,-Bsymbolic-functions//g")" \
+    ./configure \
+      --extra-cflags="$PASSED_CFLAGS $FFMPEG_EXTRACFLAGS" \
+      --disable-static \
+      `if test "$use_debug" = "no"; then echo --disable-debug; fi` \
+      `if test "$cross_compiling" = "yes"; then echo --enable-cross-compile; fi` \
+      `if test "$use_arch" != "no"; then echo --arch=$use_arch; fi`\
+      `if test "$use_cpu" != "no"; then echo --cpu=$use_cpu; fi`\
+      `if test "$use_neon" = "yes"; then echo --enable-neon; else echo --disable-neon; fi`\
+      --target-os=$ffmpeg_target_os \
+      --disable-muxers \
+      --enable-muxer=spdif \
+      --enable-muxer=adts \
+      --disable-encoders \
+      --enable-encoder=ac3 \
+      --enable-encoder=aac \
+      `if test "$use_ffmpeg_libvorbis" = "yes"; then echo --enable-libvorbis --enable-muxer=ogg --enable-encoder=libvorbis; else echo --disable-libvorbis; fi` \
+      --disable-decoder=mpeg_xvmc \
+      --disable-devices \
+      --disable-ffprobe \
+      --disable-ffplay \
+      --disable-ffserver \
+      --disable-ffmpeg \
+      --disable-crystalhd \
+      --enable-shared \
+      --disable-doc \
+      --enable-postproc \
+      --enable-gpl \
+      `if test "x$use_vdpau" != "xno"; then echo --enable-vdpau; else echo --disable-vdpau; fi` \
+      `if test "x$use_vaapi" != "xno"; then echo --enable-vaapi; else echo --disable-vaapi; fi` \
+      `if test "$use_optimizations" != "no"; then echo --enable-optimizations; else echo --disable-optimizations; fi` \
+      --enable-protocol=http \
+      --enable-pthreads \
+      --enable-runtime-cpudetect \
+      `if test "$use_hardcoded_tables" = "yes"; then echo --enable-hardcoded-tables; else echo --disable-hardcoded-tables; fi`\
+      `if test "$target_platform" = "target_android" && test "$host_cpu" = "i686"; then echo --disable-mmx; fi #workaround for gcc 4.6 bug` \
+      `if test "$target_platform" = "target_android"; then echo "--custom-libname-with-major=\\$(SLIBPREF)\\$(FULLNAME)-\\$(LIBMAJOR)-${ARCH}\\$(SLIBSUF)"; \
+       else echo "--custom-libname-with-major=\\$(FULLNAME)-\\$(LIBMAJOR)-${ARCH}\\$(SLIBSUF)"; fi` \
+      `case $host_cpu in i?86*) echo --disable-pic ;; *) echo --enable-pic ;; esac` \
+      --cc="$CC" &&
+      sed -i -e "s#define HAVE_SYMVER 1#define HAVE_SYMVER 0#" config.h &&
+      sed -i -e "s#define HAVE_SYMVER_GNU_ASM 1#define HAVE_SYMVER_GNU_ASM 0#" config.h
+  fi
+], [$USE_EXTERNAL_FFMPEG])
+
+XB_CONFIG_MODULE([lib/libdvd/libdvdcss], [
+  ./configure \
+    CC="$CC" \
+    CXX="$CXX" \
+    CFLAGS="$CFLAGS" \
+    --prefix="${prefix}" --includedir="${includedir}" --libdir="${libdir}" --datadir="${datadir}" \
+    --host=$host_alias \
+    --build=$build_alias \
+    --target=$target_alias \      
+    --disable-doc \
+    --enable-static \
+    --with-pic
+], [$SKIP_CONFIG_DVDCSS])
+
+XB_CONFIG_MODULE([lib/libdvd/libdvdread], [
+  ./configure2 \
+    --extra-cflags="$CFLAGS $DVDREAD_CFLAGS -I`pwd`/../libdvdcss/src" \
+    --prefix="${prefix}" --includedir="${includedir}" --libdir="${libdir}" --datadir="${datadir}" \
+    --host=$host_alias \
+    --build=$build_alias \
+    --target=$target_alias \      
+    --enable-static \
+    --disable-shared \
+    --disable-strip \
+    --disable-opts \
+    --cc="$CC" &&
+  $MAKE dvdread-config &&
+  mkdir -p `pwd`/../includes/dvdread
+  cp `pwd`/../libdvdread/src/*.h `pwd`/../includes/dvdread
+], [0])
+
+XB_CONFIG_MODULE([lib/libdvd/libdvdnav], [
+  ./configure2 \
+    --extra-cflags="$CFLAGS $DVDREAD_CFLAGS -I`pwd`/../includes" \
+    --extra-ldflags="-L`pwd`/../libdvdread/obj" \
+    --with-dvdread-config="`pwd`/../libdvdread/obj/dvdread-config" \
+    --prefix="${prefix}" --includedir="${includedir}" --libdir="${libdir}" --datadir="${datadir}" \
+    --host=$host_alias \
+    --build=$build_alias \
+    --target=$target_alias \      
+    --enable-static \
+    --disable-shared \
+    --cc="$CC"
+], [0])
+
+XB_CONFIG_MODULE([xbmc/visualizations/XBMCProjectM/libprojectM],[
+  set -x
+  rm -f CMakeCache.txt &&                              \
+  CC="$ORIGCC" CXX="$ORIGCXX" LDFLAGS="$LDFLAGS" cmake \
+    -DCMAKE_BUILD_TYPE=None -DUSE_FTGL:BOOL=OFF        \
+    -DCMAKE_C_FLAGS:STRING="${CPPFLAGS} ${CFLAGS}"     \
+    -DCMAKE_CXX_FLAGS:STRING="${CPPFLAGS} ${CXXFLAGS}" \
+    -DCMAKE_INSTALL_PREFIX="${prefix}"                 \
+    -DCMAKE_INSTALL_LIBDIR:PATH="${libdir}"            \
+    -DINCLUDE_INSTALL_DIR:PATH="${includedir}"         \
+    -DLIB_INSTALL_DIR:PATH="${libdir}"                 \
+    -DSYSCONF_INSTALL_DIR:PATH="${sysconfdir}"         \
+    -DSHARE_INSTALL_PREFIX:PATH="${datadir}" . &&
+  if test "$host_vendor" = "apple" ; then
+    # cmake has hardcoded paths to macports which bork our darwin depends cross/ppc, remove them
+    sed -ie "s|-L/opt/local/lib| |" CMakeFiles/projectM.dir/link.txt
+    sed -ie "s|-L/opt/local/lib| |" CMakeFiles/projectM.dir/flags.make
+    sed -ie "s|-I/opt/local/include| |" CMakeFiles/projectM.dir/flags.make
+  fi
+  set +x
+], [$DISABLE_PROJECTM])
+
+XB_CONFIG_MODULE([xbmc/visualizations/Goom/goom2k4-0],[
+  ./configure  \
+    CFLAGS="$CFLAGS" \ 
+    CXXFLAGS="$CXXFLAGS" \
+    --prefix="${prefix}" --includedir="${includedir}" --libdir="${libdir}" --datadir="${datadir}" \
+    --host=$host_alias \
+    --build=$build_alias \
+    --target=$target_alias \      
+    --disable-shared \
+    --enable-static \
+    --with-pic
+], [$DISABLE_GOOM])
+
+XB_CONFIG_MODULE([xbmc/screensavers/rsxs-0.9/], [
+  if test "$host_vendor" = "apple"; then
+    TEMPCFLAGS="${CFLAGS} -fgnu89-inline";
+  else
+    TEMPCFLAGS="$CFLAGS";
+  fi
+  ./configure \
+    CC="$CC" \
+    CXX="$CXX" \
+    CFLAGS="$TEMPCFLAGS" \ 
+    CXXFLAGS="$CXXFLAGS" \
+    `if test "$host_vendor" = "apple"; then echo --with-png=${prefix} --x-includes=/usr/X11/include --x-libraries=/usr/X11/lib; fi` \
+    --prefix="${prefix}" --includedir="${includedir}" --libdir="${libdir}" --datadir="${datadir}" \
+    --host=$host_alias \
+    --build=$build_alias \
+    --target=$target_alias \      
+    --without-xscreensaver \
+    --disable-sound \
+    --disable-cyclone \
+    --disable-fieldlines \
+    --disable-flocks \
+    --disable-flux \
+    --disable-helios \
+    --disable-hyperspace \
+    --disable-lattice \
+    --disable-skyrocket
+  if echo "$ARCH" | grep -q freebsd ; then
+    sed -i.back "s;\(STDBOOL_H = \)stdbool.h;\1;" lib/Makefile
+  fi
+], [$DISABLE_RSXS])
+
+XB_CONFIG_MODULE([lib/cpluff], [
+  ./configure --disable-nls \
+    --prefix="${prefix}" --includedir="${includedir}" --libdir="${libdir}" --datadir="${datadir}" \
+    --host=$host_alias \
+    --build=$build_alias \
+    --target=$target_alias CFLAGS="$CFLAGS" CC="$CC" CXX="$CXX" LDFLAGS="$LDFLAGS" LIBS=""
+    #LDFLAGS="$LDFLAGS -Wl,-read_only_relocs,suppress"    
+], [0])
+
+XB_CONFIG_MODULE([lib/gtest], [
+  ./configure \
+    CC="$CC" \
+    CXX="$CXX" \
+    CFLAGS="$CFLAGS" \
+    --prefix="${prefix}" --includedir="${includedir}" --libdir="${libdir}" --datadir="${datadir}" \
+    --host=$host_alias \
+    --build=$build_alias \
+    --target=$target_alias \
+    --disable-shared \
+    --enable-static \
+    --with-pthreads
+], [$SKIP_CONFIG_GTEST])
+
+XB_CONFIG_MODULE([pvr-addons], [
+   if test "$USE_EXTERNAL_FFMPEG" = 1; then
+      PVR_EXT_FFMPEG="--enable-external-ffmpeg"
+   fi
+  ./configure \
+    --prefix="${prefix}" \
+    --host=$host_alias \
+    --build=$build_alias \
+    --target=$target_alias \
+    $PVR_EXT_FFMPEG \
+    CC="$CC" \
+    CXX="$CXX" \
+    CFLAGS="$CFLAGS" \
+    CXXFLAGS="$CXXFLAGS"
+], [$DISABLE_PVR_ADDON_CONFIG])
+
+AC_OUTPUT
+
+final_message="$final_message\n  prefix:\t$prefix\n$dashes"
+echo -e "$final_message\n"
diff -Nur xbmc-nightly.org/m4/ax_python_devel.m4 xbmc-nightly/m4/ax_python_devel.m4
--- xbmc-nightly.org/m4/ax_python_devel.m4	2014-01-24 21:55:44.111676535 -0800
+++ xbmc-nightly/m4/ax_python_devel.m4	2014-02-14 18:27:05.136589308 -0800
@@ -243,7 +243,7 @@
 			  "from distutils.sysconfig import get_python_lib as f; \
 			  import os; \
 			  print (os.path.join(f(plat_specific=1, standard_lib=1), 'config'));"`
-			PYTHON_LDFLAGS="-L$ac_python_libdir -lpython$ac_python_version"
+			PYTHON_LDFLAGS="-L$PY_PATH/include/python$PYTHON_VERSION -lpython$ac_python_version"
 		fi
 
 		if test -z "$PYTHON_LDFLAGS"; then
diff -Nur xbmc-nightly.org/Makefile.in xbmc-nightly/Makefile.in
--- xbmc-nightly.org/Makefile.in	2014-01-24 22:02:26.622833806 -0800
+++ xbmc-nightly/Makefile.in	2014-02-14 18:27:05.175594267 -0800
@@ -21,8 +21,7 @@
                    xbmc/cores/dvdplayer/DVDInputStreams/DVDInputStreams.a \
                    xbmc/cores/dvdplayer/DVDSubtitles/DVDSubtitles.a
 
-DIRECTORY_ARCHIVES=$(DVDPLAYER_ARCHIVES) \
-                   lib/SlingboxLib/SlingboxLib.a \
+DIRECTORY_ARCHIVES=lib/SlingboxLib/SlingboxLib.a \
                    lib/libRTV/librtv.a \
                    lib/libXDAAP/libxdaap.a \
                    lib/libhts/libhts.a \
@@ -30,7 +29,6 @@
                    lib/xbmc-dll-symbols/dll-symbols.a \
                    xbmc/addons/addons.a \
                    xbmc/cdrip/cdrip.a \
-                   xbmc/cores/AudioEngine/audioengine.a \
                    xbmc/cores/DllLoader/dllloader.a \
                    xbmc/cores/DllLoader/exports/exports.a \
                    xbmc/cores/DllLoader/exports/util/exports_utils.a \
@@ -38,7 +36,6 @@
                    xbmc/cores/VideoRenderers/VideoRenderer.a \
                    xbmc/cores/VideoRenderers/VideoShaders/VideoShaders.a \
                    xbmc/cores/cores.a \
-                   xbmc/cores/paplayer/paplayer.a \
                    xbmc/cores/playercorefactory/playercorefactory.a \
                    xbmc/dbwrappers/dbwrappers.a \
                    xbmc/dialogs/dialogs.a \
@@ -87,6 +84,21 @@
                    xbmc/windows/windows.a \
                    xbmc/xbmc.a \
 
+#ifeq (@USE_AUDIOENGINE@,1)
+DIRECTORY_ARCHIVES += xbmc/cores/AudioEngine/audioengine.a
+#endif
+
+ifeq (@USE_DVDPLAYER@,1)
+DIRECTORY_ARCHIVES += $(DVDPLAYER_ARCHIVES)
+endif
+
+#ifeq (@USE_PAPLAYER@,1)
+DIRECTORY_ARCHIVES += xbmc/cores/paplayer/paplayer.a
+#endif
+
+ifeq (@USE_GSTPLAYER@,1)
+DIRECTORY_ARCHIVES += xbmc/cores/gstplayer/gstplayer.a
+endif
 
 NWAOBJSXBMC=	xbmc/threads/threads.a \
 		xbmc/commons/commons.a
@@ -109,6 +121,11 @@
 DIRECTORY_ARCHIVES += xbmc/visualizations/EGLHelpers/eglhelpers.a
 endif
 
+ifeq (@USE_OPENGLESV1@,1)
+DIRECTORY_ARCHIVES += xbmc/rendering/gles/rendering_gles.a
+DIRECTORY_ARCHIVES += xbmc/windowing/egl/windowing_egl.a
+endif
+
 ifeq (@USE_UPNP@,1)
 DIRECTORY_ARCHIVES += lib/libUPnP/libupnp.a \
                       xbmc/network/upnp/upnp.a
@@ -193,8 +210,12 @@
   SS_DIRS+= xbmc/screensavers/rsxs-0.9/xbmc
 endif
 
-VIS_DIRS=xbmc/visualizations/OpenGLSpectrum \
-         xbmc/visualizations/WaveForm
+VIS_DIRS=
+ifneq (@USE_OPENGLESV1@,1)
+  VIS_DIRS+=\
+	xbmc/visualizations/OpenGLSpectrum \
+	xbmc/visualizations/WaveForm
+endif
 
 ifneq (@DISABLE_PROJECTM@,1)
   VIS_DIRS+= xbmc/visualizations/XBMCProjectM
@@ -369,7 +390,7 @@
   endif
 endif
 	$(MAKE) -C lib/stsound/StSoundLibrary
-ifeq ($(or $(findstring powerpc,@ARCH@),$(findstring x86_64-linux,@ARCH@),$(findstring arm, @ARCH@),$(findstring freebsd,@ARCH@)),)
+ifeq ($(or $(findstring powerpc,@ARCH@),$(findstring x86_64-linux,@ARCH@),$(findstring arm, @ARCH@),$(findstring freebsd,@ARCH@),$(findstring sh, @ARCH@)),)
 	$(MAKE) -C lib/snesapu/SNES/SNESAPU
 endif
 imagelib: dllloader
@@ -530,7 +551,7 @@
 		-exec install -m 0644 "{}" $(DESTDIR)$(datarootdir)/xbmc/"{}" \; \
 		-exec printf " -- %-75.75s\r" "{}" \;
 else
-	@find addons language media sounds userdata system -regextype posix-extended -type f -not -iregex ".*@ARCH@.*|.*\.vis|.*\.xbs|.*svn.*|.*\.so|.*\.dll|.*\.pvr" -exec install -D -m 0644 "{}" $(DESTDIR)$(datarootdir)/xbmc/"{}" \; -printf " -- %-75.75f\r"
+	@find addons language media sounds userdata system -regextype posix-extended -type f -not -iregex ".*-@ARCH@.*|.*\.vis|.*\.xbs|.*svn.*|.*\.so|.*\.dll|.*\.pvr" -exec install -D -m 0644 "{}" $(DESTDIR)$(datarootdir)/xbmc/"{}" \; -printf " -- %-75.75f\r"
 endif
 endif
 	@# Icons and links
diff -Nur xbmc-nightly.org/tools/TexturePacker/XBMCTex.cpp xbmc-nightly/tools/TexturePacker/XBMCTex.cpp
--- xbmc-nightly.org/tools/TexturePacker/XBMCTex.cpp	2014-01-24 22:02:28.004009345 -0800
+++ xbmc-nightly/tools/TexturePacker/XBMCTex.cpp	2014-02-14 18:27:05.136589309 -0800
@@ -297,6 +297,23 @@
   height = image->h;
   bool hasAlpha = HasAlpha(argb, width, height);
   
+  unsigned char* argb_pointer = argb;
+  float f;
+  for (int h = 0; h < height; h++)
+  {
+    for (int w = 0; w < width; w++)
+    {
+      f = ((unsigned char)*(argb_pointer + 3))/255.0; //a
+      *(argb_pointer) = ((unsigned char)*(argb_pointer))*f; //r
+      argb_pointer++;
+      *(argb_pointer) = ((unsigned char)*(argb_pointer))*f; //g
+      argb_pointer++;
+      *(argb_pointer) = ((unsigned char)*(argb_pointer))*f; //b
+      argb_pointer++;
+      argb_pointer++;
+    }
+  }
+  
   if (flags & FLAGS_USE_DXT)
   {
     double colorMSE, alphaMSE;
diff -Nur xbmc-nightly.org/tools/TexturePacker/XBMCTex.cpp.orig xbmc-nightly/tools/TexturePacker/XBMCTex.cpp.orig
--- xbmc-nightly.org/tools/TexturePacker/XBMCTex.cpp.orig	1969-12-31 16:00:00.000000000 -0800
+++ xbmc-nightly/tools/TexturePacker/XBMCTex.cpp.orig	2014-01-24 22:02:28.004009345 -0800
@@ -0,0 +1,616 @@
+/*
+ *      Copyright (C) 2005-2010 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#ifdef _WIN32
+#include <sys/types.h>
+#include <sys/stat.h>
+#define __STDC_FORMAT_MACROS
+#include <inttypes.h>
+#endif
+//#include <string>
+#include <cerrno>
+//#include <cstring>
+#include <dirent.h>
+#include <map>
+
+#include <SDL/SDL.h>
+#include <SDL/SDL_image.h>
+#undef main
+
+#include "guilib/XBTF.h"
+#include "XBTFWriter.h"
+#include "md5.h"
+#include "SDL_anigif.h"
+#include "cmdlineargs.h"
+#include "libsquish/squish.h"
+
+#ifdef _WIN32
+#define strncasecmp strnicmp
+#endif
+
+#ifdef USE_LZO_PACKING
+#ifdef _WIN32
+#include "../../lib/win32/liblzo/LZO1X.H"
+#else
+#include <lzo/lzo1x.h>
+#endif
+#endif
+
+using namespace std;
+
+#define FLAGS_USE_LZO     1
+#define FLAGS_ALLOW_YCOCG 2
+#define FLAGS_USE_DXT     4
+
+#define DIR_SEPARATOR "/"
+#define DIR_SEPARATOR_CHAR '/'
+
+int NP2( unsigned x )
+{
+  --x;
+  x |= x >> 1;
+  x |= x >> 2;
+  x |= x >> 4;
+  x |= x >> 8;
+  x |= x >> 16;
+  return ++x;
+}
+
+const char *GetFormatString(unsigned int format)
+{
+  switch (format)
+  {
+  case XB_FMT_DXT1:
+    return "DXT1 ";
+  case XB_FMT_DXT3:
+    return "DXT3 ";
+  case XB_FMT_DXT5:
+    return "DXT5 ";
+  case XB_FMT_DXT5_YCoCg:
+    return "YCoCg";
+  case XB_FMT_A8R8G8B8:
+    return "ARGB ";
+  case XB_FMT_A8:
+    return "A8   ";
+  default:
+    return "?????";
+  }
+}
+
+// returns true for png, bmp, tga, jpg and dds files, otherwise returns false
+bool IsGraphicsFile(char *strFileName)
+{
+  size_t n = strlen(strFileName);
+  if (n < 4)
+    return false;
+
+  if (strncasecmp(&strFileName[n-4], ".png", 4) &&
+      strncasecmp(&strFileName[n-4], ".bmp", 4) &&
+      strncasecmp(&strFileName[n-4], ".tga", 4) &&
+      strncasecmp(&strFileName[n-4], ".gif", 4) &&
+      strncasecmp(&strFileName[n-4], ".tbn", 4) &&
+      strncasecmp(&strFileName[n-4], ".jpg", 4))
+    return false;
+
+  return true;
+}
+
+// returns true for png, bmp, tga, jpg and dds files, otherwise returns false
+bool IsGIF(const char *strFileName)
+{
+  size_t n = strlen(strFileName);
+  if (n < 4)
+    return false;
+
+  if (strncasecmp(&strFileName[n-4], ".gif", 4))
+    return false;
+
+  return true;
+}
+
+void CreateSkeletonHeaderImpl(CXBTF& xbtf, std::string fullPath, std::string relativePath)
+{
+  struct dirent* dp;
+  struct stat stat_p;
+  DIR *dirp = opendir(fullPath.c_str());
+
+  if (dirp)
+  {
+    while ((dp = readdir(dirp)) != NULL)
+    {
+      if (strcmp(dp->d_name, ".") == 0 || strcmp(dp->d_name, "..") == 0) 
+      {
+        continue;
+      }
+
+      //stat to check for dir type (reiserfs fix)
+      std::string fileN = fullPath + "/" + dp->d_name;
+      if (stat(fileN.c_str(), &stat_p) == 0)
+      {
+        if (dp->d_type == DT_DIR || stat_p.st_mode & S_IFDIR)
+        {
+          std::string tmpPath = relativePath;
+          if (tmpPath.size() > 0)
+          {
+            tmpPath += "/";
+          }
+
+          CreateSkeletonHeaderImpl(xbtf, fullPath + DIR_SEPARATOR + dp->d_name, tmpPath + dp->d_name);
+        }
+        else if (IsGraphicsFile(dp->d_name))
+        {
+          std::string fileName = "";
+          if (relativePath.size() > 0)
+          {
+            fileName += relativePath;
+            fileName += "/";
+          }
+
+          fileName += dp->d_name;
+
+          CXBTFFile file;
+          file.SetPath(fileName);
+          xbtf.GetFiles().push_back(file);
+        }
+      }
+    }
+
+    closedir(dirp);
+  }
+  else
+  {
+    printf("Error opening %s (%s)\n", fullPath.c_str(), strerror(errno));
+  }
+}
+
+void CreateSkeletonHeader(CXBTF& xbtf, std::string fullPath)
+{
+  std::string temp;
+  CreateSkeletonHeaderImpl(xbtf, fullPath, temp);
+}
+
+CXBTFFrame appendContent(CXBTFWriter &writer, int width, int height, unsigned char *data, unsigned int size, unsigned int format, bool hasAlpha, unsigned int flags)
+{
+  CXBTFFrame frame;
+#ifdef USE_LZO_PACKING
+  lzo_uint packedSize = size;
+
+  if ((flags & FLAGS_USE_LZO) == FLAGS_USE_LZO)
+  {
+    // grab a temporary buffer for unpacking into
+    packedSize = size + size / 16 + 64 + 3; // see simple.c in lzo
+    unsigned char *packed  = new unsigned char[packedSize];
+    unsigned char *working = new unsigned char[LZO1X_999_MEM_COMPRESS];
+    if (packed && working)
+    {
+      if (lzo1x_999_compress(data, size, packed, &packedSize, working) != LZO_E_OK || packedSize > size)
+      {
+        // compression failed, or compressed size is bigger than uncompressed, so store as uncompressed
+        packedSize = size;
+        writer.AppendContent(data, size);
+      }
+      else
+      { // success
+        lzo_uint optimSize = size;
+        if (lzo1x_optimize(packed, packedSize, data, &optimSize, NULL) != LZO_E_OK || optimSize != size)
+        { //optimisation failed
+          packedSize = size;
+          writer.AppendContent(data, size);
+        }
+        else
+        { // success
+          writer.AppendContent(packed, packedSize);
+        }
+      }
+      delete[] working;
+      delete[] packed;
+    }
+  }
+  else
+#else
+  unsigned int packedSize = size;
+#endif
+  {
+    writer.AppendContent(data, size);
+  }
+  frame.SetPackedSize(packedSize);
+  frame.SetUnpackedSize(size);
+  frame.SetWidth(width);
+  frame.SetHeight(height);
+  frame.SetFormat(hasAlpha ? format : format | XB_FMT_OPAQUE);
+  frame.SetDuration(0);
+  return frame;
+}
+
+void CompressImage(const squish::u8 *brga, int width, int height, squish::u8 *compressed, unsigned int flags, double &colorMSE, double &alphaMSE)
+{
+  squish::CompressImage(brga, width, height, compressed, flags | squish::kSourceBGRA);
+  squish::ComputeMSE(brga, width, height, compressed, flags | squish::kSourceBGRA, colorMSE, alphaMSE);
+}
+
+bool HasAlpha(unsigned char *argb, unsigned int width, unsigned int height)
+{
+  unsigned char *p = argb + 3; // offset of alpha
+  for (unsigned int i = 0; i < 4*width*height; i += 4)
+  {
+    if (p[i] != 0xff)
+      return true;
+  }
+  return false;
+}
+
+CXBTFFrame createXBTFFrame(SDL_Surface* image, CXBTFWriter& writer, double maxMSE, unsigned int flags)
+{
+  // Convert to ARGB
+  SDL_PixelFormat argbFormat;
+  memset(&argbFormat, 0, sizeof(SDL_PixelFormat));
+  argbFormat.BitsPerPixel = 32;
+  argbFormat.BytesPerPixel = 4;
+
+  // For DXT5 we need RGBA
+#if defined(HOST_BIGENDIAN)
+  argbFormat.Amask = 0x000000ff;
+  argbFormat.Ashift = 0;
+  argbFormat.Rmask = 0x0000ff00;
+  argbFormat.Rshift = 8;
+  argbFormat.Gmask = 0x00ff0000;
+  argbFormat.Gshift = 16;
+  argbFormat.Bmask = 0xff000000;
+  argbFormat.Bshift = 24;
+#else
+  argbFormat.Amask = 0xff000000;
+  argbFormat.Ashift = 24;
+  argbFormat.Rmask = 0x00ff0000;
+  argbFormat.Rshift = 16;
+  argbFormat.Gmask = 0x0000ff00;
+  argbFormat.Gshift = 8;
+  argbFormat.Bmask = 0x000000ff;
+  argbFormat.Bshift = 0;
+#endif
+
+  int width, height;
+  unsigned int format = 0;
+  SDL_Surface *argbImage = SDL_ConvertSurface(image, &argbFormat, 0);
+  unsigned char* argb = (unsigned char*)argbImage->pixels;
+  unsigned int compressedSize = 0;
+  unsigned char* compressed = NULL;
+  
+  width  = image->w;
+  height = image->h;
+  bool hasAlpha = HasAlpha(argb, width, height);
+  
+  if (flags & FLAGS_USE_DXT)
+  {
+    double colorMSE, alphaMSE;
+    compressedSize = squish::GetStorageRequirements(width, height, squish::kDxt5);
+    compressed = new unsigned char[compressedSize];
+    // first try DXT1, which is only 4bits/pixel
+    CompressImage(argb, width, height, compressed, squish::kDxt1, colorMSE, alphaMSE);
+    if (colorMSE < maxMSE && alphaMSE < maxMSE)
+    { // success - use it
+      compressedSize = squish::GetStorageRequirements(width, height, squish::kDxt1);
+      format = XB_FMT_DXT1;
+    }
+    /* 
+    if (!format && alphaMSE == 0 && (flags & FLAGS_ALLOW_YCOCG) == FLAGS_ALLOW_YCOCG)
+    { 
+      // no alpha channel, so DXT5YCoCg is going to be the best DXT5 format
+      CompressImage(argb, width, height, compressed, squish::kDxt5 | squish::kUseYCoCg, colorMSE, alphaMSE);
+      if (colorMSE < maxMSE && alphaMSE < maxMSE)
+      { // success - use it
+        compressedSize = squish::GetStorageRequirements(width, height, squish::kDxt5);
+        format = XB_FMT_DXT5_YCoCg;
+      }
+    }
+    */
+    if (!format)
+    { // try DXT3 and DXT5 - use whichever is better (color is the same, but alpha will be different)
+      CompressImage(argb, width, height, compressed, squish::kDxt3, colorMSE, alphaMSE);
+      if (colorMSE < maxMSE)
+      { // color is fine, test DXT5 as well
+        double dxt5MSE;
+        squish::u8* compressed2 = new squish::u8[squish::GetStorageRequirements(width, height, squish::kDxt5)];
+        CompressImage(argb, width, height, compressed2, squish::kDxt5, colorMSE, dxt5MSE);
+        if (alphaMSE < maxMSE && alphaMSE < dxt5MSE)
+        { // DXT3 passes and is best
+          compressedSize = squish::GetStorageRequirements(width, height, squish::kDxt3);
+          format = XB_FMT_DXT3;
+        }
+        else if (dxt5MSE < maxMSE)
+        { // DXT5 passes
+          compressedSize = squish::GetStorageRequirements(width, height, squish::kDxt5);
+          memcpy(compressed, compressed2, compressedSize);
+          format = XB_FMT_DXT5;
+        }
+        delete[] compressed2;
+      }
+    }
+  }
+
+  CXBTFFrame frame; 
+  if (format)
+  {
+    frame = appendContent(writer, width, height, compressed, compressedSize, format, hasAlpha, flags);
+    if (compressedSize)
+      delete[] compressed;
+  }
+  else
+  {
+    // none of the compressed stuff works for us, so we use 32bit texture
+    format = XB_FMT_A8R8G8B8;
+    frame = appendContent(writer, width, height, argb, (width * height * 4), format, hasAlpha, flags);
+  }
+
+  SDL_FreeSurface(argbImage);
+  return frame;
+}
+
+void Usage()
+{
+  puts("Usage:");
+  puts("  -help            Show this screen.");
+  puts("  -input <dir>     Input directory. Default: current dir");
+  puts("  -output <dir>    Output directory/filename. Default: Textures.xpr");
+  puts("  -dupecheck       Enable duplicate file detection. Reduces output file size. Default: on");
+  puts("  -use_lzo         Use lz0 packing.     Default: on");
+  puts("  -use_dxt         Use DXT compression. Default: on");
+  puts("  -use_none        Use No  compression. Default: off");
+}
+
+static bool checkDupe(struct MD5Context* ctx,
+                      map<string,unsigned int>& hashes,
+                      vector<unsigned int>& dupes, unsigned int pos)
+{
+  unsigned char digest[17];
+  MD5Final(digest,ctx);
+  digest[16] = 0;
+  char hex[33];
+  sprintf(hex, "%02X%02X%02X%02X%02X%02X%02X%02X"\
+      "%02X%02X%02X%02X%02X%02X%02X%02X", digest[0], digest[1], digest[2],
+      digest[3], digest[4], digest[5], digest[6], digest[7], digest[8],
+      digest[9], digest[10], digest[11], digest[12], digest[13], digest[14],
+      digest[15]);
+  hex[32] = 0;
+  map<string,unsigned int>::iterator it = hashes.find(hex);
+  if (it != hashes.end())
+  {
+    dupes[pos] = it->second; 
+    return true;
+  }
+
+  hashes.insert(make_pair(hex,pos));
+  dupes[pos] = pos;
+
+  return false;
+}
+
+int createBundle(const std::string& InputDir, const std::string& OutputFile, double maxMSE, unsigned int flags, bool dupecheck)
+{
+  map<string,unsigned int> hashes;
+  vector<unsigned int> dupes;
+  CXBTF xbtf;
+  CreateSkeletonHeader(xbtf, InputDir);
+  dupes.resize(xbtf.GetFiles().size());
+  if (!dupecheck)
+  {
+    for (unsigned int i=0;i<dupes.size();++i)
+      dupes[i] = i;
+  }
+
+  CXBTFWriter writer(xbtf, OutputFile);
+  if (!writer.Create())
+  {
+    printf("Error creating file\n");
+    return 1;
+  }
+
+  std::vector<CXBTFFile>& files = xbtf.GetFiles();
+  for (size_t i = 0; i < files.size(); i++)
+  {
+    struct MD5Context ctx;
+    MD5Init(&ctx);
+    CXBTFFile& file = files[i];
+
+    std::string fullPath = InputDir;
+    fullPath += file.GetPath();
+
+    std::string output = file.GetPath();
+    output = output.substr(0, 40);
+    while (output.size() < 46)
+      output += ' ';
+    if (!IsGIF(fullPath.c_str()))
+    {
+      // Load the image
+      SDL_Surface* image = IMG_Load(fullPath.c_str());
+      if (!image)
+      {
+        printf("...unable to load image %s\n", file.GetPath());
+        continue;
+      }
+
+      bool skip=false;
+      printf("%s", output.c_str());
+      if (dupecheck)
+      {
+        MD5Update(&ctx,(const uint8_t*)image->pixels,image->h*image->pitch);
+        if (checkDupe(&ctx,hashes,dupes,i))
+        {
+          printf("****  duplicate of %s\n", files[dupes[i]].GetPath());
+          file.GetFrames().insert(file.GetFrames().end(),
+            files[dupes[i]].GetFrames().begin(), files[dupes[i]].GetFrames().end());
+          skip = true;
+        }
+      }
+
+      if (!skip)
+      {
+        CXBTFFrame frame = createXBTFFrame(image, writer, maxMSE, flags);
+
+        printf("%s%c (%d,%d @ %"PRIu64" bytes)\n", GetFormatString(frame.GetFormat()), frame.HasAlpha() ? ' ' : '*',
+          frame.GetWidth(), frame.GetHeight(), frame.GetUnpackedSize());
+
+        file.SetLoop(0);
+        file.GetFrames().push_back(frame);
+      }
+      SDL_FreeSurface(image);
+    }
+    else
+    {
+      int gnAG = AG_LoadGIF(fullPath.c_str(), NULL, 0);
+      AG_Frame* gpAG = new AG_Frame[gnAG];
+      AG_LoadGIF(fullPath.c_str(), gpAG, gnAG);
+
+      printf("%s\n", output.c_str());
+      bool skip=false;
+      if (dupecheck)
+      {
+        for (int j = 0; j < gnAG; j++)
+          MD5Update(&ctx,
+            (const uint8_t*)gpAG[j].surface->pixels,
+            gpAG[j].surface->h * gpAG[j].surface->pitch);
+
+        if (checkDupe(&ctx,hashes,dupes,i))
+        {
+          printf("****  duplicate of %s\n", files[dupes[i]].GetPath());
+          file.GetFrames().insert(file.GetFrames().end(),
+            files[dupes[i]].GetFrames().begin(), files[dupes[i]].GetFrames().end());
+          skip = true;
+        }
+      }
+
+      if (!skip)
+      {
+        for (int j = 0; j < gnAG; j++)
+        {
+          printf("    frame %4i                                ", j);
+          CXBTFFrame frame = createXBTFFrame(gpAG[j].surface, writer, maxMSE, flags);
+          frame.SetDuration(gpAG[j].delay);
+          file.GetFrames().push_back(frame);
+          printf("%s%c (%d,%d @ %"PRIu64" bytes)\n", GetFormatString(frame.GetFormat()), frame.HasAlpha() ? ' ' : '*',
+            frame.GetWidth(), frame.GetHeight(), frame.GetUnpackedSize());
+        }
+      }
+      AG_FreeSurfaces(gpAG, gnAG);
+      delete [] gpAG;
+
+      file.SetLoop(0);
+    }
+  }
+
+  if (!writer.UpdateHeader(dupes))
+  {
+    printf("Error writing header to file\n");
+    return 1;
+  }
+
+  if (!writer.Close())
+  {
+    printf("Error closing file\n");
+    return 1;
+  }
+
+  return 0;
+}
+
+int main(int argc, char* argv[])
+{
+#ifdef USE_LZO_PACKING
+  if (lzo_init() != LZO_E_OK)
+    return 1;
+#endif
+  bool valid = false;
+  unsigned int flags = 0;
+  bool dupecheck = false;
+  CmdLineArgs args(argc, (const char**)argv);
+
+  // setup some defaults, dxt with lzo post packing,
+  flags = FLAGS_USE_DXT;
+#ifdef USE_LZO_PACKING
+  flags |= FLAGS_USE_LZO;
+#endif
+
+  if (args.size() == 1)
+  {
+    Usage();
+    return 1;
+  }
+
+  std::string InputDir;
+  std::string OutputFilename = "Textures.xbt";
+
+  for (unsigned int i = 1; i < args.size(); ++i)
+  {
+    if (!stricmp(args[i], "-help") || !stricmp(args[i], "-h") || !stricmp(args[i], "-?"))
+    {
+      Usage();
+      return 1;
+    }
+    else if (!stricmp(args[i], "-input") || !stricmp(args[i], "-i"))
+    {
+      InputDir = args[++i];
+      valid = true;
+    }
+    else if (!strcmp(args[i], "-dupecheck"))
+    {
+      dupecheck = true;
+    }
+    else if (!stricmp(args[i], "-output") || !stricmp(args[i], "-o"))
+    {
+      OutputFilename = args[++i];
+      valid = true;
+#ifdef _LINUX
+      char *c = NULL;
+      while ((c = (char *)strchr(OutputFilename.c_str(), '\\')) != NULL) *c = '/';
+#endif
+    }
+    else if (!stricmp(args[i], "-use_none"))
+    {
+      flags &= ~FLAGS_USE_DXT;
+    }
+    else if (!stricmp(args[i], "-use_dxt"))
+    {
+      flags |= FLAGS_USE_DXT;
+    }
+#ifdef USE_LZO_PACKING
+    else if (!stricmp(args[i], "-use_lzo"))
+    {
+      flags |= FLAGS_USE_LZO;
+    }
+#endif
+    else
+    {
+      printf("Unrecognized command line flag: %s\n", args[i]);
+    }
+  }
+
+  if (!valid)
+  {
+    Usage();
+    return 1;
+  }
+
+  size_t pos = InputDir.find_last_of(DIR_SEPARATOR);
+  if (pos != InputDir.length() - 1)
+    InputDir += DIR_SEPARATOR;
+
+  double maxMSE = 1.5;    // HQ only please
+  createBundle(InputDir, OutputFilename, maxMSE, flags, dupecheck);
+}
diff -Nur xbmc-nightly.org/xbmc/Application.cpp xbmc-nightly/xbmc/Application.cpp
--- xbmc-nightly.org/xbmc/Application.cpp	2014-01-24 22:02:28.101021674 -0800
+++ xbmc-nightly/xbmc/Application.cpp	2014-02-14 18:27:05.171593758 -0800
@@ -4098,10 +4098,19 @@
   // one of the players that allows gapless playback (paplayer, dvdplayer)
   if (m_pPlayer)
   {
-    if ( !(m_eCurrentPlayer == eNewCore && (m_eCurrentPlayer == EPC_DVDPLAYER || m_eCurrentPlayer  == EPC_PAPLAYER
+    if ( !(m_eCurrentPlayer == eNewCore && (0
+#ifdef HAS_DVDPLAYER
+            || m_eCurrentPlayer == EPC_DVDPLAYER
+#endif
+#ifdef HAS_PAPLAYER
+            || m_eCurrentPlayer  == EPC_PAPLAYER
+#endif
 #if defined(HAS_OMXPLAYER)
             || m_eCurrentPlayer == EPC_OMXPLAYER
-#endif            
+#endif     
+#ifdef HAS_GSTPLAYER
+            || m_eCurrentPlayer  == EPC_GSTPLAYER
+#endif       
             )) )
     {
       delete m_pPlayer;
diff -Nur xbmc-nightly.org/xbmc/Application.cpp.orig xbmc-nightly/xbmc/Application.cpp.orig
--- xbmc-nightly.org/xbmc/Application.cpp.orig	1969-12-31 16:00:00.000000000 -0800
+++ xbmc-nightly/xbmc/Application.cpp.orig	2014-01-24 22:02:28.101021674 -0800
@@ -0,0 +1,5920 @@
+/*
+ *      Copyright (C) 2005-2012 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "network/Network.h"
+#include "threads/SystemClock.h"
+#include "system.h"
+#include "Application.h"
+#include "interfaces/Builtins.h"
+#include "utils/Variant.h"
+#include "utils/Splash.h"
+#include "LangInfo.h"
+#include "utils/Screenshot.h"
+#include "Util.h"
+#include "URL.h"
+#include "guilib/TextureManager.h"
+#include "cores/dvdplayer/DVDFileInfo.h"
+#include "cores/AudioEngine/AEFactory.h"
+#include "cores/AudioEngine/Utils/AEUtil.h"
+#include "PlayListPlayer.h"
+#include "Autorun.h"
+#include "video/Bookmark.h"
+#ifdef HAS_WEB_SERVER
+#include "network/WebServer.h"
+#include "network/httprequesthandler/HTTPImageHandler.h"
+#include "network/httprequesthandler/HTTPVfsHandler.h"
+#ifdef HAS_JSONRPC
+#include "network/httprequesthandler/HTTPJsonRpcHandler.h"
+#endif
+#ifdef HAS_WEB_INTERFACE
+#include "network/httprequesthandler/HTTPWebinterfaceHandler.h"
+#include "network/httprequesthandler/HTTPWebinterfaceAddonsHandler.h"
+#endif
+#endif
+#ifdef HAS_LCD
+#include "utils/LCDFactory.h"
+#endif
+#include "guilib/GUIControlProfiler.h"
+#include "utils/LangCodeExpander.h"
+#include "GUIInfoManager.h"
+#include "playlists/PlayListFactory.h"
+#include "guilib/GUIFontManager.h"
+#include "guilib/GUIColorManager.h"
+#include "guilib/GUITextLayout.h"
+#include "addons/Skin.h"
+#ifdef HAS_PYTHON
+#include "interfaces/python/XBPython.h"
+#endif
+#include "input/ButtonTranslator.h"
+#include "guilib/GUIAudioManager.h"
+#include "network/libscrobbler/lastfmscrobbler.h"
+#include "network/libscrobbler/librefmscrobbler.h"
+#include "GUIPassword.h"
+#include "input/InertialScrollingHandler.h"
+#include "ApplicationMessenger.h"
+#include "SectionLoader.h"
+#include "cores/DllLoader/DllLoaderContainer.h"
+#include "GUIUserMessages.h"
+#include "filesystem/DirectoryCache.h"
+#include "filesystem/StackDirectory.h"
+#include "filesystem/SpecialProtocol.h"
+#include "filesystem/DllLibCurl.h"
+#include "filesystem/MythSession.h"
+#include "filesystem/PluginDirectory.h"
+#ifdef HAS_FILESYSTEM_SAP
+#include "filesystem/SAPDirectory.h"
+#endif
+#ifdef HAS_FILESYSTEM_HTSP
+#include "filesystem/HTSPDirectory.h"
+#endif
+#include "utils/TuxBoxUtil.h"
+#include "utils/SystemInfo.h"
+#include "utils/TimeUtils.h"
+#include "GUILargeTextureManager.h"
+#include "TextureCache.h"
+#include "music/LastFmManager.h"
+#include "playlists/SmartPlayList.h"
+#ifdef HAS_FILESYSTEM_RAR
+#include "filesystem/RarManager.h"
+#endif
+#include "playlists/PlayList.h"
+#include "windowing/WindowingFactory.h"
+#include "powermanagement/PowerManager.h"
+#include "powermanagement/DPMSSupport.h"
+#include "settings/Settings.h"
+#include "settings/AdvancedSettings.h"
+#include "guilib/LocalizeStrings.h"
+#include "utils/CPUInfo.h"
+#include "utils/SeekHandler.h"
+
+#include "input/KeyboardStat.h"
+#include "input/XBMC_vkeys.h"
+#include "input/MouseStat.h"
+
+#ifdef HAS_SDL
+#include <SDL/SDL.h>
+#endif
+
+#if defined(FILESYSTEM) && !defined(_LINUX)
+#include "filesystem/FileDAAP.h"
+#endif
+#ifdef HAS_UPNP
+#include "network/upnp/UPnP.h"
+#include "filesystem/UPnPDirectory.h"
+#endif
+#if defined(_LINUX) && defined(HAS_FILESYSTEM_SMB)
+#include "filesystem/SMBDirectory.h"
+#endif
+#ifdef HAS_FILESYSTEM_NFS
+#include "filesystem/NFSFile.h"
+#endif
+#ifdef HAS_FILESYSTEM_AFP
+#include "filesystem/AFPFile.h"
+#endif
+#ifdef HAS_FILESYSTEM_SFTP
+#include "filesystem/SFTPFile.h"
+#endif
+#include "PartyModeManager.h"
+#ifdef HAS_VIDEO_PLAYBACK
+#include "cores/VideoRenderers/RenderManager.h"
+#endif
+#ifdef HAS_KARAOKE
+#include "music/karaoke/karaokelyricsmanager.h"
+#include "music/karaoke/GUIDialogKaraokeSongSelector.h"
+#include "music/karaoke/GUIWindowKaraokeLyrics.h"
+#endif
+#include "network/Zeroconf.h"
+#include "network/ZeroconfBrowser.h"
+#ifndef _LINUX
+#include "threads/platform/win/Win32Exception.h"
+#endif
+#ifdef HAS_EVENT_SERVER
+#include "network/EventServer.h"
+#endif
+#ifdef HAS_DBUS
+#include <dbus/dbus.h>
+#endif
+#ifdef HAS_JSONRPC
+#include "interfaces/json-rpc/JSONRPC.h"
+#include "network/TCPServer.h"
+#endif
+#ifdef HAS_AIRPLAY
+#include "network/AirPlayServer.h"
+#endif
+#ifdef HAS_AIRTUNES
+#include "network/AirTunesServer.h"
+#endif
+#if defined(HAVE_LIBCRYSTALHD)
+#include "cores/dvdplayer/DVDCodecs/Video/CrystalHD.h"
+#endif
+#include "interfaces/AnnouncementManager.h"
+#include "peripherals/Peripherals.h"
+#include "peripherals/dialogs/GUIDialogPeripheralManager.h"
+#include "peripherals/dialogs/GUIDialogPeripheralSettings.h"
+#include "peripherals/devices/PeripheralImon.h"
+#include "music/infoscanner/MusicInfoScanner.h"
+
+// Windows includes
+#include "guilib/GUIWindowManager.h"
+#include "windows/GUIWindowHome.h"
+#include "settings/GUIWindowSettings.h"
+#include "windows/GUIWindowFileManager.h"
+#include "settings/GUIWindowSettingsCategory.h"
+#include "music/windows/GUIWindowMusicPlaylist.h"
+#include "music/windows/GUIWindowMusicSongs.h"
+#include "music/windows/GUIWindowMusicNav.h"
+#include "music/windows/GUIWindowMusicPlaylistEditor.h"
+#include "video/windows/GUIWindowVideoPlaylist.h"
+#include "music/dialogs/GUIDialogMusicInfo.h"
+#include "video/dialogs/GUIDialogVideoInfo.h"
+#include "video/windows/GUIWindowVideoNav.h"
+#include "settings/GUIWindowSettingsProfile.h"
+#ifdef HAS_GL
+#include "rendering/gl/GUIWindowTestPatternGL.h"
+#endif
+#ifdef HAS_DX
+#include "rendering/dx/GUIWindowTestPatternDX.h"
+#endif
+#include "settings/GUIWindowSettingsScreenCalibration.h"
+#include "programs/GUIWindowPrograms.h"
+#include "pictures/GUIWindowPictures.h"
+#include "windows/GUIWindowWeather.h"
+#include "windows/GUIWindowLoginScreen.h"
+#include "addons/GUIWindowAddonBrowser.h"
+#include "music/windows/GUIWindowVisualisation.h"
+#include "windows/GUIWindowDebugInfo.h"
+#include "windows/GUIWindowPointer.h"
+#include "windows/GUIWindowSystemInfo.h"
+#include "windows/GUIWindowScreensaver.h"
+#include "windows/GUIWindowScreensaverDim.h"
+#include "pictures/GUIWindowSlideShow.h"
+#include "windows/GUIWindowStartup.h"
+#include "video/windows/GUIWindowFullScreen.h"
+#include "video/dialogs/GUIDialogVideoOSD.h"
+#include "music/dialogs/GUIDialogMusicOverlay.h"
+#include "video/dialogs/GUIDialogVideoOverlay.h"
+#include "video/VideoInfoScanner.h"
+
+// Dialog includes
+#include "music/dialogs/GUIDialogMusicOSD.h"
+#include "music/dialogs/GUIDialogVisualisationPresetList.h"
+#include "dialogs/GUIDialogTextViewer.h"
+#include "network/GUIDialogNetworkSetup.h"
+#include "dialogs/GUIDialogMediaSource.h"
+#include "video/dialogs/GUIDialogVideoSettings.h"
+#include "video/dialogs/GUIDialogAudioSubtitleSettings.h"
+#include "video/dialogs/GUIDialogVideoBookmarks.h"
+#include "settings/GUIDialogProfileSettings.h"
+#include "settings/GUIDialogLockSettings.h"
+#include "settings/GUIDialogContentSettings.h"
+#include "dialogs/GUIDialogBusy.h"
+#include "dialogs/GUIDialogKeyboardGeneric.h"
+#include "dialogs/GUIDialogYesNo.h"
+#include "dialogs/GUIDialogOK.h"
+#include "dialogs/GUIDialogProgress.h"
+#include "dialogs/GUIDialogExtendedProgressBar.h"
+#include "dialogs/GUIDialogSelect.h"
+#include "dialogs/GUIDialogSeekBar.h"
+#include "dialogs/GUIDialogKaiToast.h"
+#include "dialogs/GUIDialogVolumeBar.h"
+#include "dialogs/GUIDialogMuteBug.h"
+#include "video/dialogs/GUIDialogFileStacking.h"
+#include "dialogs/GUIDialogNumeric.h"
+#include "dialogs/GUIDialogGamepad.h"
+#include "dialogs/GUIDialogSubMenu.h"
+#include "dialogs/GUIDialogFavourites.h"
+#include "dialogs/GUIDialogButtonMenu.h"
+#include "dialogs/GUIDialogContextMenu.h"
+#include "dialogs/GUIDialogPlayerControls.h"
+#include "music/dialogs/GUIDialogSongInfo.h"
+#include "dialogs/GUIDialogSmartPlaylistEditor.h"
+#include "dialogs/GUIDialogSmartPlaylistRule.h"
+#include "pictures/GUIDialogPictureInfo.h"
+#include "addons/GUIDialogAddonSettings.h"
+#include "addons/GUIDialogAddonInfo.h"
+#ifdef HAS_LINUX_NETWORK
+#include "network/GUIDialogAccessPoints.h"
+#endif
+
+/* PVR related include Files */
+#include "pvr/PVRManager.h"
+#include "pvr/timers/PVRTimers.h"
+#include "pvr/windows/GUIWindowPVR.h"
+#include "pvr/dialogs/GUIDialogPVRChannelManager.h"
+#include "pvr/dialogs/GUIDialogPVRChannelsOSD.h"
+#include "pvr/dialogs/GUIDialogPVRCutterOSD.h"
+#include "pvr/dialogs/GUIDialogPVRDirectorOSD.h"
+#include "pvr/dialogs/GUIDialogPVRGroupManager.h"
+#include "pvr/dialogs/GUIDialogPVRGuideInfo.h"
+#include "pvr/dialogs/GUIDialogPVRGuideOSD.h"
+#include "pvr/dialogs/GUIDialogPVRGuideSearch.h"
+#include "pvr/dialogs/GUIDialogPVRRecordingInfo.h"
+#include "pvr/dialogs/GUIDialogPVRTimerSettings.h"
+
+#include "epg/EpgContainer.h"
+
+#include "video/dialogs/GUIDialogFullScreenInfo.h"
+#include "video/dialogs/GUIDialogTeletext.h"
+#include "dialogs/GUIDialogSlider.h"
+#include "guilib/GUIControlFactory.h"
+#include "dialogs/GUIDialogCache.h"
+#include "dialogs/GUIDialogPlayEject.h"
+#include "dialogs/GUIDialogMediaFilter.h"
+#include "utils/XMLUtils.h"
+#include "addons/AddonInstaller.h"
+
+#ifdef HAS_PERFORMANCE_SAMPLE
+#include "utils/PerformanceSample.h"
+#else
+#define MEASURE_FUNCTION
+#endif
+
+#ifdef TARGET_WINDOWS
+#include <shlobj.h>
+#include "win32util.h"
+#endif
+#ifdef HAS_XRANDR
+#include "windowing/X11/XRandR.h"
+#endif
+
+#ifdef TARGET_DARWIN_OSX
+#include "osx/CocoaInterface.h"
+#include "osx/XBMCHelper.h"
+#endif
+#ifdef TARGET_DARWIN
+#include "osx/DarwinUtils.h"
+#endif
+
+
+#ifdef HAS_DVD_DRIVE
+#include <cdio/logging.h>
+#endif
+
+#ifdef HAS_HAL
+#include "linux/HALManager.h"
+#endif
+
+#include "storage/MediaManager.h"
+#include "utils/JobManager.h"
+#include "utils/SaveFileStateJob.h"
+#include "utils/AlarmClock.h"
+#include "utils/StringUtils.h"
+#include "DatabaseManager.h"
+
+#ifdef _LINUX
+#include "XHandle.h"
+#endif
+
+#ifdef HAS_LIRC
+#include "input/linux/LIRC.h"
+#endif
+#ifdef HAS_IRSERVERSUITE
+  #include "input/windows/IRServerSuite.h"
+#endif
+
+#if defined(TARGET_WINDOWS)
+#include "input/windows/WINJoystick.h"
+#elif defined(HAS_SDL_JOYSTICK) || defined(HAS_EVENT_SERVER)
+#include "input/SDLJoystick.h"
+#endif
+
+#if defined(TARGET_ANDROID)
+#include "android/activity/XBMCApp.h"
+#endif
+
+using namespace std;
+using namespace ADDON;
+using namespace XFILE;
+#ifdef HAS_DVD_DRIVE
+using namespace MEDIA_DETECT;
+#endif
+using namespace PLAYLIST;
+using namespace VIDEO;
+using namespace MUSIC_INFO;
+#ifdef HAS_EVENT_SERVER
+using namespace EVENTSERVER;
+#endif
+#ifdef HAS_JSONRPC
+using namespace JSONRPC;
+#endif
+using namespace ANNOUNCEMENT;
+using namespace PVR;
+using namespace EPG;
+using namespace PERIPHERALS;
+
+using namespace XbmcThreads;
+
+// uncomment this if you want to use release libs in the debug build.
+// Atm this saves you 7 mb of memory
+#define USE_RELEASE_LIBS
+
+#define MAX_FFWD_SPEED 5
+
+//extern IDirectSoundRenderer* m_pAudioDecoder;
+CApplication::CApplication(void)
+  : m_pPlayer(NULL)
+#ifdef HAS_WEB_SERVER
+  , m_WebServer(*new CWebServer)
+  , m_httpImageHandler(*new CHTTPImageHandler)
+  , m_httpVfsHandler(*new CHTTPVfsHandler)
+#ifdef HAS_JSONRPC
+  , m_httpJsonRpcHandler(*new CHTTPJsonRpcHandler)
+#endif
+#ifdef HAS_WEB_INTERFACE
+  , m_httpWebinterfaceHandler(*new CHTTPWebinterfaceHandler)
+  , m_httpWebinterfaceAddonsHandler(*new CHTTPWebinterfaceAddonsHandler)
+#endif
+#endif
+  , m_itemCurrentFile(new CFileItem)
+  , m_stackFileItemToUpdate(new CFileItem)
+  , m_progressTrackingVideoResumeBookmark(*new CBookmark)
+  , m_progressTrackingItem(new CFileItem)
+  , m_videoInfoScanner(new CVideoInfoScanner)
+  , m_musicInfoScanner(new CMusicInfoScanner)
+  , m_seekHandler(new CSeekHandler)
+{
+  m_network = NULL;
+  TiXmlBase::SetCondenseWhiteSpace(false);
+  m_iPlaySpeed = 1;
+  m_bInhibitIdleShutdown = false;
+  m_bScreenSave = false;
+  m_dpms = NULL;
+  m_dpmsIsActive = false;
+  m_dpmsIsManual = false;
+  m_iScreenSaveLock = 0;
+  m_bInitializing = true;
+  m_eForcedNextPlayer = EPC_NONE;
+  m_strPlayListFile = "";
+  m_nextPlaylistItem = -1;
+  m_bPlaybackStarting = false;
+  m_skinReloading = false;
+
+#ifdef HAS_GLX
+  XInitThreads();
+#endif
+
+  //true while we in IsPaused mode! Workaround for OnPaused, which must be add. after v2.0
+  m_bIsPaused = false;
+
+  /* for now always keep this around */
+#ifdef HAS_KARAOKE
+  m_pKaraokeMgr = new CKaraokeLyricsManager();
+#endif
+  m_currentStack = new CFileItemList;
+
+  m_frameCount = 0;
+
+  m_bPresentFrame = false;
+  m_bPlatformDirectories = true;
+
+  m_bStandalone = false;
+  m_bEnableLegacyRes = false;
+  m_bSystemScreenSaverEnable = false;
+  m_pInertialScrollingHandler = new CInertialScrollingHandler();
+#ifdef HAS_DVD_DRIVE
+  m_Autorun = new CAutorun();
+#endif
+
+  m_splash = NULL;
+  m_threadID = 0;
+  m_eCurrentPlayer = EPC_NONE;
+  m_progressTrackingPlayCountUpdate = false;
+  m_currentStackPosition = 0;
+  m_lastFrameTime = 0;
+  m_lastRenderTime = 0;
+  m_bTestMode = false;
+}
+
+CApplication::~CApplication(void)
+{
+#ifdef HAS_WEB_SERVER
+  delete &m_WebServer;
+  delete &m_httpImageHandler;
+  delete &m_httpVfsHandler;
+#ifdef HAS_JSONRPC
+  delete &m_httpJsonRpcHandler;
+#endif
+#ifdef HAS_WEB_INTERFACE
+  delete &m_httpWebinterfaceHandler;
+  delete &m_httpWebinterfaceAddonsHandler;
+#endif
+#endif
+  delete m_musicInfoScanner;
+  delete m_videoInfoScanner;
+  delete &m_progressTrackingVideoResumeBookmark;
+#ifdef HAS_DVD_DRIVE
+  delete m_Autorun;
+#endif
+  delete m_currentStack;
+
+#ifdef HAS_KARAOKE
+  delete m_pKaraokeMgr;
+#endif
+
+  delete m_dpms;
+  delete m_seekHandler;
+  delete m_pInertialScrollingHandler;
+
+}
+
+bool CApplication::OnEvent(XBMC_Event& newEvent)
+{
+  switch(newEvent.type)
+  {
+    case XBMC_QUIT:
+      if (!g_application.m_bStop)
+        CApplicationMessenger::Get().Quit();
+      break;
+    case XBMC_KEYDOWN:
+      g_application.OnKey(g_Keyboard.ProcessKeyDown(newEvent.key.keysym));
+      break;
+    case XBMC_KEYUP:
+      g_Keyboard.ProcessKeyUp();
+      break;
+    case XBMC_MOUSEBUTTONDOWN:
+    case XBMC_MOUSEBUTTONUP:
+    case XBMC_MOUSEMOTION:
+      g_Mouse.HandleEvent(newEvent);
+      g_application.ProcessMouse();
+      break;
+    case XBMC_VIDEORESIZE:
+      if (!g_application.m_bInitializing &&
+          !g_advancedSettings.m_fullScreen)
+      {
+        g_Windowing.SetWindowResolution(newEvent.resize.w, newEvent.resize.h);
+        g_graphicsContext.SetVideoResolution(RES_WINDOW, true);
+        g_guiSettings.SetInt("window.width", newEvent.resize.w);
+        g_guiSettings.SetInt("window.height", newEvent.resize.h);
+        g_settings.Save();
+      }
+      break;
+    case XBMC_VIDEOMOVE:
+#ifdef TARGET_WINDOWS
+      if (g_advancedSettings.m_fullScreen)
+      {
+        // when fullscreen, remain fullscreen and resize to the dimensions of the new screen
+        RESOLUTION newRes = (RESOLUTION) g_Windowing.DesktopResolution(g_Windowing.GetCurrentScreen());
+        if (newRes != g_graphicsContext.GetVideoResolution())
+        {
+          g_guiSettings.SetResolution(newRes);
+          g_graphicsContext.SetVideoResolution(newRes);
+        }
+      }
+      else
+#endif
+      {
+        g_Windowing.OnMove(newEvent.move.x, newEvent.move.y);
+      }
+      break;
+    case XBMC_USEREVENT:
+      CApplicationMessenger::Get().UserEvent(newEvent.user.code);
+      break;
+    case XBMC_APPCOMMAND:
+      return g_application.OnAppCommand(newEvent.appcommand.action);
+  }
+  return true;
+}
+
+extern "C" void __stdcall init_emu_environ();
+extern "C" void __stdcall update_emu_environ();
+
+//
+// Utility function used to copy files from the application bundle
+// over to the user data directory in Application Support/XBMC.
+//
+static void CopyUserDataIfNeeded(const CStdString &strPath, const CStdString &file)
+{
+  CStdString destPath = URIUtils::AddFileToFolder(strPath, file);
+  if (!CFile::Exists(destPath))
+  {
+    // need to copy it across
+    CStdString srcPath = URIUtils::AddFileToFolder("special://xbmc/userdata/", file);
+    CFile::Cache(srcPath, destPath);
+  }
+}
+
+void CApplication::Preflight()
+{
+#ifdef HAS_DBUS
+  // call 'dbus_threads_init_default' before any other dbus calls in order to
+  // avoid race conditions with other threads using dbus connections
+  dbus_threads_init_default();
+#endif
+
+  // run any platform preflight scripts.
+#if defined(TARGET_DARWIN_OSX)
+  CStdString install_path;
+
+  CUtil::GetHomePath(install_path);
+  setenv("XBMC_HOME", install_path.c_str(), 0);
+  install_path += "/tools/darwin/runtime/preflight";
+  system(install_path.c_str());
+#endif
+}
+
+bool CApplication::Create()
+{
+#if defined(HAS_LINUX_NETWORK)
+  m_network = new CNetworkLinux();
+#elif defined(HAS_WIN32_NETWORK)
+  m_network = new CNetworkWin32();
+#else
+  m_network = new CNetwork();
+#endif
+
+  Preflight();
+  g_settings.Initialize(); //Initialize default AdvancedSettings
+
+#ifdef _LINUX
+  tzset();   // Initialize timezone information variables
+#endif
+
+  // Grab a handle to our thread to be used later in identifying the render thread.
+  m_threadID = CThread::GetCurrentThreadId();
+
+#ifndef _LINUX
+  //floating point precision to 24 bits (faster performance)
+  _controlfp(_PC_24, _MCW_PC);
+
+  /* install win32 exception translator, win32 exceptions
+   * can now be caught using c++ try catch */
+  win32_exception::install_handler();
+
+#endif
+
+  // only the InitDirectories* for the current platform should return true
+  // putting this before the first log entries saves another ifdef for g_settings.m_logFolder
+  bool inited = InitDirectoriesLinux();
+  if (!inited)
+    inited = InitDirectoriesOSX();
+  if (!inited)
+    inited = InitDirectoriesWin32();
+
+  // copy required files
+  CopyUserDataIfNeeded("special://masterprofile/", "RssFeeds.xml");
+  CopyUserDataIfNeeded("special://masterprofile/", "favourites.xml");
+  CopyUserDataIfNeeded("special://masterprofile/", "Lircmap.xml");
+  CopyUserDataIfNeeded("special://masterprofile/", "LCD.xml");
+
+  if (!CLog::Init(CSpecialProtocol::TranslatePath(g_settings.m_logFolder).c_str()))
+  {
+    fprintf(stderr,"Could not init logging classes. Permission errors on ~/.xbmc (%s)\n",
+      CSpecialProtocol::TranslatePath(g_settings.m_logFolder).c_str());
+    return false;
+  }
+
+  // Init our DllLoaders emu env
+  init_emu_environ();
+
+  g_settings.LoadProfiles(PROFILES_FILE);
+
+  CLog::Log(LOGNOTICE, "-----------------------------------------------------------------------");
+#if defined(TARGET_DARWIN_OSX)
+  CLog::Log(LOGNOTICE, "Starting XBMC (%s), Platform: Darwin OSX (%s). Built on %s", g_infoManager.GetVersion().c_str(), g_sysinfo.GetUnameVersion().c_str(), __DATE__);
+#elif defined(TARGET_DARWIN_IOS)
+  CLog::Log(LOGNOTICE, "Starting XBMC (%s), Platform: Darwin iOS (%s). Built on %s", g_infoManager.GetVersion().c_str(), g_sysinfo.GetUnameVersion().c_str(), __DATE__);
+#elif defined(__FreeBSD__)
+  CLog::Log(LOGNOTICE, "Starting XBMC (%s), Platform: FreeBSD (%s). Built on %s", g_infoManager.GetVersion().c_str(), g_sysinfo.GetUnameVersion().c_str(), __DATE__);
+#elif defined(_LINUX)
+  CLog::Log(LOGNOTICE, "Starting XBMC (%s), Platform: Linux (%s, %s). Built on %s", g_infoManager.GetVersion().c_str(), g_sysinfo.GetLinuxDistro().c_str(), g_sysinfo.GetUnameVersion().c_str(), __DATE__);
+#elif defined(_WIN32)
+  CLog::Log(LOGNOTICE, "Starting XBMC (%s), Platform: %s. Built on %s (compiler %i)", g_infoManager.GetVersion().c_str(), g_sysinfo.GetKernelVersion().c_str(), __DATE__, _MSC_VER);
+#if defined(__arm__)
+  if (g_cpuInfo.GetCPUFeatures() & CPU_FEATURE_NEON)
+    CLog::Log(LOGNOTICE, "ARM Features: Neon enabled");
+  else
+    CLog::Log(LOGNOTICE, "ARM Features: Neon disabled");
+#endif
+  CLog::Log(LOGNOTICE, g_cpuInfo.getCPUModel().c_str());
+  CLog::Log(LOGNOTICE, CWIN32Util::GetResInfoString());
+  CLog::Log(LOGNOTICE, "Running with %s rights", (CWIN32Util::IsCurrentUserLocalAdministrator() == TRUE) ? "administrator" : "restricted");
+  CLog::Log(LOGNOTICE, "Aero is %s", (g_sysinfo.IsAeroDisabled() == true) ? "disabled" : "enabled");
+#endif
+  CSpecialProtocol::LogPaths();
+
+  CStdString executable = CUtil::ResolveExecutablePath();
+  CLog::Log(LOGNOTICE, "The executable running is: %s", executable.c_str());
+  CLog::Log(LOGNOTICE, "Local hostname: %s", m_network->GetHostName().c_str());
+  CLog::Log(LOGNOTICE, "Log File is located: %sxbmc.log", g_settings.m_logFolder.c_str());
+  CLog::Log(LOGNOTICE, "-----------------------------------------------------------------------");
+
+  CStdString strExecutablePath;
+  CUtil::GetHomePath(strExecutablePath);
+
+  // if we are running from DVD our UserData location will be TDATA
+  if (URIUtils::IsDVD(strExecutablePath))
+  {
+    // TODO: Should we copy over any UserData folder from the DVD?
+    if (!CFile::Exists("special://masterprofile/guisettings.xml")) // first run - cache userdata folder
+    {
+      CFileItemList items;
+      CUtil::GetRecursiveListing("special://xbmc/userdata",items,"");
+      for (int i=0;i<items.Size();++i)
+          CFile::Cache(items[i]->GetPath(),"special://masterprofile/"+URIUtils::GetFileName(items[i]->GetPath()));
+    }
+    g_settings.m_logFolder = "special://masterprofile/";
+  }
+
+#ifdef HAS_XRANDR
+  g_xrandr.LoadCustomModeLinesToAllOutputs();
+#endif
+
+  // for python scripts that check the OS
+#if defined(TARGET_DARWIN)
+  setenv("OS","OS X",true);
+#elif defined(_LINUX)
+  setenv("OS","Linux",true);
+#elif defined(_WIN32)
+  SetEnvironmentVariable("OS","win32");
+#endif
+
+  g_powerManager.Initialize();
+
+  // Load the AudioEngine before settings as they need to query the engine
+  if (!CAEFactory::LoadEngine())
+  {
+    CLog::Log(LOGFATAL, "CApplication::Create: Failed to load an AudioEngine");
+    return false;
+  }
+
+  CLog::Log(LOGNOTICE, "load settings...");
+
+  g_guiSettings.Initialize();  // Initialize default Settings - don't move
+  g_powerManager.SetDefaults();
+  if (!g_settings.Load())
+  {
+    CLog::Log(LOGFATAL, "%s: Failed to reset settings", __FUNCTION__);
+    return false;
+  }
+
+  CLog::Log(LOGINFO, "creating subdirectories");
+  CLog::Log(LOGINFO, "userdata folder: %s", g_settings.GetProfileUserDataFolder().c_str());
+  CLog::Log(LOGINFO, "recording folder: %s", g_guiSettings.GetString("audiocds.recordingpath",false).c_str());
+  CLog::Log(LOGINFO, "screenshots folder: %s", g_guiSettings.GetString("debug.screenshotpath",false).c_str());
+  CDirectory::Create(g_settings.GetUserDataFolder());
+  CDirectory::Create(g_settings.GetProfileUserDataFolder());
+  g_settings.CreateProfileFolders();
+
+  update_emu_environ();//apply the GUI settings
+
+  // initialize our charset converter
+  g_charsetConverter.reset();
+
+  // Load the langinfo to have user charset <-> utf-8 conversion
+  CStdString strLanguage = g_guiSettings.GetString("locale.language");
+  strLanguage[0] = toupper(strLanguage[0]);
+
+  CStdString strLangInfoPath;
+  strLangInfoPath.Format("special://xbmc/language/%s/langinfo.xml", strLanguage.c_str());
+
+  CLog::Log(LOGINFO, "load language info file: %s", strLangInfoPath.c_str());
+  g_langInfo.Load(strLangInfoPath);
+
+  CStdString strLanguagePath = "special://xbmc/language/";
+
+  CLog::Log(LOGINFO, "load %s language file, from path: %s", strLanguage.c_str(), strLanguagePath.c_str());
+  if (!g_localizeStrings.Load(strLanguagePath, strLanguage))
+  {
+    CLog::Log(LOGFATAL, "%s: Failed to load %s language file, from path: %s", __FUNCTION__, strLanguage.c_str(), strLanguagePath.c_str());
+    return false;
+  }
+
+  // start the AudioEngine
+  if (!CAEFactory::StartEngine())
+  {
+    CLog::Log(LOGFATAL, "CApplication::Create: Failed to start the AudioEngine");
+    return false;
+  }
+
+  // restore AE's previous volume state
+  SetHardwareVolume(g_settings.m_fVolumeLevel);
+  CAEFactory::SetMute     (g_settings.m_bMute);
+  CAEFactory::SetSoundMode(g_guiSettings.GetInt("audiooutput.guisoundmode"));
+
+  // initialize the addon database (must be before the addon manager is init'd)
+  CDatabaseManager::Get().Initialize(true);
+
+  // start-up Addons Framework
+  // currently bails out if either cpluff Dll is unavailable or system dir can not be scanned
+  if (!CAddonMgr::Get().Init())
+  {
+    CLog::Log(LOGFATAL, "CApplication::Create: Unable to start CAddonMgr");
+    return false;
+  }
+
+  g_peripherals.Initialise();
+
+  // Create the Mouse, Keyboard, Remote, and Joystick devices
+  // Initialize after loading settings to get joystick deadzone setting
+  g_Mouse.Initialize();
+  g_Mouse.SetEnabled(g_guiSettings.GetBool("input.enablemouse"));
+
+  g_Keyboard.Initialize();
+#if defined(HAS_LIRC) || defined(HAS_IRSERVERSUITE)
+  g_RemoteControl.Initialize();
+#endif
+
+#if defined(TARGET_DARWIN_OSX)
+  // Configure and possible manually start the helper.
+  XBMCHelper::GetInstance().Configure();
+#endif
+
+  CUtil::InitRandomSeed();
+
+  g_mediaManager.Initialize();
+
+  m_lastFrameTime = XbmcThreads::SystemClockMillis();
+  m_lastRenderTime = m_lastFrameTime;
+  return true;
+}
+
+bool CApplication::CreateGUI()
+{
+  m_renderGUI = true;
+#ifdef HAS_SDL
+  CLog::Log(LOGNOTICE, "Setup SDL");
+
+  /* Clean up on exit, exit on window close and interrupt */
+  atexit(SDL_Quit);
+
+  uint32_t sdlFlags = 0;
+
+#if defined(HAS_SDL_OPENGL) || (HAS_GLES == 2)
+  sdlFlags |= SDL_INIT_VIDEO;
+#endif
+
+#if defined(HAS_SDL_JOYSTICK) && !defined(TARGET_WINDOWS)
+  sdlFlags |= SDL_INIT_JOYSTICK;
+#endif
+
+  //depending on how it's compiled, SDL periodically calls XResetScreenSaver when it's fullscreen
+  //this might bring the monitor out of standby, so we have to disable it explicitly
+  //by passing 0 for overwrite to setsenv, the user can still override this by setting the environment variable
+#if defined(_LINUX) && !defined(TARGET_DARWIN)
+  setenv("SDL_VIDEO_ALLOW_SCREENSAVER", "1", 0);
+#endif
+
+#endif // HAS_SDL
+
+#ifdef _LINUX
+  // for nvidia cards - vsync currently ALWAYS enabled.
+  // the reason is that after screen has been setup changing this env var will make no difference.
+  setenv("__GL_SYNC_TO_VBLANK", "1", 0);
+  setenv("__GL_YIELD", "USLEEP", 0);
+#endif
+
+  m_bSystemScreenSaverEnable = g_Windowing.IsSystemScreenSaverEnabled();
+  g_Windowing.EnableSystemScreenSaver(false);
+
+#ifdef HAS_SDL
+  if (SDL_Init(sdlFlags) != 0)
+  {
+    CLog::Log(LOGFATAL, "XBAppEx: Unable to initialize SDL: %s", SDL_GetError());
+    return false;
+  }
+  #if defined(TARGET_DARWIN)
+  // SDL_Init will install a handler for segfaults, restore the default handler.
+  signal(SIGSEGV, SIG_DFL);
+  #endif
+#endif
+
+  // Initialize core peripheral port support. Note: If these parameters
+  // are 0 and NULL, respectively, then the default number and types of
+  // controllers will be initialized.
+  if (!g_Windowing.InitWindowSystem())
+  {
+    CLog::Log(LOGFATAL, "CApplication::Create: Unable to init windowing system");
+    return false;
+  }
+
+  // Retrieve the matching resolution based on GUI settings
+  g_guiSettings.m_LookAndFeelResolution = g_guiSettings.GetResolution();
+  CLog::Log(LOGNOTICE, "Checking resolution %i", g_guiSettings.m_LookAndFeelResolution);
+  if (!g_graphicsContext.IsValidResolution(g_guiSettings.m_LookAndFeelResolution))
+  {
+    CLog::Log(LOGNOTICE, "Setting safe mode %i", RES_DESKTOP);
+    g_guiSettings.SetResolution(RES_DESKTOP);
+  }
+
+  // update the window resolution
+  g_Windowing.SetWindowResolution(g_guiSettings.GetInt("window.width"), g_guiSettings.GetInt("window.height"));
+
+  if (g_advancedSettings.m_startFullScreen && g_guiSettings.m_LookAndFeelResolution == RES_WINDOW)
+    g_guiSettings.m_LookAndFeelResolution = RES_DESKTOP;
+
+  if (!g_graphicsContext.IsValidResolution(g_guiSettings.m_LookAndFeelResolution))
+  {
+    // Oh uh - doesn't look good for starting in their wanted screenmode
+    CLog::Log(LOGERROR, "The screen resolution requested is not valid, resetting to a valid mode");
+    g_guiSettings.m_LookAndFeelResolution = RES_DESKTOP;
+  }
+  if (!InitWindow())
+  {
+    return false;
+  }
+
+  if (g_advancedSettings.m_splashImage)
+  {
+    CStdString strUserSplash = "special://home/media/Splash.png";
+    if (CFile::Exists(strUserSplash))
+    {
+      CLog::Log(LOGINFO, "load user splash image: %s", CSpecialProtocol::TranslatePath(strUserSplash).c_str());
+      m_splash = new CSplash(strUserSplash);
+    }
+    else
+    {
+      CLog::Log(LOGINFO, "load default splash image: %s", CSpecialProtocol::TranslatePath("special://xbmc/media/Splash.png").c_str());
+      m_splash = new CSplash("special://xbmc/media/Splash.png");
+    }
+    m_splash->Show();
+  }
+
+  // The key mappings may already have been loaded by a peripheral
+  CLog::Log(LOGINFO, "load keymapping");
+  if (!CButtonTranslator::GetInstance().Load())
+    return false;
+
+  int iResolution = g_graphicsContext.GetVideoResolution();
+  CLog::Log(LOGINFO, "GUI format %ix%i, Display %s",
+            g_settings.m_ResInfo[iResolution].iWidth,
+            g_settings.m_ResInfo[iResolution].iHeight,
+            g_settings.m_ResInfo[iResolution].strMode.c_str());
+  g_windowManager.Initialize();
+
+  return true;
+}
+
+bool CApplication::InitWindow()
+{
+#ifdef TARGET_DARWIN_OSX
+  // force initial window creation to be windowed, if fullscreen, it will switch to it below
+  // fixes the white screen of death if starting fullscreen and switching to windowed.
+  bool bFullScreen = false;
+  if (!g_Windowing.CreateNewWindow("XBMC", bFullScreen, g_settings.m_ResInfo[RES_WINDOW], OnEvent))
+  {
+    CLog::Log(LOGFATAL, "CApplication::Create: Unable to create window");
+    return false;
+  }
+#else
+  bool bFullScreen = g_guiSettings.m_LookAndFeelResolution != RES_WINDOW;
+  if (!g_Windowing.CreateNewWindow("XBMC", bFullScreen, g_settings.m_ResInfo[g_guiSettings.m_LookAndFeelResolution], OnEvent))
+  {
+    CLog::Log(LOGFATAL, "CApplication::Create: Unable to create window");
+    return false;
+  }
+#endif
+
+  if (!g_Windowing.InitRenderSystem())
+  {
+    CLog::Log(LOGFATAL, "CApplication::Create: Unable to init rendering system");
+    return false;
+  }
+  // set GUI res and force the clear of the screen
+  g_graphicsContext.SetVideoResolution(g_guiSettings.m_LookAndFeelResolution);
+  g_fontManager.ReloadTTFFonts();
+  return true;
+}
+
+bool CApplication::DestroyWindow()
+{
+  g_fontManager.UnloadTTFFonts();
+  return g_Windowing.DestroyWindow();
+}
+
+bool CApplication::InitDirectoriesLinux()
+{
+/*
+   The following is the directory mapping for Platform Specific Mode:
+
+   special://xbmc/          => [read-only] system directory (/usr/share/xbmc)
+   special://home/          => [read-write] user's directory that will override special://xbmc/ system-wide
+                               installations like skins, screensavers, etc.
+                               ($HOME/.xbmc)
+                               NOTE: XBMC will look in both special://xbmc/addons and special://home/addons for addons.
+   special://masterprofile/ => [read-write] userdata of master profile. It will by default be
+                               mapped to special://home/userdata ($HOME/.xbmc/userdata)
+   special://profile/       => [read-write] current profile's userdata directory.
+                               Generally special://masterprofile for the master profile or
+                               special://masterprofile/profiles/<profile_name> for other profiles.
+
+   NOTE: All these root directories are lowercase. Some of the sub-directories
+         might be mixed case.
+*/
+
+#if defined(_LINUX) && !defined(TARGET_DARWIN)
+  CStdString userName;
+  if (getenv("USER"))
+    userName = getenv("USER");
+  else
+    userName = "root";
+
+  CStdString userHome;
+  if (getenv("HOME"))
+    userHome = getenv("HOME");
+  else
+    userHome = "/root";
+
+  CStdString xbmcBinPath, xbmcPath;
+  CUtil::GetHomePath(xbmcBinPath, "XBMC_BIN_HOME");
+  xbmcPath = getenv("XBMC_HOME");
+
+  if (xbmcPath.IsEmpty())
+  {
+    xbmcPath = xbmcBinPath;
+    /* Check if xbmc binaries and arch independent data files are being kept in
+     * separate locations. */
+    if (!CFile::Exists(URIUtils::AddFileToFolder(xbmcPath, "language")))
+    {
+      /* Attempt to locate arch independent data files. */
+      CUtil::GetHomePath(xbmcPath);
+      if (!CFile::Exists(URIUtils::AddFileToFolder(xbmcPath, "language")))
+      {
+        fprintf(stderr, "Unable to find path to XBMC data files!\n");
+        exit(1);
+      }
+    }
+  }
+
+  /* Set some environment variables */
+  setenv("XBMC_BIN_HOME", xbmcBinPath.c_str(), 0);
+  setenv("XBMC_HOME", xbmcPath.c_str(), 0);
+
+  if (m_bPlatformDirectories)
+  {
+    // map our special drives
+    CSpecialProtocol::SetXBMCBinPath(xbmcBinPath);
+    CSpecialProtocol::SetXBMCPath(xbmcPath);
+    CSpecialProtocol::SetHomePath(userHome + "/.xbmc");
+    CSpecialProtocol::SetMasterProfilePath(userHome + "/.xbmc/userdata");
+
+    CStdString strTempPath = userHome;
+    strTempPath = URIUtils::AddFileToFolder(strTempPath, ".xbmc/temp");
+    if (getenv("XBMC_TEMP"))
+      strTempPath = getenv("XBMC_TEMP");
+    CSpecialProtocol::SetTempPath(strTempPath);
+
+    URIUtils::AddSlashAtEnd(strTempPath);
+    g_settings.m_logFolder = strTempPath;
+
+    CreateUserDirs();
+
+  }
+  else
+  {
+    URIUtils::AddSlashAtEnd(xbmcPath);
+    g_settings.m_logFolder = xbmcPath;
+
+    CSpecialProtocol::SetXBMCBinPath(xbmcBinPath);
+    CSpecialProtocol::SetXBMCPath(xbmcPath);
+    CSpecialProtocol::SetHomePath(URIUtils::AddFileToFolder(xbmcPath, "portable_data"));
+    CSpecialProtocol::SetMasterProfilePath(URIUtils::AddFileToFolder(xbmcPath, "portable_data/userdata"));
+
+    CStdString strTempPath = xbmcPath;
+    strTempPath = URIUtils::AddFileToFolder(strTempPath, "portable_data/temp");
+    if (getenv("XBMC_TEMP"))
+      strTempPath = getenv("XBMC_TEMP");
+    CSpecialProtocol::SetTempPath(strTempPath);
+    CreateUserDirs();
+
+    URIUtils::AddSlashAtEnd(strTempPath);
+    g_settings.m_logFolder = strTempPath;
+  }
+
+  return true;
+#else
+  return false;
+#endif
+}
+
+bool CApplication::InitDirectoriesOSX()
+{
+#if defined(TARGET_DARWIN)
+  CStdString userName;
+  if (getenv("USER"))
+    userName = getenv("USER");
+  else
+    userName = "root";
+
+  CStdString userHome;
+  if (getenv("HOME"))
+    userHome = getenv("HOME");
+  else
+    userHome = "/root";
+
+  CStdString xbmcPath;
+  CUtil::GetHomePath(xbmcPath);
+  setenv("XBMC_HOME", xbmcPath.c_str(), 0);
+
+#if defined(TARGET_DARWIN_IOS)
+  CStdString fontconfigPath;
+  fontconfigPath = xbmcPath + "/system/players/dvdplayer/etc/fonts/fonts.conf";
+  setenv("FONTCONFIG_FILE", fontconfigPath.c_str(), 0);
+#endif
+
+  // setup path to our internal dylibs so loader can find them
+  CStdString frameworksPath = CUtil::GetFrameworksPath();
+  CSpecialProtocol::SetXBMCFrameworksPath(frameworksPath);
+
+  // OSX always runs with m_bPlatformDirectories == true
+  if (m_bPlatformDirectories)
+  {
+    // map our special drives
+    CSpecialProtocol::SetXBMCBinPath(xbmcPath);
+    CSpecialProtocol::SetXBMCPath(xbmcPath);
+    #if defined(TARGET_DARWIN_IOS)
+      CSpecialProtocol::SetHomePath(userHome + "/Library/Preferences/XBMC");
+      CSpecialProtocol::SetMasterProfilePath(userHome + "/Library/Preferences/XBMC/userdata");
+    #else
+      CSpecialProtocol::SetHomePath(userHome + "/Library/Application Support/XBMC");
+      CSpecialProtocol::SetMasterProfilePath(userHome + "/Library/Application Support/XBMC/userdata");
+    #endif
+
+    // location for temp files
+    #if defined(TARGET_DARWIN_IOS)
+      CStdString strTempPath = URIUtils::AddFileToFolder(userHome,  "Library/Preferences/XBMC/temp");
+    #else
+      CStdString strTempPath = URIUtils::AddFileToFolder(userHome, ".xbmc/");
+      CDirectory::Create(strTempPath);
+      strTempPath = URIUtils::AddFileToFolder(userHome, ".xbmc/temp");
+    #endif
+    CSpecialProtocol::SetTempPath(strTempPath);
+
+    // xbmc.log file location
+    #if defined(TARGET_DARWIN_IOS)
+      strTempPath = userHome + "/Library/Preferences";
+    #else
+      strTempPath = userHome + "/Library/Logs";
+    #endif
+    URIUtils::AddSlashAtEnd(strTempPath);
+    g_settings.m_logFolder = strTempPath;
+
+    CreateUserDirs();
+  }
+  else
+  {
+    URIUtils::AddSlashAtEnd(xbmcPath);
+    g_settings.m_logFolder = xbmcPath;
+
+    CSpecialProtocol::SetXBMCBinPath(xbmcPath);
+    CSpecialProtocol::SetXBMCPath(xbmcPath);
+    CSpecialProtocol::SetHomePath(URIUtils::AddFileToFolder(xbmcPath, "portable_data"));
+    CSpecialProtocol::SetMasterProfilePath(URIUtils::AddFileToFolder(xbmcPath, "portable_data/userdata"));
+
+    CStdString strTempPath = URIUtils::AddFileToFolder(xbmcPath, "portable_data/temp");
+    CSpecialProtocol::SetTempPath(strTempPath);
+
+    URIUtils::AddSlashAtEnd(strTempPath);
+    g_settings.m_logFolder = strTempPath;
+  }
+
+  return true;
+#else
+  return false;
+#endif
+}
+
+bool CApplication::InitDirectoriesWin32()
+{
+#ifdef _WIN32
+  CStdString xbmcPath;
+
+  CUtil::GetHomePath(xbmcPath);
+  SetEnvironmentVariable("XBMC_HOME", xbmcPath.c_str());
+  CSpecialProtocol::SetXBMCBinPath(xbmcPath);
+  CSpecialProtocol::SetXBMCPath(xbmcPath);
+
+  CStdString strWin32UserFolder = CWIN32Util::GetProfilePath();
+
+  g_settings.m_logFolder = strWin32UserFolder;
+  CSpecialProtocol::SetHomePath(strWin32UserFolder);
+  CSpecialProtocol::SetMasterProfilePath(URIUtils::AddFileToFolder(strWin32UserFolder, "userdata"));
+  CSpecialProtocol::SetTempPath(URIUtils::AddFileToFolder(strWin32UserFolder,"cache"));
+
+  SetEnvironmentVariable("XBMC_PROFILE_USERDATA",CSpecialProtocol::TranslatePath("special://masterprofile/").c_str());
+
+  CreateUserDirs();
+
+  // Expand the DLL search path with our directories
+  CWIN32Util::ExtendDllPath();
+
+  return true;
+#else
+  return false;
+#endif
+}
+
+void CApplication::CreateUserDirs()
+{
+  CDirectory::Create("special://home/");
+  CDirectory::Create("special://home/addons");
+  CDirectory::Create("special://home/addons/packages");
+  CDirectory::Create("special://home/media");
+  CDirectory::Create("special://home/sounds");
+  CDirectory::Create("special://home/system");
+  CDirectory::Create("special://masterprofile/");
+  CDirectory::Create("special://temp/");
+  CDirectory::Create("special://temp/temp"); // temp directory for python and dllGetTempPathA
+}
+
+bool CApplication::Initialize()
+{
+#if defined(HAS_DVD_DRIVE) && !defined(_WIN32) // somehow this throws an "unresolved external symbol" on win32
+  // turn off cdio logging
+  cdio_loglevel_default = CDIO_LOG_ERROR;
+#endif
+
+#ifdef _LINUX // TODO: Win32 has no special://home/ mapping by default, so we
+              //       must create these here. Ideally this should be using special://home/ and
+              //       be platform agnostic (i.e. unify the InitDirectories*() functions)
+  if (!m_bPlatformDirectories)
+#endif
+  {
+    CDirectory::Create("special://xbmc/language");
+    CDirectory::Create("special://xbmc/addons");
+    CDirectory::Create("special://xbmc/sounds");
+  }
+
+  // Load curl so curl_global_init gets called before any service threads
+  // are started. Unloading will have no effect as curl is never fully unloaded.
+  // To quote man curl_global_init:
+  //  "This function is not thread safe. You must not call it when any other
+  //  thread in the program (i.e. a thread sharing the same memory) is running.
+  //  This doesn't just mean no other thread that is using libcurl. Because
+  //  curl_global_init() calls functions of other libraries that are similarly
+  //  thread unsafe, it could conflict with any other thread that
+  //  uses these other libraries."
+  g_curlInterface.Load();
+  g_curlInterface.Unload();
+
+  // initialize (and update as needed) our databases
+  CDatabaseManager::Get().Initialize();
+
+#ifdef HAS_WEB_SERVER
+  CWebServer::RegisterRequestHandler(&m_httpImageHandler);
+  CWebServer::RegisterRequestHandler(&m_httpVfsHandler);
+#ifdef HAS_JSONRPC
+  CWebServer::RegisterRequestHandler(&m_httpJsonRpcHandler);
+#endif
+#ifdef HAS_WEB_INTERFACE
+  CWebServer::RegisterRequestHandler(&m_httpWebinterfaceAddonsHandler);
+  CWebServer::RegisterRequestHandler(&m_httpWebinterfaceHandler);
+#endif
+#endif
+
+  StartServices();
+
+  // Init DPMS, before creating the corresponding setting control.
+  m_dpms = new DPMSSupport();
+  if (g_windowManager.Initialized())
+  {
+    g_guiSettings.GetSetting("powermanagement.displaysoff")->SetVisible(m_dpms->IsSupported());
+
+    g_windowManager.Add(new CGUIWindowHome);
+    g_windowManager.Add(new CGUIWindowPrograms);
+    g_windowManager.Add(new CGUIWindowPictures);
+    g_windowManager.Add(new CGUIWindowFileManager);
+    g_windowManager.Add(new CGUIWindowSettings);
+    g_windowManager.Add(new CGUIWindowSystemInfo);
+#ifdef HAS_GL
+    g_windowManager.Add(new CGUIWindowTestPatternGL);
+#endif
+#ifdef HAS_DX
+    g_windowManager.Add(new CGUIWindowTestPatternDX);
+#endif
+    g_windowManager.Add(new CGUIWindowSettingsScreenCalibration);
+    g_windowManager.Add(new CGUIWindowSettingsCategory);
+    g_windowManager.Add(new CGUIWindowVideoNav);
+    g_windowManager.Add(new CGUIWindowVideoPlaylist);
+    g_windowManager.Add(new CGUIWindowLoginScreen);
+    g_windowManager.Add(new CGUIWindowSettingsProfile);
+    g_windowManager.Add(new CGUIWindow(WINDOW_SKIN_SETTINGS, "SkinSettings.xml"));
+    g_windowManager.Add(new CGUIWindowAddonBrowser);
+    g_windowManager.Add(new CGUIWindowScreensaverDim);
+    g_windowManager.Add(new CGUIWindowDebugInfo);
+    g_windowManager.Add(new CGUIWindowPointer);
+    g_windowManager.Add(new CGUIDialogYesNo);
+    g_windowManager.Add(new CGUIDialogProgress);
+    g_windowManager.Add(new CGUIDialogExtendedProgressBar);
+    g_windowManager.Add(new CGUIDialogKeyboardGeneric);
+    g_windowManager.Add(new CGUIDialogVolumeBar);
+    g_windowManager.Add(new CGUIDialogSeekBar);
+    g_windowManager.Add(new CGUIDialogSubMenu);
+    g_windowManager.Add(new CGUIDialogContextMenu);
+    g_windowManager.Add(new CGUIDialogKaiToast);
+    g_windowManager.Add(new CGUIDialogNumeric);
+    g_windowManager.Add(new CGUIDialogGamepad);
+    g_windowManager.Add(new CGUIDialogButtonMenu);
+    g_windowManager.Add(new CGUIDialogMuteBug);
+    g_windowManager.Add(new CGUIDialogPlayerControls);
+#ifdef HAS_KARAOKE
+    g_windowManager.Add(new CGUIDialogKaraokeSongSelectorSmall);
+    g_windowManager.Add(new CGUIDialogKaraokeSongSelectorLarge);
+#endif
+    g_windowManager.Add(new CGUIDialogSlider);
+    g_windowManager.Add(new CGUIDialogMusicOSD);
+    g_windowManager.Add(new CGUIDialogVisualisationPresetList);
+    g_windowManager.Add(new CGUIDialogVideoSettings);
+    g_windowManager.Add(new CGUIDialogAudioSubtitleSettings);
+    g_windowManager.Add(new CGUIDialogVideoBookmarks);
+    // Don't add the filebrowser dialog - it's created and added when it's needed
+    g_windowManager.Add(new CGUIDialogNetworkSetup);
+    g_windowManager.Add(new CGUIDialogMediaSource);
+    g_windowManager.Add(new CGUIDialogProfileSettings);
+    g_windowManager.Add(new CGUIDialogFavourites);
+    g_windowManager.Add(new CGUIDialogSongInfo);
+    g_windowManager.Add(new CGUIDialogSmartPlaylistEditor);
+    g_windowManager.Add(new CGUIDialogSmartPlaylistRule);
+    g_windowManager.Add(new CGUIDialogBusy);
+    g_windowManager.Add(new CGUIDialogPictureInfo);
+    g_windowManager.Add(new CGUIDialogAddonInfo);
+    g_windowManager.Add(new CGUIDialogAddonSettings);
+#ifdef HAS_LINUX_NETWORK
+    g_windowManager.Add(new CGUIDialogAccessPoints);
+#endif
+
+    g_windowManager.Add(new CGUIDialogLockSettings);
+
+    g_windowManager.Add(new CGUIDialogContentSettings);
+
+    g_windowManager.Add(new CGUIDialogPlayEject);
+
+    g_windowManager.Add(new CGUIDialogPeripheralManager);
+    g_windowManager.Add(new CGUIDialogPeripheralSettings);
+    
+    g_windowManager.Add(new CGUIDialogMediaFilter);
+
+    g_windowManager.Add(new CGUIWindowMusicPlayList);
+    g_windowManager.Add(new CGUIWindowMusicSongs);
+    g_windowManager.Add(new CGUIWindowMusicNav);
+    g_windowManager.Add(new CGUIWindowMusicPlaylistEditor);
+
+    /* Load PVR related Windows and Dialogs */
+    g_windowManager.Add(new CGUIDialogTeletext);
+    g_windowManager.Add(new CGUIWindowPVR);
+    g_windowManager.Add(new CGUIDialogPVRGuideInfo);
+    g_windowManager.Add(new CGUIDialogPVRRecordingInfo);
+    g_windowManager.Add(new CGUIDialogPVRTimerSettings);
+    g_windowManager.Add(new CGUIDialogPVRGroupManager);
+    g_windowManager.Add(new CGUIDialogPVRChannelManager);
+    g_windowManager.Add(new CGUIDialogPVRGuideSearch);
+    g_windowManager.Add(new CGUIDialogPVRChannelsOSD);
+    g_windowManager.Add(new CGUIDialogPVRGuideOSD);
+    g_windowManager.Add(new CGUIDialogPVRDirectorOSD);
+    g_windowManager.Add(new CGUIDialogPVRCutterOSD);
+
+    g_windowManager.Add(new CGUIDialogSelect);
+    g_windowManager.Add(new CGUIDialogMusicInfo);
+    g_windowManager.Add(new CGUIDialogOK);
+    g_windowManager.Add(new CGUIDialogVideoInfo);
+    g_windowManager.Add(new CGUIDialogTextViewer);
+    g_windowManager.Add(new CGUIWindowFullScreen);
+    g_windowManager.Add(new CGUIWindowVisualisation);
+    g_windowManager.Add(new CGUIWindowSlideShow);
+    g_windowManager.Add(new CGUIDialogFileStacking);
+#ifdef HAS_KARAOKE
+    g_windowManager.Add(new CGUIWindowKaraokeLyrics);
+#endif
+
+    g_windowManager.Add(new CGUIDialogVideoOSD);
+    g_windowManager.Add(new CGUIDialogMusicOverlay);
+    g_windowManager.Add(new CGUIDialogVideoOverlay);
+    g_windowManager.Add(new CGUIWindowScreensaver);
+    g_windowManager.Add(new CGUIWindowWeather);
+    g_windowManager.Add(new CGUIWindowStartup);
+
+    /* window id's 3000 - 3100 are reserved for python */
+
+    // Make sure we have at least the default skin
+    if (!LoadSkin(g_guiSettings.GetString("lookandfeel.skin")) && !LoadSkin(DEFAULT_SKIN))
+    {
+        CLog::Log(LOGERROR, "Default skin '%s' not found! Terminating..", DEFAULT_SKIN);
+        return false;
+    }
+
+    if (g_advancedSettings.m_splashImage)
+      SAFE_DELETE(m_splash);
+
+    if (g_guiSettings.GetBool("masterlock.startuplock") &&
+        g_settings.GetMasterProfile().getLockMode() != LOCK_MODE_EVERYONE &&
+       !g_settings.GetMasterProfile().getLockCode().IsEmpty())
+    {
+       g_passwordManager.CheckStartUpLock();
+    }
+
+    // check if we should use the login screen
+    if (g_settings.UsingLoginScreen())
+      g_windowManager.ActivateWindow(WINDOW_LOGIN_SCREEN);
+    else
+    {
+#ifdef HAS_JSONRPC
+      CJSONRPC::Initialize();
+#endif
+      ADDON::CAddonMgr::Get().StartServices(false);
+      if (g_SkinInfo->GetFirstWindow() == WINDOW_PVR)
+      {
+        g_windowManager.ActivateWindow(WINDOW_HOME);
+        StartPVRManager(true);
+      }
+      else
+      {
+        StartPVRManager(false);
+        g_windowManager.ActivateWindow(g_SkinInfo->GetFirstWindow());
+      }
+    }
+
+  }
+  else //No GUI Created
+  {
+#ifdef HAS_JSONRPC
+    CJSONRPC::Initialize();
+#endif
+    ADDON::CAddonMgr::Get().StartServices(false);
+  }
+
+  g_sysinfo.Refresh();
+
+  CLog::Log(LOGINFO, "removing tempfiles");
+  CUtil::RemoveTempFiles();
+
+  if (!g_settings.UsingLoginScreen())
+  {
+    UpdateLibraries();
+#ifdef HAS_PYTHON
+    g_pythonParser.m_bLogin = true;
+#endif
+  }
+
+  m_slowTimer.StartZero();
+
+#if defined(HAVE_LIBCRYSTALHD)
+  CCrystalHD::GetInstance();
+#endif
+
+  CAddonMgr::Get().StartServices(true);
+
+  CLog::Log(LOGNOTICE, "initialize done");
+
+  m_bInitializing = false;
+
+  // reset our screensaver (starts timers etc.)
+  ResetScreenSaver();
+
+#ifdef HAS_SDL_JOYSTICK
+  g_Joystick.SetEnabled(g_guiSettings.GetBool("input.enablejoystick") &&
+                    CPeripheralImon::GetCountOfImonsConflictWithDInput() == 0 );
+#endif
+
+  return true;
+}
+
+bool CApplication::StartServer(enum ESERVERS eServer, bool bStart, bool bWait/* = false*/)
+{
+  bool ret = true;
+  bool oldSetting = false;
+
+  switch(eServer)
+  {
+    case ES_WEBSERVER:
+      oldSetting = g_guiSettings.GetBool("services.webserver");
+      g_guiSettings.SetBool("services.webserver", bStart);
+
+      if (bStart)
+        ret = StartWebServer();
+      else
+        StopWebServer();
+
+      if (!ret)
+      {
+        g_guiSettings.SetBool("services.webserver", oldSetting);
+      }
+      break;
+    case ES_AIRPLAYSERVER:
+      oldSetting = g_guiSettings.GetBool("services.esenabled");
+      g_guiSettings.SetBool("services.airplay", bStart);
+
+      if (bStart)
+        ret = StartAirplayServer();
+      else
+        StopAirplayServer(bWait);
+
+      if (!ret)
+      {
+        g_guiSettings.SetBool("services.esenabled", oldSetting);
+      }
+      break;
+    case ES_JSONRPCSERVER:
+      oldSetting = g_guiSettings.GetBool("services.esenabled");
+      g_guiSettings.SetBool("services.esenabled", bStart);
+
+      if (bStart)
+        ret = StartJSONRPCServer();
+      else
+        StopJSONRPCServer(bWait);
+
+      if (!ret)
+      {
+        g_guiSettings.SetBool("services.esenabled", oldSetting);
+      }
+      break;
+    case ES_UPNPSERVER:
+      g_guiSettings.SetBool("services.upnpserver", bStart);
+      if (bStart)
+        StartUPnPServer();
+      else
+        StopUPnPServer();
+      break;
+    case ES_UPNPRENDERER:
+      g_guiSettings.SetBool("services.upnprenderer", bStart);
+      if (bStart)
+        StartUPnPRenderer();
+      else
+        StopUPnPRenderer();
+      break;
+    case ES_EVENTSERVER:
+      oldSetting = g_guiSettings.GetBool("services.esenabled");
+      g_guiSettings.SetBool("services.esenabled", bStart);
+
+      if (bStart)
+        ret = StartEventServer();
+      else
+        StopEventServer(bWait, false);
+
+      if (!ret)
+      {
+        g_guiSettings.SetBool("services.esenabled", oldSetting);
+      }
+
+      break;
+    case ES_ZEROCONF:
+      g_guiSettings.SetBool("services.zeroconf", bStart);
+      if (bStart)
+        StartZeroconf();
+      else
+        StopZeroconf();
+      break;
+    default:
+      ret = false;
+      break;
+  }
+  g_settings.Save();
+
+  return ret;
+}
+
+bool CApplication::StartWebServer()
+{
+#ifdef HAS_WEB_SERVER
+  if (g_guiSettings.GetBool("services.webserver") && m_network->IsAvailable())
+  {
+    int webPort = atoi(g_guiSettings.GetString("services.webserverport"));
+    CLog::Log(LOGNOTICE, "Webserver: Starting...");
+#ifdef _LINUX
+    if (webPort < 1024 && !CUtil::CanBindPrivileged())
+    {
+        CLog::Log(LOGERROR, "Cannot start Web Server on port %i, no permission to bind to ports below 1024", webPort);
+        return false;
+    }
+#endif
+
+    bool started = false;
+    if (m_WebServer.Start(webPort, g_guiSettings.GetString("services.webserverusername"), g_guiSettings.GetString("services.webserverpassword")))
+    {
+      std::vector<std::pair<std::string, std::string> > txt;
+      started = true;
+      // publish web frontend and API services
+#ifdef HAS_WEB_INTERFACE
+      CZeroconf::GetInstance()->PublishService("servers.webserver", "_http._tcp", g_infoManager.GetLabel(SYSTEM_FRIENDLY_NAME), webPort, txt);
+#endif
+#ifdef HAS_JSONRPC
+      CZeroconf::GetInstance()->PublishService("servers.jsonrpc-http", "_xbmc-jsonrpc-h._tcp", g_infoManager.GetLabel(SYSTEM_FRIENDLY_NAME), webPort, txt);
+#endif
+    }
+
+    return started;
+  }
+#endif
+
+  return true;
+}
+
+void CApplication::StopWebServer()
+{
+#ifdef HAS_WEB_SERVER
+  if (m_WebServer.IsStarted())
+  {
+    CLog::Log(LOGNOTICE, "Webserver: Stopping...");
+    m_WebServer.Stop();
+    if(! m_WebServer.IsStarted() )
+    {
+      CLog::Log(LOGNOTICE, "Webserver: Stopped...");
+      CZeroconf::GetInstance()->RemoveService("servers.webserver");
+      CZeroconf::GetInstance()->RemoveService("servers.jsonrpc-http");
+      CZeroconf::GetInstance()->RemoveService("servers.webapi");
+    } else
+      CLog::Log(LOGWARNING, "Webserver: Failed to stop.");
+  }
+#endif
+}
+
+bool CApplication::StartAirplayServer()
+{
+  bool ret = false;
+#ifdef HAS_AIRPLAY
+  if (g_guiSettings.GetBool("services.airplay") && m_network->IsAvailable())
+  {
+    int listenPort = g_advancedSettings.m_airPlayPort;
+    CStdString password = g_guiSettings.GetString("services.airplaypassword");
+    bool usePassword = g_guiSettings.GetBool("services.useairplaypassword");
+
+    if (CAirPlayServer::StartServer(listenPort, true))
+    {
+      CAirPlayServer::SetCredentials(usePassword, password);
+      std::vector<std::pair<std::string, std::string> > txt;
+      CNetworkInterface* iface = g_application.getNetwork().GetFirstConnectedInterface();
+      if (iface)
+      {
+        txt.push_back(std::make_pair("deviceid", iface->GetMacAddress()));
+      }
+      else
+      {
+        txt.push_back(std::make_pair("deviceid", "FF:FF:FF:FF:FF:F2"));
+      }
+      txt.push_back(std::make_pair("features", "0x77"));
+      txt.push_back(std::make_pair("model", "Xbmc,1"));
+      txt.push_back(std::make_pair("srcvers", AIRPLAY_SERVER_VERSION_STR));
+      CZeroconf::GetInstance()->PublishService("servers.airplay", "_airplay._tcp", g_infoManager.GetLabel(SYSTEM_FRIENDLY_NAME), listenPort, txt);
+      ret = true;
+    }
+  }
+  if (ret)
+#endif
+  {
+#ifdef HAS_AIRTUNES
+    if (g_guiSettings.GetBool("services.airplay") && m_network->IsAvailable())
+    {
+      int listenPort = g_advancedSettings.m_airTunesPort;
+      CStdString password = g_guiSettings.GetString("services.airplaypassword");
+      bool usePassword = g_guiSettings.GetBool("services.useairplaypassword");
+
+      if (!CAirTunesServer::StartServer(listenPort, true, usePassword, password))
+      {
+        CLog::Log(LOGERROR, "Failed to start AirTunes Server");
+      }
+      ret = true;
+    }
+#endif
+  }
+  return ret;
+}
+
+void CApplication::StopAirplayServer(bool bWait)
+{
+#ifdef HAS_AIRPLAY
+  CAirPlayServer::StopServer(bWait);
+  CZeroconf::GetInstance()->RemoveService("servers.airplay");
+#endif
+#ifdef HAS_AIRTUNES
+  CAirTunesServer::StopServer(bWait);
+#endif
+}
+
+bool CApplication::StartJSONRPCServer()
+{
+#ifdef HAS_JSONRPC
+  if (g_guiSettings.GetBool("services.esenabled"))
+  {
+    if (CTCPServer::StartServer(g_advancedSettings.m_jsonTcpPort, g_guiSettings.GetBool("services.esallinterfaces")))
+    {
+      std::vector<std::pair<std::string, std::string> > txt;
+      CZeroconf::GetInstance()->PublishService("servers.jsonrpc-tpc", "_xbmc-jsonrpc._tcp", g_infoManager.GetLabel(SYSTEM_FRIENDLY_NAME), g_advancedSettings.m_jsonTcpPort, txt);
+      return true;
+    }
+    else
+      return false;
+  }
+#endif
+
+  return true;
+}
+
+void CApplication::StopJSONRPCServer(bool bWait)
+{
+#ifdef HAS_JSONRPC
+  CTCPServer::StopServer(bWait);
+  CZeroconf::GetInstance()->RemoveService("servers.jsonrpc-tcp");
+#endif
+}
+
+void CApplication::StartUPnP()
+{
+#ifdef HAS_UPNP
+  StartUPnPServer();
+  StartUPnPRenderer();
+#endif
+}
+
+void CApplication::StopUPnP(bool bWait)
+{
+#ifdef HAS_UPNP
+  if (UPNP::CUPnP::IsInstantiated())
+  {
+    CLog::Log(LOGNOTICE, "stopping upnp");
+    UPNP::CUPnP::ReleaseInstance(bWait);
+  }
+#endif
+}
+
+bool CApplication::StartEventServer()
+{
+#ifdef HAS_EVENT_SERVER
+  CEventServer* server = CEventServer::GetInstance();
+  if (!server)
+  {
+    CLog::Log(LOGERROR, "ES: Out of memory");
+    return false;
+  }
+  if (g_guiSettings.GetBool("services.esenabled"))
+  {
+    CLog::Log(LOGNOTICE, "ES: Starting event server");
+    server->StartServer();
+    return true;
+  }
+#endif
+  return true;
+}
+
+bool CApplication::StopEventServer(bool bWait, bool promptuser)
+{
+#ifdef HAS_EVENT_SERVER
+  CEventServer* server = CEventServer::GetInstance();
+  if (!server)
+  {
+    CLog::Log(LOGERROR, "ES: Out of memory");
+    return false;
+  }
+  if (promptuser)
+  {
+    if (server->GetNumberOfClients() > 0)
+    {
+      bool cancelled = false;
+      if (!CGUIDialogYesNo::ShowAndGetInput(13140, 13141, 13142, 20022,
+                                            -1, -1, cancelled, 10000)
+          || cancelled)
+      {
+        CLog::Log(LOGNOTICE, "ES: Not stopping event server");
+        return false;
+      }
+    }
+    CLog::Log(LOGNOTICE, "ES: Stopping event server with confirmation");
+
+    CEventServer::GetInstance()->StopServer(true);
+  }
+  else
+  {
+    if (!bWait)
+      CLog::Log(LOGNOTICE, "ES: Stopping event server");
+
+    CEventServer::GetInstance()->StopServer(bWait);
+  }
+
+  return true;
+#endif
+}
+
+void CApplication::RefreshEventServer()
+{
+#ifdef HAS_EVENT_SERVER
+  if (g_guiSettings.GetBool("services.esenabled"))
+  {
+    CEventServer::GetInstance()->RefreshSettings();
+  }
+#endif
+}
+
+void CApplication::StartUPnPRenderer()
+{
+#ifdef HAS_UPNP
+  if (g_guiSettings.GetBool("services.upnprenderer"))
+  {
+    CLog::Log(LOGNOTICE, "starting upnp renderer");
+    UPNP::CUPnP::GetInstance()->StartRenderer();
+  }
+#endif
+}
+
+void CApplication::StopUPnPRenderer()
+{
+#ifdef HAS_UPNP
+  if (UPNP::CUPnP::IsInstantiated())
+  {
+    CLog::Log(LOGNOTICE, "stopping upnp renderer");
+    UPNP::CUPnP::GetInstance()->StopRenderer();
+  }
+#endif
+}
+
+void CApplication::StartUPnPServer()
+{
+#ifdef HAS_UPNP
+  if (g_guiSettings.GetBool("services.upnpserver"))
+  {
+    CLog::Log(LOGNOTICE, "starting upnp server");
+    UPNP::CUPnP::GetInstance()->StartServer();
+  }
+#endif
+}
+
+void CApplication::StopUPnPServer()
+{
+#ifdef HAS_UPNP
+  if (UPNP::CUPnP::IsInstantiated())
+  {
+    CLog::Log(LOGNOTICE, "stopping upnp server");
+    UPNP::CUPnP::GetInstance()->StopServer();
+  }
+#endif
+}
+
+void CApplication::StartZeroconf()
+{
+#ifdef HAS_ZEROCONF
+  //entry in guisetting only present if HAS_ZEROCONF is set
+  if(g_guiSettings.GetBool("services.zeroconf"))
+  {
+    CLog::Log(LOGNOTICE, "starting zeroconf publishing");
+    CZeroconf::GetInstance()->Start();
+  }
+#endif
+}
+
+void CApplication::StopZeroconf()
+{
+#ifdef HAS_ZEROCONF
+  if(CZeroconf::IsInstantiated())
+  {
+    CLog::Log(LOGNOTICE, "stopping zeroconf publishing");
+    CZeroconf::GetInstance()->Stop();
+  }
+#endif
+}
+
+void CApplication::StartPVRManager(bool bOpenPVRWindow /* = false */)
+{
+  if (g_guiSettings.GetBool("pvrmanager.enabled"))
+    g_PVRManager.Start(true, bOpenPVRWindow);
+}
+
+void CApplication::StopPVRManager()
+{
+  CLog::Log(LOGINFO, "stopping PVRManager");
+  if (g_PVRManager.IsPlaying())
+    StopPlaying();
+  g_PVRManager.Stop();
+  g_EpgContainer.Stop();
+}
+
+void CApplication::DimLCDOnPlayback(bool dim)
+{
+#ifdef HAS_LCD
+  if (g_lcd)
+  {
+    if (dim)
+      g_lcd->DisableOnPlayback(IsPlayingVideo(), IsPlayingAudio());
+    else
+      g_lcd->SetBackLight(1);
+  }
+#endif
+}
+
+void CApplication::StartServices()
+{
+#if !defined(_WIN32) && defined(HAS_DVD_DRIVE)
+  // Start Thread for DVD Mediatype detection
+  CLog::Log(LOGNOTICE, "start dvd mediatype detection");
+  m_DetectDVDType.Create(false, THREAD_MINSTACKSIZE);
+#endif
+
+  CLog::Log(LOGNOTICE, "initializing playlistplayer");
+  g_playlistPlayer.SetRepeat(PLAYLIST_MUSIC, g_settings.m_bMyMusicPlaylistRepeat ? PLAYLIST::REPEAT_ALL : PLAYLIST::REPEAT_NONE);
+  g_playlistPlayer.SetShuffle(PLAYLIST_MUSIC, g_settings.m_bMyMusicPlaylistShuffle);
+  g_playlistPlayer.SetRepeat(PLAYLIST_VIDEO, g_settings.m_bMyVideoPlaylistRepeat ? PLAYLIST::REPEAT_ALL : PLAYLIST::REPEAT_NONE);
+  g_playlistPlayer.SetShuffle(PLAYLIST_VIDEO, g_settings.m_bMyVideoPlaylistShuffle);
+  CLog::Log(LOGNOTICE, "DONE initializing playlistplayer");
+
+#ifdef HAS_LCD
+  CLCDFactory factory;
+  g_lcd = factory.Create();
+  if (g_lcd)
+  {
+    g_lcd->Initialize();
+  }
+#endif
+}
+
+void CApplication::StopServices()
+{
+  m_network->NetworkMessage(CNetwork::SERVICES_DOWN, 0);
+
+#if !defined(_WIN32) && defined(HAS_DVD_DRIVE)
+  CLog::Log(LOGNOTICE, "stop dvd detect media");
+  m_DetectDVDType.StopThread();
+#endif
+
+  g_peripherals.Clear();
+}
+
+void CApplication::ReloadSkin()
+{
+  m_skinReloading = false;
+  CGUIMessage msg(GUI_MSG_LOAD_SKIN, -1, g_windowManager.GetActiveWindow());
+  g_windowManager.SendMessage(msg);
+  
+  // Reload the skin, restoring the previously focused control.  We need this as
+  // the window unload will reset all control states.
+  int iCtrlID = -1;
+  CGUIWindow* pWindow = g_windowManager.GetWindow(g_windowManager.GetActiveWindow());
+  if (pWindow)
+    iCtrlID = pWindow->GetFocusedControlID();
+  
+  g_application.LoadSkin(g_guiSettings.GetString("lookandfeel.skin"));
+ 
+  if (iCtrlID != -1)
+  {
+    pWindow = g_windowManager.GetWindow(g_windowManager.GetActiveWindow());
+    if (pWindow && pWindow->HasSaveLastControl())
+    {
+      CGUIMessage msg3(GUI_MSG_SETFOCUS, g_windowManager.GetActiveWindow(), iCtrlID, 0);
+      pWindow->OnMessage(msg3);
+    }
+  }
+}
+
+bool CApplication::LoadSkin(const CStdString& skinID)
+{
+  if (m_skinReloading)
+    return false;
+
+  AddonPtr addon;
+  if (CAddonMgr::Get().GetAddon(skinID, addon, ADDON_SKIN))
+  {
+    LoadSkin(boost::dynamic_pointer_cast<ADDON::CSkinInfo>(addon));
+    return true;
+  }
+  return false;
+}
+
+void CApplication::LoadSkin(const SkinPtr& skin)
+{
+  if (!skin)
+  {
+    CLog::Log(LOGERROR, "failed to load requested skin, fallback to \"%s\" skin", DEFAULT_SKIN);
+    g_guiSettings.SetString("lookandfeel.skin", DEFAULT_SKIN);
+    LoadSkin(DEFAULT_SKIN);
+    return ;
+  }
+
+  skin->Start();
+  if (!skin->HasSkinFile("Home.xml"))
+  {
+    // failed to find home.xml
+    // fallback to default skin
+    if (strcmpi(skin->ID().c_str(), DEFAULT_SKIN) != 0)
+    {
+      CLog::Log(LOGERROR, "home.xml doesn't exist in skin: %s, fallback to \"%s\" skin", skin->ID().c_str(), DEFAULT_SKIN);
+      g_guiSettings.SetString("lookandfeel.skin", DEFAULT_SKIN);
+      LoadSkin(DEFAULT_SKIN);
+      CGUIDialogKaiToast::QueueNotification(CGUIDialogKaiToast::Error, g_localizeStrings.Get(24102), g_localizeStrings.Get(24103));
+      return ;
+    }
+  }
+
+  bool bPreviousPlayingState=false;
+  bool bPreviousRenderingState=false;
+  if (g_application.m_pPlayer && g_application.IsPlayingVideo())
+  {
+    bPreviousPlayingState = !g_application.m_pPlayer->IsPaused();
+    if (bPreviousPlayingState)
+      g_application.m_pPlayer->Pause();
+#ifdef HAS_VIDEO_PLAYBACK
+    if (!g_renderManager.Paused())
+    {
+      if (g_windowManager.GetActiveWindow() == WINDOW_FULLSCREEN_VIDEO)
+     {
+        g_windowManager.ActivateWindow(WINDOW_HOME);
+        bPreviousRenderingState = true;
+      }
+    }
+#endif
+  }
+  // close the music and video overlays (they're re-opened automatically later)
+  CSingleLock lock(g_graphicsContext);
+
+  // save the current window details
+  int currentWindow = g_windowManager.GetActiveWindow();
+  vector<int> currentModelessWindows;
+  g_windowManager.GetActiveModelessWindows(currentModelessWindows);
+
+  UnloadSkin();
+
+  CLog::Log(LOGINFO, "  load skin from: %s (version: %s)", skin->Path().c_str(), skin->Version().c_str());
+  g_SkinInfo = skin;
+  g_SkinInfo->Start();
+
+  CLog::Log(LOGINFO, "  load fonts for skin...");
+  g_graphicsContext.SetMediaDir(skin->Path());
+  g_directoryCache.ClearSubPaths(skin->Path());
+  if (g_langInfo.ForceUnicodeFont() && !g_fontManager.IsFontSetUnicode(g_guiSettings.GetString("lookandfeel.font")))
+  {
+    CLog::Log(LOGINFO, "    language needs a ttf font, loading first ttf font available");
+    CStdString strFontSet;
+    if (g_fontManager.GetFirstFontSetUnicode(strFontSet))
+    {
+      CLog::Log(LOGINFO, "    new font is '%s'", strFontSet.c_str());
+      g_guiSettings.SetString("lookandfeel.font", strFontSet);
+      g_settings.Save();
+    }
+    else
+      CLog::Log(LOGERROR, "    no ttf font found, but needed for the language %s.", g_guiSettings.GetString("locale.language").c_str());
+  }
+  g_colorManager.Load(g_guiSettings.GetString("lookandfeel.skincolors"));
+
+  g_fontManager.LoadFonts(g_guiSettings.GetString("lookandfeel.font"));
+
+  // load in the skin strings
+  CStdString langPath;
+  URIUtils::AddFileToFolder(skin->Path(), "language", langPath);
+  URIUtils::AddSlashAtEnd(langPath);
+
+  g_localizeStrings.LoadSkinStrings(langPath, g_guiSettings.GetString("locale.language"));
+
+  g_SkinInfo->LoadIncludes();
+
+  int64_t start;
+  start = CurrentHostCounter();
+
+  CLog::Log(LOGINFO, "  load new skin...");
+
+  // Load the user windows
+  LoadUserWindows();
+
+  int64_t end, freq;
+  end = CurrentHostCounter();
+  freq = CurrentHostFrequency();
+  CLog::Log(LOGDEBUG,"Load Skin XML: %.2fms", 1000.f * (end - start) / freq);
+
+  CLog::Log(LOGINFO, "  initialize new skin...");
+  g_windowManager.AddMsgTarget(this);
+  g_windowManager.AddMsgTarget(&g_playlistPlayer);
+  g_windowManager.AddMsgTarget(&g_infoManager);
+  g_windowManager.AddMsgTarget(&g_fontManager);
+  g_windowManager.SetCallback(*this);
+  g_windowManager.Initialize();
+  CTextureCache::Get().Initialize();
+  g_audioManager.Enable(true);
+  g_audioManager.Load();
+
+  if (g_SkinInfo->HasSkinFile("DialogFullScreenInfo.xml"))
+    g_windowManager.Add(new CGUIDialogFullScreenInfo);
+
+  { // we can't register visible condition in dialog's ctor because infomanager is cleared when unloading skin
+    CGUIDialog *overlay = (CGUIDialog *)g_windowManager.GetWindow(WINDOW_DIALOG_VIDEO_OVERLAY);
+    if (overlay) overlay->SetVisibleCondition("skin.hasvideooverlay");
+    overlay = (CGUIDialog *)g_windowManager.GetWindow(WINDOW_DIALOG_MUSIC_OVERLAY);
+    if (overlay) overlay->SetVisibleCondition("skin.hasmusicoverlay");
+  }
+
+  CLog::Log(LOGINFO, "  skin loaded...");
+
+  // leave the graphics lock
+  lock.Leave();
+
+  // restore windows
+  if (currentWindow != WINDOW_INVALID)
+  {
+    g_windowManager.ActivateWindow(currentWindow);
+    for (unsigned int i = 0; i < currentModelessWindows.size(); i++)
+    {
+      CGUIDialog *dialog = (CGUIDialog *)g_windowManager.GetWindow(currentModelessWindows[i]);
+      if (dialog) dialog->Show();
+    }
+  }
+
+  if (g_application.m_pPlayer && g_application.IsPlayingVideo())
+  {
+    if (bPreviousPlayingState)
+      g_application.m_pPlayer->Pause();
+    if (bPreviousRenderingState)
+      g_windowManager.ActivateWindow(WINDOW_FULLSCREEN_VIDEO);
+  }
+}
+
+void CApplication::UnloadSkin(bool forReload /* = false */)
+{
+  m_skinReloading = forReload;
+
+  CLog::Log(LOGINFO, "Unloading old skin %s...", forReload ? "for reload " : "");
+
+  g_audioManager.Enable(false);
+
+  g_windowManager.DeInitialize();
+  CTextureCache::Get().Deinitialize();
+
+  // remove the skin-dependent window
+  g_windowManager.Delete(WINDOW_DIALOG_FULLSCREEN_INFO);
+
+  g_TextureManager.Cleanup();
+  g_largeTextureManager.CleanupUnusedImages(true);
+
+  g_fontManager.Clear();
+
+  g_colorManager.Clear();
+
+  g_charsetConverter.reset();
+
+  g_infoManager.Clear();
+
+//  The g_SkinInfo boost shared_ptr ought to be reset here
+// but there are too many places it's used without checking for NULL
+// and as a result a race condition on exit can cause a crash.
+}
+
+bool CApplication::LoadUserWindows()
+{
+  // Start from wherever home.xml is
+  std::vector<CStdString> vecSkinPath;
+  g_SkinInfo->GetSkinPaths(vecSkinPath);
+  for (unsigned int i = 0;i < vecSkinPath.size();++i)
+  {
+    CLog::Log(LOGINFO, "Loading user windows, path %s", vecSkinPath[i].c_str());
+    CFileItemList items;
+    if (CDirectory::GetDirectory(vecSkinPath[i], items, ".xml", DIR_FLAG_NO_FILE_DIRS))
+    {
+      for (int i = 0; i < items.Size(); ++i)
+      {
+        if (items[i]->m_bIsFolder)
+          continue;
+        CStdString skinFile = URIUtils::GetFileName(items[i]->GetPath());
+        if (skinFile.Left(6).CompareNoCase("custom") == 0)
+        {
+          CXBMCTinyXML xmlDoc;
+          if (!xmlDoc.LoadFile(items[i]->GetPath()))
+          {
+            CLog::Log(LOGERROR, "unable to load: %s, Line %d\n%s", items[i]->GetPath().c_str(), xmlDoc.ErrorRow(), xmlDoc.ErrorDesc());
+            continue;
+          }
+
+          // Root element should be <window>
+          TiXmlElement* pRootElement = xmlDoc.RootElement();
+          CStdString strValue = pRootElement->Value();
+          if (!strValue.Equals("window"))
+          {
+            CLog::Log(LOGERROR, "file: %s doesnt contain <window>", skinFile.c_str());
+            continue;
+          }
+
+          // Read the <type> element to get the window type to create
+          // If no type is specified, create a CGUIWindow as default
+          CGUIWindow* pWindow = NULL;
+          CStdString strType;
+          if (pRootElement->Attribute("type"))
+            strType = pRootElement->Attribute("type");
+          else
+          {
+            const TiXmlNode *pType = pRootElement->FirstChild("type");
+            if (pType && pType->FirstChild())
+              strType = pType->FirstChild()->Value();
+          }
+          int id = WINDOW_INVALID;
+          if (!pRootElement->Attribute("id", &id))
+          {
+            const TiXmlNode *pType = pRootElement->FirstChild("id");
+            if (pType && pType->FirstChild())
+              id = atol(pType->FirstChild()->Value());
+          }
+          CStdString visibleCondition;
+          CGUIControlFactory::GetConditionalVisibility(pRootElement, visibleCondition);
+
+          if (strType.Equals("dialog"))
+            pWindow = new CGUIDialog(id + WINDOW_HOME, skinFile);
+          else if (strType.Equals("submenu"))
+            pWindow = new CGUIDialogSubMenu(id + WINDOW_HOME, skinFile);
+          else if (strType.Equals("buttonmenu"))
+            pWindow = new CGUIDialogButtonMenu(id + WINDOW_HOME, skinFile);
+          else
+            pWindow = new CGUIWindow(id + WINDOW_HOME, skinFile);
+
+          // Check to make sure the pointer isn't still null
+          if (pWindow == NULL)
+          {
+            CLog::Log(LOGERROR, "Out of memory / Failed to create new object in LoadUserWindows");
+            return false;
+          }
+          if (id == WINDOW_INVALID || g_windowManager.GetWindow(WINDOW_HOME + id))
+          {
+            delete pWindow;
+            continue;
+          }
+          pWindow->SetVisibleCondition(visibleCondition);
+          pWindow->SetLoadType(CGUIWindow::KEEP_IN_MEMORY);
+          g_windowManager.AddCustomWindow(pWindow);
+        }
+      }
+    }
+  }
+  return true;
+}
+
+bool CApplication::RenderNoPresent()
+{
+  MEASURE_FUNCTION;
+
+// DXMERGE: This may have been important?
+//  g_graphicsContext.AcquireCurrentContext();
+
+  g_graphicsContext.Lock();
+
+  // dont show GUI when playing full screen video
+  if (g_graphicsContext.IsFullScreenVideo())
+  {
+    if (m_bPresentFrame && IsPlaying() && !IsPaused())
+    {
+      ResetScreenSaver();
+      g_renderManager.Present();
+    }
+    else
+      g_renderManager.RenderUpdate(true);
+
+    // close window overlays
+    CGUIDialog *overlay = (CGUIDialog *)g_windowManager.GetWindow(WINDOW_DIALOG_VIDEO_OVERLAY);
+    if (overlay) overlay->Close(true);
+    overlay = (CGUIDialog *)g_windowManager.GetWindow(WINDOW_DIALOG_MUSIC_OVERLAY);
+    if (overlay) overlay->Close(true);
+
+  }
+
+  bool hasRendered = g_windowManager.Render();
+
+  g_graphicsContext.Unlock();
+
+  return hasRendered;
+}
+
+float CApplication::GetDimScreenSaverLevel() const
+{
+  if (!m_bScreenSave || !m_screenSaver ||
+      (m_screenSaver->ID() != "screensaver.xbmc.builtin.dim" &&
+       m_screenSaver->ID() != "screensaver.xbmc.builtin.black" &&
+       !m_screenSaver->ID().empty()))
+    return 0;
+
+  if (!m_screenSaver->GetSetting("level").IsEmpty())
+    return 100.0f - (float)atof(m_screenSaver->GetSetting("level"));
+  return 100.0f;
+}
+
+bool CApplication::WaitFrame(unsigned int timeout)
+{
+  bool done = false;
+
+  // Wait for all other frames to be presented
+  CSingleLock lock(m_frameMutex);
+  //wait until event is set, but modify remaining time
+
+  TightConditionVariable<InversePredicate<int&> > cv(m_frameCond, InversePredicate<int&>(m_frameCount));
+  cv.wait(lock,timeout);
+  done = m_frameCount == 0;
+
+  return done;
+}
+
+void CApplication::NewFrame()
+{
+  // We just posted another frame. Keep track and notify.
+  {
+    CSingleLock lock(m_frameMutex);
+    m_frameCount++;
+  }
+
+  m_frameCond.notifyAll();
+}
+
+void CApplication::Render()
+{
+  // do not render if we are stopped
+  if (m_bStop)
+    return;
+
+  if (!m_AppActive && !m_bStop && (!IsPlayingVideo() || IsPaused()))
+  {
+    Sleep(1);
+    ResetScreenSaver();
+    return;
+  }
+
+  MEASURE_FUNCTION;
+
+  int vsync_mode = g_guiSettings.GetInt("videoscreen.vsync");
+
+  bool decrement = false;
+  bool hasRendered = false;
+  bool limitFrames = false;
+  unsigned int singleFrameTime = 10; // default limit 100 fps
+
+  {
+    // Less fps in DPMS
+    bool lowfps = m_dpmsIsActive || g_Windowing.EnableFrameLimiter();
+    // Whether externalplayer is playing and we're unfocused
+    bool extPlayerActive = m_eCurrentPlayer == EPC_EXTPLAYER && IsPlaying() && !m_AppFocused;
+
+    m_bPresentFrame = false;
+    if (!extPlayerActive && g_graphicsContext.IsFullScreenVideo() && !IsPaused())
+    {
+      CSingleLock lock(m_frameMutex);
+
+      TightConditionVariable<int&> cv(m_frameCond,m_frameCount);
+      cv.wait(lock,100);
+
+      m_bPresentFrame = m_frameCount > 0;
+      decrement = m_bPresentFrame;
+      hasRendered = true;
+    }
+    else
+    {
+      // engage the frame limiter as needed
+      limitFrames = lowfps || extPlayerActive;
+      // DXMERGE - we checked for g_videoConfig.GetVSyncMode() before this
+      //           perhaps allowing it to be set differently than the UI option??
+      if (vsync_mode == VSYNC_DISABLED || vsync_mode == VSYNC_VIDEO)
+        limitFrames = true; // not using vsync.
+      else if ((g_infoManager.GetFPS() > g_graphicsContext.GetFPS() + 10) && g_infoManager.GetFPS() > 1000 / singleFrameTime)
+        limitFrames = true; // using vsync, but it isn't working.
+
+      if (limitFrames)
+      {
+        if (extPlayerActive)
+        {
+          ResetScreenSaver();  // Prevent screensaver dimming the screen
+          singleFrameTime = 1000;  // 1 fps, high wakeup latency but v.low CPU usage
+        }
+        else if (lowfps)
+          singleFrameTime = 200;  // 5 fps, <=200 ms latency to wake up
+      }
+
+      decrement = true;
+    }
+  }
+
+  CSingleLock lock(g_graphicsContext);
+  g_infoManager.UpdateFPS();
+
+  if (g_graphicsContext.IsFullScreenVideo() && IsPlaying() && vsync_mode == VSYNC_VIDEO)
+    g_Windowing.SetVSync(true);
+  else if (vsync_mode == VSYNC_ALWAYS)
+    g_Windowing.SetVSync(true);
+  else if (vsync_mode != VSYNC_DRIVER)
+    g_Windowing.SetVSync(false);
+
+  if(!g_Windowing.BeginRender())
+    return;
+
+  CDirtyRegionList dirtyRegions = g_windowManager.GetDirty();
+  if (RenderNoPresent())
+    hasRendered = true;
+
+  g_Windowing.EndRender();
+
+  // reset our info cache - we do this at the end of Render so that it is
+  // fresh for the next process(), or after a windowclose animation (where process()
+  // isn't called)
+  g_infoManager.ResetCache();
+  lock.Leave();
+
+  unsigned int now = XbmcThreads::SystemClockMillis();
+  if (hasRendered)
+    m_lastRenderTime = now;
+
+  //when nothing has been rendered for m_guiDirtyRegionNoFlipTimeout milliseconds,
+  //we don't call g_graphicsContext.Flip() anymore, this saves gpu and cpu usage
+  bool flip;
+  if (g_advancedSettings.m_guiDirtyRegionNoFlipTimeout >= 0)
+    flip = hasRendered || (now - m_lastRenderTime) < (unsigned int)g_advancedSettings.m_guiDirtyRegionNoFlipTimeout;
+  else
+    flip = true;
+
+  //fps limiter, make sure each frame lasts at least singleFrameTime milliseconds
+  if (limitFrames || !flip)
+  {
+    if (!limitFrames)
+      singleFrameTime = 40; //if not flipping, loop at 25 fps
+
+    unsigned int frameTime = now - m_lastFrameTime;
+    if (frameTime < singleFrameTime)
+      Sleep(singleFrameTime - frameTime);
+  }
+  m_lastFrameTime = XbmcThreads::SystemClockMillis();
+
+  if (flip)
+    g_graphicsContext.Flip(dirtyRegions);
+  CTimeUtils::UpdateFrameTime(flip);
+
+  g_renderManager.UpdateResolution();
+  g_renderManager.ManageCaptures();
+
+  {
+    CSingleLock lock(m_frameMutex);
+    if(m_frameCount > 0 && decrement)
+      m_frameCount--;
+  }
+  m_frameCond.notifyAll();
+}
+
+void CApplication::SetStandAlone(bool value)
+{
+  g_advancedSettings.m_handleMounting = m_bStandalone = value;
+}
+
+// OnKey() translates the key into a CAction which is sent on to our Window Manager.
+// The window manager will return true if the event is processed, false otherwise.
+// If not already processed, this routine handles global keypresses.  It returns
+// true if the key has been processed, false otherwise.
+
+bool CApplication::OnKey(const CKey& key)
+{
+
+  // Turn the mouse off, as we've just got a keypress from controller or remote
+  g_Mouse.SetActive(false);
+
+  // get the current active window
+  int iWin = g_windowManager.GetActiveWindow() & WINDOW_ID_MASK;
+
+  // this will be checked for certain keycodes that need
+  // special handling if the screensaver is active
+  CAction action = CButtonTranslator::GetInstance().GetAction(iWin, key);
+
+  // a key has been pressed.
+  // reset Idle Timer
+  m_idleTimer.StartZero();
+  bool processKey = AlwaysProcess(action);
+
+  ResetScreenSaver();
+
+  // allow some keys to be processed while the screensaver is active
+  if (WakeUpScreenSaverAndDPMS(processKey) && !processKey)
+  {
+    CLog::Log(LOGDEBUG, "%s: %s pressed, screen saver/dpms woken up", __FUNCTION__, g_Keyboard.GetKeyName((int) key.GetButtonCode()).c_str());
+    return true;
+  }
+
+  // change this if we have a dialog up
+  if (g_windowManager.HasModalDialog())
+  {
+    iWin = g_windowManager.GetTopMostModalDialogID() & WINDOW_ID_MASK;
+  }
+  if (iWin == WINDOW_DIALOG_FULLSCREEN_INFO)
+  { // fullscreen info dialog - special case
+    action = CButtonTranslator::GetInstance().GetAction(iWin, key);
+
+    if (!key.IsAnalogButton())
+      CLog::Log(LOGDEBUG, "%s: %s pressed, trying fullscreen info action %s", __FUNCTION__, g_Keyboard.GetKeyName((int) key.GetButtonCode()).c_str(), action.GetName().c_str());
+
+    if (OnAction(action))
+      return true;
+
+    // fallthrough to the main window
+    iWin = WINDOW_FULLSCREEN_VIDEO;
+  }
+  if (iWin == WINDOW_FULLSCREEN_VIDEO)
+  {
+    // current active window is full screen video.
+    if (g_application.m_pPlayer && g_application.m_pPlayer->IsInMenu())
+    {
+      // if player is in some sort of menu, (ie DVDMENU) map buttons differently
+      action = CButtonTranslator::GetInstance().GetAction(WINDOW_VIDEO_MENU, key);
+    }
+    else if (g_PVRManager.IsStarted() && g_application.CurrentFileItem().HasPVRChannelInfoTag())
+    {
+      // check for PVR specific keymaps in FULLSCREEN_VIDEO window
+      action = CButtonTranslator::GetInstance().GetAction(WINDOW_FULLSCREEN_LIVETV, key, false);
+
+      // if no PVR specific action/mapping is found, fall back to default
+      if (action.GetID() == 0)
+        action = CButtonTranslator::GetInstance().GetAction(iWin, key);
+    }
+    else
+    {
+      // in any other case use the fullscreen window section of keymap.xml to map key->action
+      action = CButtonTranslator::GetInstance().GetAction(iWin, key);
+    }
+  }
+  else
+  {
+    // current active window isnt the fullscreen window
+    // just use corresponding section from keymap.xml
+    // to map key->action
+
+    // first determine if we should use keyboard input directly
+    bool useKeyboard = key.FromKeyboard() && (iWin == WINDOW_DIALOG_KEYBOARD || iWin == WINDOW_DIALOG_NUMERIC);
+    CGUIWindow *window = g_windowManager.GetWindow(iWin);
+    if (window)
+    {
+      CGUIControl *control = window->GetFocusedControl();
+      if (control)
+      {
+        // If this is an edit control set usekeyboard to true. This causes the
+        // keypress to be processed directly not through the key mappings.
+        if (control->GetControlType() == CGUIControl::GUICONTROL_EDIT)
+          useKeyboard = true;
+
+        // If the key pressed is shift-A to shift-Z set usekeyboard to true.
+        // This causes the keypress to be used for list navigation.
+        if (control->IsContainer() && key.GetModifiers() == CKey::MODIFIER_SHIFT && key.GetVKey() >= XBMCVK_A && key.GetVKey() <= XBMCVK_Z)
+          useKeyboard = true;
+      }
+    }
+    if (useKeyboard)
+    {
+      action = CAction(0); // reset our action
+      if (g_guiSettings.GetBool("input.remoteaskeyboard"))
+      {
+        // users remote is executing keyboard commands, so use the virtualkeyboard section of keymap.xml
+        // and send those rather than actual keyboard presses.  Only for navigation-type commands though
+        action = CButtonTranslator::GetInstance().GetAction(WINDOW_DIALOG_KEYBOARD, key);
+        if (!(action.GetID() == ACTION_MOVE_LEFT ||
+              action.GetID() == ACTION_MOVE_RIGHT ||
+              action.GetID() == ACTION_MOVE_UP ||
+              action.GetID() == ACTION_MOVE_DOWN ||
+              action.GetID() == ACTION_SELECT_ITEM ||
+              action.GetID() == ACTION_ENTER ||
+              action.GetID() == ACTION_PREVIOUS_MENU ||
+              action.GetID() == ACTION_NAV_BACK))
+        {
+          // the action isn't plain navigation - check for a keyboard-specific keymap
+          action = CButtonTranslator::GetInstance().GetAction(WINDOW_DIALOG_KEYBOARD, key, false);
+          if (!(action.GetID() >= REMOTE_0 && action.GetID() <= REMOTE_9) ||
+                action.GetID() == ACTION_BACKSPACE ||
+                action.GetID() == ACTION_SHIFT ||
+                action.GetID() == ACTION_SYMBOLS ||
+                action.GetID() == ACTION_CURSOR_LEFT ||
+                action.GetID() == ACTION_CURSOR_RIGHT)
+            action = CAction(0); // don't bother with this action
+        }
+      }
+      if (!action.GetID())
+      {
+        // keyboard entry - pass the keys through directly
+        if (key.GetFromService())
+          action = CAction(key.GetButtonCode() != KEY_INVALID ? key.GetButtonCode() : 0, key.GetUnicode());
+        else
+        { // see if we've got an ascii key
+          if (key.GetUnicode())
+            action = CAction(key.GetAscii() | KEY_ASCII, key.GetUnicode());
+          else
+            action = CAction(key.GetVKey() | KEY_VKEY);
+        }
+      }
+
+      CLog::Log(LOGDEBUG, "%s: %s pressed, trying keyboard action %i", __FUNCTION__, g_Keyboard.GetKeyName((int) key.GetButtonCode()).c_str(), action.GetID());
+
+      if (OnAction(action))
+        return true;
+      // failed to handle the keyboard action, drop down through to standard action
+    }
+    if (key.GetFromService())
+    {
+      if (key.GetButtonCode() != KEY_INVALID)
+        action = CButtonTranslator::GetInstance().GetAction(iWin, key);
+    }
+    else
+      action = CButtonTranslator::GetInstance().GetAction(iWin, key);
+  }
+  if (!key.IsAnalogButton())
+    CLog::Log(LOGDEBUG, "%s: %s pressed, action is %s", __FUNCTION__, g_Keyboard.GetKeyName((int) key.GetButtonCode()).c_str(), action.GetName().c_str());
+
+  return ExecuteInputAction(action);
+}
+
+// OnAppCommand is called in response to a XBMC_APPCOMMAND event.
+// This needs to return true if it processed the appcommand or false if it didn't
+bool CApplication::OnAppCommand(const CAction &action)
+{
+  // Reset the screen saver
+  ResetScreenSaver();
+
+  // If we were currently in the screen saver wake up and don't process the appcommand
+  if (WakeUpScreenSaverAndDPMS())
+    return true;
+
+  // The action ID is the APPCOMMAND code. We need to retrieve the action
+  // associated with this appcommand from the mapping table.
+  uint32_t appcmd = action.GetID();
+  CKey key(appcmd | KEY_APPCOMMAND, (unsigned int) 0);
+  int iWin = g_windowManager.GetActiveWindow() & WINDOW_ID_MASK;
+  CAction appcmdaction = CButtonTranslator::GetInstance().GetAction(iWin, key);
+
+  // If we couldn't find an action return false to indicate we have not
+  // handled this appcommand
+  if (!appcmdaction.GetID())
+  {
+    CLog::Log(LOGDEBUG, "%s: unknown appcommand %d", __FUNCTION__, appcmd);
+    return false;
+  }
+
+  // Process the appcommand
+  CLog::Log(LOGDEBUG, "%s: appcommand %d, trying action %s", __FUNCTION__, appcmd, appcmdaction.GetName().c_str());
+  OnAction(appcmdaction);
+
+  // Always return true regardless of whether the action succeeded or not.
+  // This stops Windows handling the appcommand itself.
+  return true;
+}
+
+bool CApplication::OnAction(const CAction &action)
+{
+  // special case for switching between GUI & fullscreen mode.
+  if (action.GetID() == ACTION_SHOW_GUI)
+  { // Switch to fullscreen mode if we can
+    if (SwitchToFullScreen())
+    {
+      m_navigationTimer.StartZero();
+      return true;
+    }
+  }
+
+  if (action.GetID() == ACTION_TOGGLE_FULLSCREEN)
+  {
+    g_graphicsContext.ToggleFullScreenRoot();
+    return true;
+  }
+
+  if (action.IsMouse())
+    g_Mouse.SetActive(true);
+
+  // The action PLAYPAUSE behaves as ACTION_PAUSE if we are currently
+  // playing or ACTION_PLAYER_PLAY if we are not playing.
+  if (action.GetID() == ACTION_PLAYER_PLAYPAUSE)
+  {
+    if (IsPlaying())
+      return OnAction(CAction(ACTION_PAUSE));
+    else
+      return OnAction(CAction(ACTION_PLAYER_PLAY));
+  }
+
+  //if the action would start or stop inertial scrolling
+  //by gesture - bypass the normal OnAction handler of current window
+  if( !m_pInertialScrollingHandler->CheckForInertialScrolling(&action) )
+  {
+    // in normal case
+    // just pass the action to the current window and let it handle it
+    if (g_windowManager.OnAction(action))
+    {
+      m_navigationTimer.StartZero();
+      return true;
+    }
+  }
+
+  // handle extra global presses
+
+  // screenshot : take a screenshot :)
+  if (action.GetID() == ACTION_TAKE_SCREENSHOT)
+  {
+    CScreenShot::TakeScreenshot();
+    return true;
+  }
+  // built in functions : execute the built-in
+  if (action.GetID() == ACTION_BUILT_IN_FUNCTION)
+  {
+    CBuiltins::Execute(action.GetName());
+    m_navigationTimer.StartZero();
+    return true;
+  }
+
+  // reload keymaps
+  if (action.GetID() == ACTION_RELOAD_KEYMAPS)
+  {
+    CButtonTranslator::GetInstance().Clear();
+    CButtonTranslator::GetInstance().Load();
+  }
+
+  // show info : Shows the current video or song information
+  if (action.GetID() == ACTION_SHOW_INFO)
+  {
+    g_infoManager.ToggleShowInfo();
+    return true;
+  }
+
+  // codec info : Shows the current song, video or picture codec information
+  if (action.GetID() == ACTION_SHOW_CODEC)
+  {
+    g_infoManager.ToggleShowCodec();
+    return true;
+  }
+
+  if ((action.GetID() == ACTION_INCREASE_RATING || action.GetID() == ACTION_DECREASE_RATING) && IsPlayingAudio())
+  {
+    const CMusicInfoTag *tag = g_infoManager.GetCurrentSongTag();
+    if (tag)
+    {
+      *m_itemCurrentFile->GetMusicInfoTag() = *tag;
+      char rating = tag->GetRating();
+      bool needsUpdate(false);
+      if (rating > '0' && action.GetID() == ACTION_DECREASE_RATING)
+      {
+        m_itemCurrentFile->GetMusicInfoTag()->SetRating(rating - 1);
+        needsUpdate = true;
+      }
+      else if (rating < '5' && action.GetID() == ACTION_INCREASE_RATING)
+      {
+        m_itemCurrentFile->GetMusicInfoTag()->SetRating(rating + 1);
+        needsUpdate = true;
+      }
+      if (needsUpdate)
+      {
+        CMusicDatabase db;
+        if (db.Open())      // OpenForWrite() ?
+        {
+          db.SetSongRating(m_itemCurrentFile->GetPath(), m_itemCurrentFile->GetMusicInfoTag()->GetRating());
+          db.Close();
+        }
+        // send a message to all windows to tell them to update the fileitem (eg playlistplayer, media windows)
+        CGUIMessage msg(GUI_MSG_NOTIFY_ALL, 0, 0, GUI_MSG_UPDATE_ITEM, 0, m_itemCurrentFile);
+        g_windowManager.SendMessage(msg);
+      }
+    }
+    return true;
+  }
+
+  // stop : stops playing current audio song
+  if (action.GetID() == ACTION_STOP)
+  {
+    StopPlaying();
+    return true;
+  }
+
+  // previous : play previous song from playlist
+  if (action.GetID() == ACTION_PREV_ITEM)
+  {
+    // first check whether we're within 3 seconds of the start of the track
+    // if not, we just revert to the start of the track
+    if (m_pPlayer && m_pPlayer->CanSeek() && GetTime() > 3)
+    {
+      SeekTime(0);
+      SetPlaySpeed(1);
+    }
+    else
+    {
+      g_playlistPlayer.PlayPrevious();
+    }
+    return true;
+  }
+
+  // next : play next song from playlist
+  if (action.GetID() == ACTION_NEXT_ITEM)
+  {
+    if (IsPlaying() && m_pPlayer->SkipNext())
+      return true;
+
+    if (IsPaused())
+      m_pPlayer->Pause();
+
+    g_playlistPlayer.PlayNext();
+
+    return true;
+  }
+
+  if (IsPlaying())
+  {
+    // forward channel switches to the player - he knows what to do
+    if (action.GetID() == ACTION_CHANNEL_UP || action.GetID() == ACTION_CHANNEL_DOWN)
+    {
+      m_pPlayer->OnAction(action);
+      return true;
+    }
+
+    // pause : pauses current audio song
+    if (action.GetID() == ACTION_PAUSE && m_iPlaySpeed == 1)
+    {
+      m_pPlayer->Pause();
+#ifdef HAS_KARAOKE
+      m_pKaraokeMgr->SetPaused( m_pPlayer->IsPaused() );
+#endif
+      if (!m_pPlayer->IsPaused())
+      { // unpaused - set the playspeed back to normal
+        SetPlaySpeed(1);
+      }
+      g_audioManager.Enable(m_pPlayer->IsPaused());
+      return true;
+    }
+    if (!m_pPlayer->IsPaused())
+    {
+      // if we do a FF/RW in my music then map PLAY action togo back to normal speed
+      // if we are playing at normal speed, then allow play to pause
+      if (action.GetID() == ACTION_PLAYER_PLAY || action.GetID() == ACTION_PAUSE)
+      {
+        if (m_iPlaySpeed != 1)
+        {
+          SetPlaySpeed(1);
+        }
+        else
+        {
+          m_pPlayer->Pause();
+        }
+        return true;
+      }
+      if (action.GetID() == ACTION_PLAYER_FORWARD || action.GetID() == ACTION_PLAYER_REWIND)
+      {
+        int iPlaySpeed = m_iPlaySpeed;
+        if (action.GetID() == ACTION_PLAYER_REWIND && iPlaySpeed == 1) // Enables Rewinding
+          iPlaySpeed *= -2;
+        else if (action.GetID() == ACTION_PLAYER_REWIND && iPlaySpeed > 1) //goes down a notch if you're FFing
+          iPlaySpeed /= 2;
+        else if (action.GetID() == ACTION_PLAYER_FORWARD && iPlaySpeed < 1) //goes up a notch if you're RWing
+          iPlaySpeed /= 2;
+        else
+          iPlaySpeed *= 2;
+
+        if (action.GetID() == ACTION_PLAYER_FORWARD && iPlaySpeed == -1) //sets iSpeed back to 1 if -1 (didn't plan for a -1)
+          iPlaySpeed = 1;
+        if (iPlaySpeed > 32 || iPlaySpeed < -32)
+          iPlaySpeed = 1;
+
+        SetPlaySpeed(iPlaySpeed);
+        return true;
+      }
+      else if ((action.GetAmount() || GetPlaySpeed() != 1) && (action.GetID() == ACTION_ANALOG_REWIND || action.GetID() == ACTION_ANALOG_FORWARD))
+      {
+        // calculate the speed based on the amount the button is held down
+        int iPower = (int)(action.GetAmount() * MAX_FFWD_SPEED + 0.5f);
+        // returns 0 -> MAX_FFWD_SPEED
+        int iSpeed = 1 << iPower;
+        if (iSpeed != 1 && action.GetID() == ACTION_ANALOG_REWIND)
+          iSpeed = -iSpeed;
+        g_application.SetPlaySpeed(iSpeed);
+        if (iSpeed == 1)
+          CLog::Log(LOGDEBUG,"Resetting playspeed");
+        return true;
+      }
+    }
+    // allow play to unpause
+    else
+    {
+      if (action.GetID() == ACTION_PLAYER_PLAY)
+      {
+        // unpause, and set the playspeed back to normal
+        m_pPlayer->Pause();
+        g_audioManager.Enable(m_pPlayer->IsPaused());
+
+        g_application.SetPlaySpeed(1);
+        return true;
+      }
+    }
+  }
+
+  if (g_peripherals.OnAction(action))
+    return true;
+
+  if (action.GetID() == ACTION_MUTE)
+  {
+    ToggleMute();
+    return true;
+  }
+
+  if (action.GetID() == ACTION_TOGGLE_DIGITAL_ANALOG)
+  {
+    // we are only allowed to SetInt to a value supported in GUISettings, so we keep trying until it sticks
+    int mode = g_guiSettings.GetInt("audiooutput.mode");
+    for (int i = 0; i < AUDIO_COUNT; i++)
+    {
+      if (++mode == AUDIO_COUNT)
+        mode = 0;
+      g_guiSettings.SetInt("audiooutput.mode", mode);
+      if (g_guiSettings.GetInt("audiooutput.mode") == mode)
+         break;
+    }
+
+    g_application.Restart();
+    if (g_windowManager.GetActiveWindow() == WINDOW_SETTINGS_SYSTEM)
+    {
+      CGUIMessage msg(GUI_MSG_WINDOW_INIT, 0,0,WINDOW_INVALID,g_windowManager.GetActiveWindow());
+      g_windowManager.SendMessage(msg);
+    }
+    return true;
+  }
+
+  // Check for global volume control
+  if (action.GetAmount() && (action.GetID() == ACTION_VOLUME_UP || action.GetID() == ACTION_VOLUME_DOWN))
+  {
+    if (!m_pPlayer || !m_pPlayer->IsPassthrough())
+    {
+      if (g_settings.m_bMute)
+        UnMute();
+      float volume = g_settings.m_fVolumeLevel;
+// Android has steps based on the max available volume level
+#if defined(TARGET_ANDROID)
+      float step = (VOLUME_MAXIMUM - VOLUME_MINIMUM) / CXBMCApp::GetMaxSystemVolume();
+#else
+      float step   = (VOLUME_MAXIMUM - VOLUME_MINIMUM) / VOLUME_CONTROL_STEPS;
+
+      if (action.GetRepeat())
+        step *= action.GetRepeat() * 50; // 50 fps
+#endif
+      if (action.GetID() == ACTION_VOLUME_UP)
+        volume += (float)fabs(action.GetAmount()) * action.GetAmount() * step;
+      else
+        volume -= (float)fabs(action.GetAmount()) * action.GetAmount() * step;
+      SetVolume(volume, false);
+    }
+    // show visual feedback of volume change...
+    ShowVolumeBar(&action);
+    return true;
+  }
+  // Check for global seek control
+  if (IsPlaying() && action.GetAmount() && (action.GetID() == ACTION_ANALOG_SEEK_FORWARD || action.GetID() == ACTION_ANALOG_SEEK_BACK))
+  {
+    if (!m_pPlayer->CanSeek()) return false;
+    m_seekHandler->Seek(action.GetID() == ACTION_ANALOG_SEEK_FORWARD, action.GetAmount(), action.GetRepeat());
+    return true;
+  }
+  if (action.GetID() == ACTION_GUIPROFILE_BEGIN)
+  {
+    CGUIControlProfiler::Instance().SetOutputFile(CSpecialProtocol::TranslatePath("special://home/guiprofiler.xml"));
+    CGUIControlProfiler::Instance().Start();
+    return true;
+  }
+  if (action.GetID() == ACTION_SHOW_PLAYLIST)
+  {
+    int iPlaylist = g_playlistPlayer.GetCurrentPlaylist();
+    if (iPlaylist == PLAYLIST_VIDEO && g_windowManager.GetActiveWindow() != WINDOW_VIDEO_PLAYLIST)
+      g_windowManager.ActivateWindow(WINDOW_VIDEO_PLAYLIST);
+    else if (iPlaylist == PLAYLIST_MUSIC && g_windowManager.GetActiveWindow() != WINDOW_MUSIC_PLAYLIST)
+      g_windowManager.ActivateWindow(WINDOW_MUSIC_PLAYLIST);
+    return true;
+  }
+  return false;
+}
+
+void CApplication::UpdateLCD()
+{
+#ifdef HAS_LCD
+  static unsigned int lTickCount = 0;
+
+  if (!g_lcd || !g_guiSettings.GetBool("videoscreen.haslcd"))
+    return ;
+  unsigned int lTimeOut = 1000;
+  if ( m_iPlaySpeed != 1)
+    lTimeOut = 0;
+  if ( (XbmcThreads::SystemClockMillis() - lTickCount) >= lTimeOut)
+  {
+    if (g_application.NavigationIdleTime() < 5)
+      g_lcd->Render(ILCD::LCD_MODE_NAVIGATION);
+    else if (g_PVRManager.IsPlayingTV())
+      g_lcd->Render(ILCD::LCD_MODE_PVRTV);
+    else if (g_PVRManager.IsPlayingRadio())
+      g_lcd->Render(ILCD::LCD_MODE_PVRRADIO);
+    else if (IsPlayingVideo())
+      g_lcd->Render(ILCD::LCD_MODE_VIDEO);
+    else if (IsPlayingAudio())
+      g_lcd->Render(ILCD::LCD_MODE_MUSIC);
+    else if (IsInScreenSaver())
+      g_lcd->Render(ILCD::LCD_MODE_SCREENSAVER);
+    else
+      g_lcd->Render(ILCD::LCD_MODE_GENERAL);
+
+    // reset tick count
+    lTickCount = XbmcThreads::SystemClockMillis();
+  }
+#endif
+}
+
+void CApplication::FrameMove(bool processEvents, bool processGUI)
+{
+  MEASURE_FUNCTION;
+
+  if (processEvents)
+  {
+    // currently we calculate the repeat time (ie time from last similar keypress) just global as fps
+    float frameTime = m_frameTime.GetElapsedSeconds();
+    m_frameTime.StartZero();
+    // never set a frametime less than 2 fps to avoid problems when debuggin and on breaks
+    if( frameTime > 0.5 ) frameTime = 0.5;
+
+    if (processGUI && m_renderGUI)
+    {
+      g_graphicsContext.Lock();
+      // check if there are notifications to display
+      CGUIDialogKaiToast *toast = (CGUIDialogKaiToast *)g_windowManager.GetWindow(WINDOW_DIALOG_KAI_TOAST);
+      if (toast && toast->DoWork())
+      {
+        if (!toast->IsDialogRunning())
+        {
+          toast->Show();
+        }
+      }
+      g_graphicsContext.Unlock();
+      CWinEvents::MessagePump();
+    }
+
+    UpdateLCD();
+
+#if defined(HAS_LIRC) || defined(HAS_IRSERVERSUITE)
+    // Read the input from a remote
+    g_RemoteControl.Update();
+#endif
+
+    // process input actions
+    ProcessRemote(frameTime);
+    ProcessGamepad(frameTime);
+    ProcessEventServer(frameTime);
+    ProcessPeripherals(frameTime);
+    if (processGUI && m_renderGUI)
+    {
+      m_pInertialScrollingHandler->ProcessInertialScroll(frameTime);
+      m_seekHandler->Process();
+    }
+  }
+  if (processGUI && m_renderGUI)
+  {
+    if (!m_bStop)
+      g_windowManager.Process(CTimeUtils::GetFrameTime());
+    g_windowManager.FrameMove();
+  }
+}
+
+bool CApplication::ProcessGamepad(float frameTime)
+{
+#ifdef HAS_SDL_JOYSTICK
+  if (!m_AppFocused)
+    return false;
+
+  int iWin = GetActiveWindowID();
+  int bid = 0;
+  g_Joystick.Update();
+  if (g_Joystick.GetButton(bid))
+  {
+    // reset Idle Timer
+    m_idleTimer.StartZero();
+
+    ResetScreenSaver();
+    if (WakeUpScreenSaverAndDPMS())
+    {
+      g_Joystick.Reset(true);
+      return true;
+    }
+
+    int actionID;
+    CStdString actionName;
+    bool fullrange;
+    if (CButtonTranslator::GetInstance().TranslateJoystickString(iWin, g_Joystick.GetJoystick().c_str(), bid, JACTIVE_BUTTON, actionID, actionName, fullrange))
+    {
+      CAction action(actionID, 1.0f, 0.0f, actionName);
+      g_Joystick.Reset();
+      g_Mouse.SetActive(false);
+      return ExecuteInputAction(action);
+    }
+    else
+    {
+      g_Joystick.Reset();
+    }
+  }
+  if (g_Joystick.GetAxis(bid))
+  {
+    if (g_Joystick.GetAmount() < 0)
+    {
+      bid = -bid;
+    }
+
+    int actionID;
+    CStdString actionName;
+    bool fullrange;
+    if (CButtonTranslator::GetInstance().TranslateJoystickString(iWin, g_Joystick.GetJoystick().c_str(), bid, JACTIVE_AXIS, actionID, actionName, fullrange))
+    {
+      ResetScreenSaver();
+      if (WakeUpScreenSaverAndDPMS())
+      {
+        return true;
+      }
+
+      CAction action(actionID, fullrange ? (g_Joystick.GetAmount() + 1.0f)/2.0f : fabs(g_Joystick.GetAmount()), 0.0f, actionName);
+      g_Joystick.Reset();
+      g_Mouse.SetActive(false);
+      return ExecuteInputAction(action);
+    }
+    else
+    {
+      g_Joystick.ResetAxis(abs(bid));
+    }
+  }
+  int position = 0;
+  if (g_Joystick.GetHat(bid, position))
+  {
+    // reset Idle Timer
+    m_idleTimer.StartZero();
+
+    ResetScreenSaver();
+    if (WakeUpScreenSaverAndDPMS())
+    {
+      g_Joystick.Reset();
+      return true;
+    }
+
+    int actionID;
+    CStdString actionName;
+    bool fullrange;
+
+    bid = position<<16|bid;
+
+    if (bid && CButtonTranslator::GetInstance().TranslateJoystickString(iWin, g_Joystick.GetJoystick().c_str(), bid, JACTIVE_HAT, actionID, actionName, fullrange))
+    {
+      CAction action(actionID, 1.0f, 0.0f, actionName);
+      g_Joystick.Reset();
+      g_Mouse.SetActive(false);
+      return ExecuteInputAction(action);
+    }
+  }
+#endif
+  return false;
+}
+
+bool CApplication::ProcessRemote(float frameTime)
+{
+#if defined(HAS_LIRC) || defined(HAS_IRSERVERSUITE)
+  if (g_RemoteControl.GetButton())
+  {
+    CKey key(g_RemoteControl.GetButton(), g_RemoteControl.GetHoldTime());
+    g_RemoteControl.Reset();
+    return OnKey(key);
+  }
+#endif
+  return false;
+}
+
+bool CApplication::ProcessPeripherals(float frameTime)
+{
+  CKey key;
+  if (g_peripherals.GetNextKeypress(frameTime, key))
+    return OnKey(key);
+  return false;
+}
+
+bool CApplication::ProcessMouse()
+{
+  MEASURE_FUNCTION;
+
+  if (!g_Mouse.IsActive() || !m_AppFocused)
+    return false;
+
+  // Get the mouse command ID
+  uint32_t mousecommand = g_Mouse.GetAction();
+  if (mousecommand == ACTION_NOOP)
+    return true;
+
+  // Reset the screensaver and idle timers
+  m_idleTimer.StartZero();
+  ResetScreenSaver();
+  if (WakeUpScreenSaverAndDPMS())
+    return true;
+
+  // Retrieve the corresponding action
+  int iWin = GetActiveWindowID();
+  CKey key(mousecommand | KEY_MOUSE, (unsigned int) 0);
+  CAction mouseaction = CButtonTranslator::GetInstance().GetAction(iWin, key);
+
+  // If we couldn't find an action return false to indicate we have not
+  // handled this mouse action
+  if (!mouseaction.GetID())
+  {
+    CLog::Log(LOGDEBUG, "%s: unknown mouse command %d", __FUNCTION__, mousecommand);
+    return false;
+  }
+
+  // Log mouse actions except for move and noop
+  if (mouseaction.GetID() != ACTION_MOUSE_MOVE && mouseaction.GetID() != ACTION_NOOP)
+    CLog::Log(LOGDEBUG, "%s: trying mouse action %s", __FUNCTION__, mouseaction.GetName().c_str());
+
+  // The action might not be a mouse action. For example wheel moves might
+  // be mapped to volume up/down in mouse.xml. In this case we do not want
+  // the mouse position saved in the action.
+  if (!mouseaction.IsMouse())
+    return OnAction(mouseaction);
+
+  // This is a mouse action so we need to record the mouse position
+  return OnAction(CAction(mouseaction.GetID(),
+                          g_Mouse.GetHold(MOUSE_LEFT_BUTTON),
+                          (float)g_Mouse.GetX(),
+                          (float)g_Mouse.GetY(),
+                          (float)g_Mouse.GetDX(),
+                          (float)g_Mouse.GetDY(),
+                          mouseaction.GetName()));
+}
+
+bool CApplication::ProcessEventServer(float frameTime)
+{
+#ifdef HAS_EVENT_SERVER
+  CEventServer* es = CEventServer::GetInstance();
+  if (!es || !es->Running() || es->GetNumberOfClients()==0)
+    return false;
+
+  // process any queued up actions
+  if (es->ExecuteNextAction())
+  {
+    // reset idle timers
+    m_idleTimer.StartZero();
+    ResetScreenSaver();
+    WakeUpScreenSaverAndDPMS();
+  }
+
+  // now handle any buttons or axis
+  std::string joystickName;
+  bool isAxis = false;
+  float fAmount = 0.0;
+
+  // es->ExecuteNextAction() invalidates the ref to the CEventServer instance
+  // when the action exits XBMC
+  es = CEventServer::GetInstance();
+  if (!es || !es->Running() || es->GetNumberOfClients()==0)
+    return false;
+  unsigned int wKeyID = es->GetButtonCode(joystickName, isAxis, fAmount);
+
+  if (wKeyID)
+  {
+    if (joystickName.length() > 0)
+    {
+      if (isAxis == true)
+      {
+        if (fabs(fAmount) >= 0.08)
+          m_lastAxisMap[joystickName][wKeyID] = fAmount;
+        else
+          m_lastAxisMap[joystickName].erase(wKeyID);
+      }
+
+      return ProcessJoystickEvent(joystickName, wKeyID, isAxis, fAmount);
+    }
+    else
+    {
+      CKey key;
+      if (wKeyID & ES_FLAG_UNICODE)
+      {
+        key = CKey((uint8_t)0, wKeyID & ~ES_FLAG_UNICODE, 0, 0, 0);
+        return OnKey(key);
+      }
+
+      if(wKeyID == KEY_BUTTON_LEFT_ANALOG_TRIGGER)
+        key = CKey(wKeyID, (BYTE)(255*fAmount), 0, 0.0, 0.0, 0.0, 0.0, frameTime);
+      else if(wKeyID == KEY_BUTTON_RIGHT_ANALOG_TRIGGER)
+        key = CKey(wKeyID, 0, (BYTE)(255*fAmount), 0.0, 0.0, 0.0, 0.0, frameTime);
+      else if(wKeyID == KEY_BUTTON_LEFT_THUMB_STICK_LEFT)
+        key = CKey(wKeyID, 0, 0, -fAmount, 0.0, 0.0, 0.0, frameTime);
+      else if(wKeyID == KEY_BUTTON_LEFT_THUMB_STICK_RIGHT)
+        key = CKey(wKeyID, 0, 0,  fAmount, 0.0, 0.0, 0.0, frameTime);
+      else if(wKeyID == KEY_BUTTON_LEFT_THUMB_STICK_UP)
+        key = CKey(wKeyID, 0, 0, 0.0,  fAmount, 0.0, 0.0, frameTime);
+      else if(wKeyID == KEY_BUTTON_LEFT_THUMB_STICK_DOWN)
+        key = CKey(wKeyID, 0, 0, 0.0, -fAmount, 0.0, 0.0, frameTime);
+      else if(wKeyID == KEY_BUTTON_RIGHT_THUMB_STICK_LEFT)
+        key = CKey(wKeyID, 0, 0, 0.0, 0.0, -fAmount, 0.0, frameTime);
+      else if(wKeyID == KEY_BUTTON_RIGHT_THUMB_STICK_RIGHT)
+        key = CKey(wKeyID, 0, 0, 0.0, 0.0,  fAmount, 0.0, frameTime);
+      else if(wKeyID == KEY_BUTTON_RIGHT_THUMB_STICK_UP)
+        key = CKey(wKeyID, 0, 0, 0.0, 0.0, 0.0,  fAmount, frameTime);
+      else if(wKeyID == KEY_BUTTON_RIGHT_THUMB_STICK_DOWN)
+        key = CKey(wKeyID, 0, 0, 0.0, 0.0, 0.0, -fAmount, frameTime);
+      else
+        key = CKey(wKeyID);
+      key.SetFromService(true);
+      return OnKey(key);
+    }
+  }
+
+  if (m_lastAxisMap.size() > 0)
+  {
+    // Process all the stored axis.
+    for (map<std::string, map<int, float> >::iterator iter = m_lastAxisMap.begin(); iter != m_lastAxisMap.end(); ++iter)
+    {
+      for (map<int, float>::iterator iterAxis = (*iter).second.begin(); iterAxis != (*iter).second.end(); ++iterAxis)
+        ProcessJoystickEvent((*iter).first, (*iterAxis).first, true, (*iterAxis).second);
+    }
+  }
+
+  {
+    CPoint pos;
+    if (es->GetMousePos(pos.x, pos.y) && g_Mouse.IsEnabled())
+    {
+      XBMC_Event newEvent;
+      newEvent.type = XBMC_MOUSEMOTION;
+      newEvent.motion.xrel = 0;
+      newEvent.motion.yrel = 0;
+      newEvent.motion.state = 0;
+      newEvent.motion.which = 0x10;  // just a different value to distinguish between mouse and event client device.
+      newEvent.motion.x = pos.x;
+      newEvent.motion.y = pos.y;
+      OnEvent(newEvent);  // had to call this to update g_Mouse position
+      return OnAction(CAction(ACTION_MOUSE_MOVE, pos.x, pos.y));
+    }
+  }
+#endif
+  return false;
+}
+
+bool CApplication::ProcessJoystickEvent(const std::string& joystickName, int wKeyID, bool isAxis, float fAmount, unsigned int holdTime /*=0*/)
+{
+#if defined(HAS_EVENT_SERVER)
+  m_idleTimer.StartZero();
+
+   // Make sure to reset screen saver, mouse.
+   ResetScreenSaver();
+   if (WakeUpScreenSaverAndDPMS())
+     return true;
+
+#ifdef HAS_SDL_JOYSTICK
+   g_Joystick.Reset();
+#endif
+   g_Mouse.SetActive(false);
+
+   int iWin = GetActiveWindowID();
+   int actionID;
+   CStdString actionName;
+   bool fullRange = false;
+
+   // Translate using regular joystick translator.
+   if (CButtonTranslator::GetInstance().TranslateJoystickString(iWin, joystickName.c_str(), wKeyID, isAxis ? JACTIVE_AXIS : JACTIVE_BUTTON, actionID, actionName, fullRange))
+     return ExecuteInputAction( CAction(actionID, fAmount, 0.0f, actionName, holdTime) );
+   else
+     CLog::Log(LOGDEBUG, "ERROR mapping joystick action. Joystick: %s %i",joystickName.c_str(), wKeyID);
+#endif
+
+   return false;
+}
+
+bool CApplication::ExecuteInputAction(CAction action)
+{
+  bool bResult = false;
+
+  // play sound before the action unless the button is held,
+  // where we execute after the action as held actions aren't fired every time.
+  if(action.GetHoldTime())
+  {
+    bResult = OnAction(action);
+    if(bResult)
+      g_audioManager.PlayActionSound(action);
+  }
+  else
+  {
+    g_audioManager.PlayActionSound(action);
+    bResult = OnAction(action);
+  }
+  return bResult;
+}
+
+int CApplication::GetActiveWindowID(void)
+{
+  // Get the currently active window
+  int iWin = g_windowManager.GetActiveWindow() & WINDOW_ID_MASK;
+
+  // If there is a dialog active get the dialog id instead
+  if (g_windowManager.HasModalDialog())
+    iWin = g_windowManager.GetTopMostModalDialogID() & WINDOW_ID_MASK;
+
+  // If the window is FullScreenVideo check for special cases
+  if (iWin == WINDOW_FULLSCREEN_VIDEO)
+  {
+    // check if we're in a DVD menu
+    if(g_application.m_pPlayer && g_application.m_pPlayer->IsInMenu())
+      iWin = WINDOW_VIDEO_MENU;
+    // check for LiveTV and switch to it's virtual window
+    else if (g_PVRManager.IsStarted() && g_application.CurrentFileItem().HasPVRChannelInfoTag())
+      iWin = WINDOW_FULLSCREEN_LIVETV;
+  }
+
+  // Return the window id
+  return iWin;
+}
+
+bool CApplication::Cleanup()
+{
+  try
+  {
+    g_windowManager.Delete(WINDOW_MUSIC_PLAYLIST);
+    g_windowManager.Delete(WINDOW_MUSIC_PLAYLIST_EDITOR);
+    g_windowManager.Delete(WINDOW_MUSIC_FILES);
+    g_windowManager.Delete(WINDOW_MUSIC_NAV);
+    g_windowManager.Delete(WINDOW_DIALOG_MUSIC_INFO);
+    g_windowManager.Delete(WINDOW_DIALOG_VIDEO_INFO);
+    g_windowManager.Delete(WINDOW_VIDEO_FILES);
+    g_windowManager.Delete(WINDOW_VIDEO_PLAYLIST);
+    g_windowManager.Delete(WINDOW_VIDEO_NAV);
+    g_windowManager.Delete(WINDOW_FILES);
+    g_windowManager.Delete(WINDOW_DIALOG_YES_NO);
+    g_windowManager.Delete(WINDOW_DIALOG_PROGRESS);
+    g_windowManager.Delete(WINDOW_DIALOG_NUMERIC);
+    g_windowManager.Delete(WINDOW_DIALOG_GAMEPAD);
+    g_windowManager.Delete(WINDOW_DIALOG_SUB_MENU);
+    g_windowManager.Delete(WINDOW_DIALOG_BUTTON_MENU);
+    g_windowManager.Delete(WINDOW_DIALOG_CONTEXT_MENU);
+    g_windowManager.Delete(WINDOW_DIALOG_PLAYER_CONTROLS);
+    g_windowManager.Delete(WINDOW_DIALOG_KARAOKE_SONGSELECT);
+    g_windowManager.Delete(WINDOW_DIALOG_KARAOKE_SELECTOR);
+    g_windowManager.Delete(WINDOW_DIALOG_MUSIC_OSD);
+    g_windowManager.Delete(WINDOW_DIALOG_VIS_PRESET_LIST);
+    g_windowManager.Delete(WINDOW_DIALOG_SELECT);
+    g_windowManager.Delete(WINDOW_DIALOG_OK);
+    g_windowManager.Delete(WINDOW_DIALOG_FILESTACKING);
+    g_windowManager.Delete(WINDOW_DIALOG_KEYBOARD);
+    g_windowManager.Delete(WINDOW_FULLSCREEN_VIDEO);
+    g_windowManager.Delete(WINDOW_DIALOG_PROFILE_SETTINGS);
+    g_windowManager.Delete(WINDOW_DIALOG_LOCK_SETTINGS);
+    g_windowManager.Delete(WINDOW_DIALOG_NETWORK_SETUP);
+    g_windowManager.Delete(WINDOW_DIALOG_MEDIA_SOURCE);
+    g_windowManager.Delete(WINDOW_DIALOG_VIDEO_OSD_SETTINGS);
+    g_windowManager.Delete(WINDOW_DIALOG_AUDIO_OSD_SETTINGS);
+    g_windowManager.Delete(WINDOW_DIALOG_VIDEO_BOOKMARKS);
+    g_windowManager.Delete(WINDOW_DIALOG_CONTENT_SETTINGS);
+    g_windowManager.Delete(WINDOW_DIALOG_FAVOURITES);
+    g_windowManager.Delete(WINDOW_DIALOG_SONG_INFO);
+    g_windowManager.Delete(WINDOW_DIALOG_SMART_PLAYLIST_EDITOR);
+    g_windowManager.Delete(WINDOW_DIALOG_SMART_PLAYLIST_RULE);
+    g_windowManager.Delete(WINDOW_DIALOG_BUSY);
+    g_windowManager.Delete(WINDOW_DIALOG_PICTURE_INFO);
+    g_windowManager.Delete(WINDOW_DIALOG_ADDON_INFO);
+    g_windowManager.Delete(WINDOW_DIALOG_ADDON_SETTINGS);
+    g_windowManager.Delete(WINDOW_DIALOG_ACCESS_POINTS);
+    g_windowManager.Delete(WINDOW_DIALOG_SLIDER);
+    g_windowManager.Delete(WINDOW_DIALOG_MEDIA_FILTER);
+
+    /* Delete PVR related windows and dialogs */
+    g_windowManager.Delete(WINDOW_PVR);
+    g_windowManager.Delete(WINDOW_DIALOG_PVR_GUIDE_INFO);
+    g_windowManager.Delete(WINDOW_DIALOG_PVR_RECORDING_INFO);
+    g_windowManager.Delete(WINDOW_DIALOG_PVR_TIMER_SETTING);
+    g_windowManager.Delete(WINDOW_DIALOG_PVR_GROUP_MANAGER);
+    g_windowManager.Delete(WINDOW_DIALOG_PVR_CHANNEL_MANAGER);
+    g_windowManager.Delete(WINDOW_DIALOG_PVR_GUIDE_SEARCH);
+    g_windowManager.Delete(WINDOW_DIALOG_PVR_CHANNEL_SCAN);
+    g_windowManager.Delete(WINDOW_DIALOG_PVR_UPDATE_PROGRESS);
+    g_windowManager.Delete(WINDOW_DIALOG_PVR_OSD_CHANNELS);
+    g_windowManager.Delete(WINDOW_DIALOG_PVR_OSD_GUIDE);
+    g_windowManager.Delete(WINDOW_DIALOG_PVR_OSD_DIRECTOR);
+    g_windowManager.Delete(WINDOW_DIALOG_PVR_OSD_CUTTER);
+    g_windowManager.Delete(WINDOW_DIALOG_OSD_TELETEXT);
+
+    g_windowManager.Delete(WINDOW_DIALOG_TEXT_VIEWER);
+    g_windowManager.Delete(WINDOW_DIALOG_PLAY_EJECT);
+    g_windowManager.Delete(WINDOW_STARTUP_ANIM);
+    g_windowManager.Delete(WINDOW_LOGIN_SCREEN);
+    g_windowManager.Delete(WINDOW_VISUALISATION);
+    g_windowManager.Delete(WINDOW_KARAOKELYRICS);
+    g_windowManager.Delete(WINDOW_SETTINGS_MENU);
+    g_windowManager.Delete(WINDOW_SETTINGS_PROFILES);
+    g_windowManager.Delete(WINDOW_SETTINGS_MYPICTURES);  // all the settings categories
+    g_windowManager.Delete(WINDOW_TEST_PATTERN);
+    g_windowManager.Delete(WINDOW_SCREEN_CALIBRATION);
+    g_windowManager.Delete(WINDOW_SYSTEM_INFORMATION);
+    g_windowManager.Delete(WINDOW_SCREENSAVER);
+    g_windowManager.Delete(WINDOW_DIALOG_VIDEO_OSD);
+    g_windowManager.Delete(WINDOW_DIALOG_MUSIC_OVERLAY);
+    g_windowManager.Delete(WINDOW_DIALOG_VIDEO_OVERLAY);
+    g_windowManager.Delete(WINDOW_SLIDESHOW);
+    g_windowManager.Delete(WINDOW_ADDON_BROWSER);
+    g_windowManager.Delete(WINDOW_SKIN_SETTINGS);
+
+    g_windowManager.Delete(WINDOW_HOME);
+    g_windowManager.Delete(WINDOW_PROGRAMS);
+    g_windowManager.Delete(WINDOW_PICTURES);
+    g_windowManager.Delete(WINDOW_WEATHER);
+
+    g_windowManager.Delete(WINDOW_SETTINGS_MYPICTURES);
+    g_windowManager.Remove(WINDOW_SETTINGS_MYPROGRAMS);
+    g_windowManager.Remove(WINDOW_SETTINGS_MYWEATHER);
+    g_windowManager.Remove(WINDOW_SETTINGS_MYMUSIC);
+    g_windowManager.Remove(WINDOW_SETTINGS_SYSTEM);
+    g_windowManager.Remove(WINDOW_SETTINGS_MYVIDEOS);
+    g_windowManager.Remove(WINDOW_SETTINGS_SERVICE);
+    g_windowManager.Remove(WINDOW_SETTINGS_APPEARANCE);
+    g_windowManager.Remove(WINDOW_SETTINGS_MYPVR);
+    g_windowManager.Remove(WINDOW_DIALOG_KAI_TOAST);
+
+    g_windowManager.Remove(WINDOW_DIALOG_SEEK_BAR);
+    g_windowManager.Remove(WINDOW_DIALOG_VOLUME_BAR);
+
+    CAddonMgr::Get().DeInit();
+
+#if defined(HAS_LIRC) || defined(HAS_IRSERVERSUITE)
+    CLog::Log(LOGNOTICE, "closing down remote control service");
+    g_RemoteControl.Disconnect();
+#endif
+
+    CLog::Log(LOGNOTICE, "unload sections");
+
+#ifdef HAS_PERFORMANCE_SAMPLE
+    CLog::Log(LOGNOTICE, "performance statistics");
+    m_perfStats.DumpStats();
+#endif
+
+    //  Shutdown as much as possible of the
+    //  application, to reduce the leaks dumped
+    //  to the vc output window before calling
+    //  _CrtDumpMemoryLeaks(). Most of the leaks
+    //  shown are no real leaks, as parts of the app
+    //  are still allocated.
+
+    g_localizeStrings.Clear();
+    g_LangCodeExpander.Clear();
+    g_charsetConverter.clear();
+    g_directoryCache.Clear();
+    CButtonTranslator::GetInstance().Clear();
+    CLastfmScrobbler::RemoveInstance();
+    CLibrefmScrobbler::RemoveInstance();
+    CLastFmManager::RemoveInstance();
+#ifdef HAS_EVENT_SERVER
+    CEventServer::RemoveInstance();
+#endif
+    DllLoaderContainer::Clear();
+    g_playlistPlayer.Clear();
+    g_settings.Clear();
+    g_guiSettings.Clear();
+    g_advancedSettings.Clear();
+
+#ifdef _LINUX
+    CXHandle::DumpObjectTracker();
+
+#ifdef HAS_DVD_DRIVE
+    CLibcdio::ReleaseInstance();
+#endif
+#endif 
+#if defined(TARGET_ANDROID)
+    // enable for all platforms once it's safe
+    g_sectionLoader.UnloadAll();
+#endif
+#ifdef _CRTDBG_MAP_ALLOC
+    _CrtDumpMemoryLeaks();
+    while(1); // execution ends
+#endif
+
+    delete m_network;
+    m_network = NULL;
+
+    return true;
+  }
+  catch (...)
+  {
+    CLog::Log(LOGERROR, "Exception in CApplication::Cleanup()");
+    return false;
+  }
+}
+
+void CApplication::Stop(int exitCode)
+{
+  try
+  {
+    CVariant vExitCode(exitCode);
+    CAnnouncementManager::Announce(System, "xbmc", "OnQuit", vExitCode);
+
+    SaveFileState(true);
+
+    // cancel any jobs from the jobmanager
+    CJobManager::GetInstance().CancelJobs();
+
+    g_alarmClock.StopThread();
+
+    if( m_bSystemScreenSaverEnable )
+      g_Windowing.EnableSystemScreenSaver(true);
+
+    CLog::Log(LOGNOTICE, "Storing total System Uptime");
+    g_settings.m_iSystemTimeTotalUp = g_settings.m_iSystemTimeTotalUp + (int)(CTimeUtils::GetFrameTime() / 60000);
+
+    // Update the settings information (volume, uptime etc. need saving)
+    if (CFile::Exists(g_settings.GetSettingsFile()))
+    {
+      CLog::Log(LOGNOTICE, "Saving settings");
+      g_settings.Save();
+    }
+    else
+      CLog::Log(LOGNOTICE, "Not saving settings (settings.xml is not present)");
+
+    m_bStop = true;
+    m_AppActive = false;
+    m_AppFocused = false;
+    m_ExitCode = exitCode;
+    CLog::Log(LOGNOTICE, "stop all");
+
+    // stop scanning before we kill the network and so on
+    if (m_musicInfoScanner->IsScanning())
+      m_musicInfoScanner->Stop();
+
+    if (m_videoInfoScanner->IsScanning())
+      m_videoInfoScanner->Stop();
+
+    CApplicationMessenger::Get().Cleanup();
+
+    StopPVRManager();
+    StopServices();
+    //Sleep(5000);
+
+#ifdef HAS_WEB_SERVER
+  CWebServer::UnregisterRequestHandler(&m_httpImageHandler);
+  CWebServer::UnregisterRequestHandler(&m_httpVfsHandler);
+#ifdef HAS_JSONRPC
+  CWebServer::UnregisterRequestHandler(&m_httpJsonRpcHandler);
+  CJSONRPC::Cleanup();
+#endif
+#ifdef HAS_WEB_INTERFACE
+  CWebServer::UnregisterRequestHandler(&m_httpWebinterfaceAddonsHandler);
+  CWebServer::UnregisterRequestHandler(&m_httpWebinterfaceHandler);
+#endif
+#endif
+
+    if (m_pPlayer)
+    {
+      CLog::Log(LOGNOTICE, "stop player");
+      delete m_pPlayer;
+      m_pPlayer = NULL;
+    }
+
+#if HAS_FILESYTEM_DAAP
+    CLog::Log(LOGNOTICE, "stop daap clients");
+    g_DaapClient.Release();
+#endif
+#ifdef HAS_FILESYSTEM_SAP
+    CLog::Log(LOGNOTICE, "stop sap announcement listener");
+    g_sapsessions.StopThread();
+#endif
+#ifdef HAS_ZEROCONF
+    if(CZeroconfBrowser::IsInstantiated())
+    {
+      CLog::Log(LOGNOTICE, "stop zeroconf browser");
+      CZeroconfBrowser::GetInstance()->Stop();
+      CZeroconfBrowser::ReleaseInstance();
+    }
+#endif
+
+    CLog::Log(LOGNOTICE, "clean cached files!");
+#ifdef HAS_FILESYSTEM_RAR
+    g_RarManager.ClearCache(true);
+#endif
+
+#ifdef HAS_FILESYSTEM_SFTP
+    CSFTPSessionManager::DisconnectAllSessions();
+#endif
+
+    CLog::Log(LOGNOTICE, "unload skin");
+    UnloadSkin();
+
+#if defined(TARGET_DARWIN_OSX)
+    if (XBMCHelper::GetInstance().IsAlwaysOn() == false)
+      XBMCHelper::GetInstance().Stop();
+#endif
+
+#if defined(HAVE_LIBCRYSTALHD)
+    CCrystalHD::RemoveInstance();
+#endif
+
+  g_mediaManager.Stop();
+
+  // Stop services before unloading Python
+  CAddonMgr::Get().StopServices(false);
+
+/* Python resource freeing must be done after skin has been unloaded, not before
+   some windows still need it when deinitializing during skin unloading. */
+#ifdef HAS_PYTHON
+  CLog::Log(LOGNOTICE, "stop python");
+  g_pythonParser.FreeResources();
+#endif
+#ifdef HAS_LCD
+    if (g_lcd)
+    {
+      g_lcd->Stop();
+      delete g_lcd;
+      g_lcd=NULL;
+    }
+#endif
+
+    g_Windowing.DestroyRenderSystem();
+    g_Windowing.DestroyWindow();
+    g_Windowing.DestroyWindowSystem();
+
+    // shutdown the AudioEngine
+    CAEFactory::Shutdown();
+    CAEFactory::UnLoadEngine();
+
+    CLog::Log(LOGNOTICE, "stopped");
+  }
+  catch (...)
+  {
+    CLog::Log(LOGERROR, "Exception in CApplication::Stop()");
+  }
+
+  // we may not get to finish the run cycle but exit immediately after a call to g_application.Stop()
+  // so we may never get to Destroy() in CXBApplicationEx::Run(), we call it here.
+  Destroy();
+
+  //
+  Sleep(200);
+}
+
+bool CApplication::PlayMedia(const CFileItem& item, int iPlaylist)
+{
+  //If item is a plugin, expand out now and run ourselves again
+  if (item.IsPlugin())
+  {
+    CFileItem item_new(item);
+    if (XFILE::CPluginDirectory::GetPluginResult(item.GetPath(), item_new))
+      return PlayMedia(item_new, iPlaylist);
+    return false;
+  }
+  if (item.IsLastFM())
+  {
+    g_partyModeManager.Disable();
+    return CLastFmManager::GetInstance()->ChangeStation(item.GetAsUrl());
+  }
+  if (item.IsSmartPlayList())
+  {
+    CFileItemList items;
+    CUtil::GetRecursiveListing(item.GetPath(), items, "");
+    if (items.Size())
+    {
+      CSmartPlaylist smartpl;
+      //get name and type of smartplaylist, this will always succeed as GetDirectory also did this.
+      smartpl.OpenAndReadName(item.GetPath());
+      CPlayList playlist;
+      playlist.Add(items);
+      return ProcessAndStartPlaylist(smartpl.GetName(), playlist, (smartpl.GetType() == "songs" || smartpl.GetType() == "albums") ? PLAYLIST_MUSIC:PLAYLIST_VIDEO);
+    }
+  }
+  else if (item.IsPlayList() || item.IsInternetStream())
+  {
+    CGUIDialogCache* dlgCache = new CGUIDialogCache(5000, g_localizeStrings.Get(10214), item.GetLabel());
+
+    //is or could be a playlist
+    auto_ptr<CPlayList> pPlayList (CPlayListFactory::Create(item));
+    bool gotPlayList = (pPlayList.get() && pPlayList->Load(item.GetPath()));
+
+    if (dlgCache)
+    {
+       dlgCache->Close();
+       if (dlgCache->IsCanceled())
+          return true;
+    }
+
+    if (gotPlayList)
+    {
+
+      if (iPlaylist != PLAYLIST_NONE)
+      {
+        int track=0;
+        if (item.HasProperty("playlist_starting_track"))
+          track = (int)item.GetProperty("playlist_starting_track").asInteger();
+        return ProcessAndStartPlaylist(item.GetPath(), *pPlayList, iPlaylist, track);
+      }
+      else
+      {
+        CLog::Log(LOGWARNING, "CApplication::PlayMedia called to play a playlist %s but no idea which playlist to use, playing first item", item.GetPath().c_str());
+        if(pPlayList->size())
+          return PlayFile(*(*pPlayList)[0], false);
+      }
+    }
+  }
+
+  //nothing special just play
+  return PlayFile(item, false);
+}
+
+// PlayStack()
+// For playing a multi-file video.  Particularly inefficient
+// on startup, as we are required to calculate the length
+// of each video, so we open + close each one in turn.
+// A faster calculation of video time would improve this
+// substantially.
+bool CApplication::PlayStack(const CFileItem& item, bool bRestart)
+{
+  if (!item.IsStack())
+    return false;
+
+  CVideoDatabase dbs;
+
+  // case 1: stacked ISOs
+  if (CFileItem(CStackDirectory::GetFirstStackedFile(item.GetPath()),false).IsDVDImage())
+  {
+    CStackDirectory dir;
+    CFileItemList movieList;
+    dir.GetDirectory(item.GetPath(), movieList);
+
+    // first assume values passed to the stack
+    int selectedFile = item.m_lStartPartNumber;
+    int startoffset = item.m_lStartOffset;
+
+    // check if we instructed the stack to resume from default
+    if (startoffset == STARTOFFSET_RESUME) // selected file is not specified, pick the 'last' resume point
+    {
+      if (dbs.Open())
+      {
+        CBookmark bookmark;
+        if (dbs.GetResumeBookMark(item.GetPath(), bookmark))
+        {
+          startoffset = (int)(bookmark.timeInSeconds*75);
+          selectedFile = bookmark.partNumber;
+        }
+        dbs.Close();
+      }
+      else
+        CLog::Log(LOGERROR, "%s - Cannot open VideoDatabase", __FUNCTION__);
+    }
+
+    // make sure that the selected part is within the boundaries
+    if (selectedFile <= 0)
+    {
+      CLog::Log(LOGWARNING, "%s - Selected part %d out of range, playing part 1", __FUNCTION__, selectedFile);
+      selectedFile = 1;
+    }
+    else if (selectedFile > movieList.Size())
+    {
+      CLog::Log(LOGWARNING, "%s - Selected part %d out of range, playing part %d", __FUNCTION__, selectedFile, movieList.Size());
+      selectedFile = movieList.Size();
+    }
+
+    // set startoffset in movieitem, track stack item for updating purposes, and finally play disc part
+    movieList[selectedFile - 1]->m_lStartOffset = startoffset > 0 ? STARTOFFSET_RESUME : 0;
+    movieList[selectedFile - 1]->SetProperty("stackFileItemToUpdate", true);
+    *m_stackFileItemToUpdate = item;
+    return PlayFile(*(movieList[selectedFile - 1]));
+  }
+  // case 2: all other stacks
+  else
+  {
+    // see if we have the info in the database
+    // TODO: If user changes the time speed (FPS via framerate conversion stuff)
+    //       then these times will be wrong.
+    //       Also, this is really just a hack for the slow load up times we have
+    //       A much better solution is a fast reader of FPS and fileLength
+    //       that we can use on a file to get it's time.
+    vector<int> times;
+    bool haveTimes(false);
+    CVideoDatabase dbs;
+    if (dbs.Open())
+    {
+      dbs.GetVideoSettings(item.GetPath(), g_settings.m_currentVideoSettings);
+      haveTimes = dbs.GetStackTimes(item.GetPath(), times);
+      dbs.Close();
+    }
+
+
+    // calculate the total time of the stack
+    CStackDirectory dir;
+    dir.GetDirectory(item.GetPath(), *m_currentStack);
+    long totalTime = 0;
+    for (int i = 0; i < m_currentStack->Size(); i++)
+    {
+      if (haveTimes)
+        (*m_currentStack)[i]->m_lEndOffset = times[i];
+      else
+      {
+        int duration;
+        if (!CDVDFileInfo::GetFileDuration((*m_currentStack)[i]->GetPath(), duration))
+        {
+          m_currentStack->Clear();
+          return false;
+        }
+        totalTime += duration / 1000;
+        (*m_currentStack)[i]->m_lEndOffset = totalTime;
+        times.push_back(totalTime);
+      }
+    }
+
+    double seconds = item.m_lStartOffset / 75.0;
+
+    if (!haveTimes || item.m_lStartOffset == STARTOFFSET_RESUME )
+    {  // have our times now, so update the dB
+      if (dbs.Open())
+      {
+        if( !haveTimes )
+          dbs.SetStackTimes(item.GetPath(), times);
+
+        if( item.m_lStartOffset == STARTOFFSET_RESUME )
+        {
+          // can only resume seek here, not dvdstate
+          CBookmark bookmark;
+          if( dbs.GetResumeBookMark(item.GetPath(), bookmark) )
+            seconds = bookmark.timeInSeconds;
+          else
+            seconds = 0.0f;
+        }
+        dbs.Close();
+      }
+    }
+
+    *m_itemCurrentFile = item;
+    m_currentStackPosition = 0;
+    m_eCurrentPlayer = EPC_NONE; // must be reset on initial play otherwise last player will be used
+
+    if (seconds > 0)
+    {
+      // work out where to seek to
+      for (int i = 0; i < m_currentStack->Size(); i++)
+      {
+        if (seconds < (*m_currentStack)[i]->m_lEndOffset)
+        {
+          CFileItem item(*(*m_currentStack)[i]);
+          long start = (i > 0) ? (*m_currentStack)[i-1]->m_lEndOffset : 0;
+          item.m_lStartOffset = (long)(seconds - start) * 75;
+          m_currentStackPosition = i;
+          return PlayFile(item, true);
+        }
+      }
+    }
+
+    return PlayFile(*(*m_currentStack)[0], true);
+  }
+  return false;
+}
+
+bool CApplication::PlayFile(const CFileItem& item, bool bRestart)
+{
+  if (!bRestart)
+  {
+    SaveCurrentFileSettings();
+
+    OutputDebugString("new file set audiostream:0\n");
+    // Switch to default options
+    g_settings.m_currentVideoSettings = g_settings.m_defaultVideoSettings;
+    // see if we have saved options in the database
+
+    SetPlaySpeed(1);
+    m_iPlaySpeed = 1;     // Reset both CApp's & Player's speed else we'll get confused
+
+    *m_itemCurrentFile = item;
+    m_nextPlaylistItem = -1;
+    m_currentStackPosition = 0;
+    m_currentStack->Clear();
+
+    if (item.IsVideo())
+      CUtil::ClearSubtitles();
+  }
+
+  if (item.IsDiscStub())
+  {
+#ifdef HAS_DVD_DRIVE
+    // Display the Play Eject dialog if there is any optical disc drive
+    if (g_mediaManager.HasOpticalDrive())
+    {
+      if (CGUIDialogPlayEject::ShowAndGetInput(item))
+        // PlayDiscAskResume takes path to disc. No parameter means default DVD drive.
+        // Can't do better as CGUIDialogPlayEject calls CMediaManager::IsDiscInDrive, which assumes default DVD drive anyway
+        return MEDIA_DETECT::CAutorun::PlayDiscAskResume();
+    }
+    else
+#endif
+      CGUIDialogOK::ShowAndGetInput(435, 0, 436, 0);
+
+    return true;
+  }
+
+  if (item.IsPlayList())
+    return false;
+
+  if (item.IsPlugin())
+  { // we modify the item so that it becomes a real URL
+    CFileItem item_new(item);
+    if (XFILE::CPluginDirectory::GetPluginResult(item.GetPath(), item_new))
+      return PlayFile(item_new, false);
+    return false;
+  }
+
+#ifdef HAS_UPNP
+  if (URIUtils::IsUPnP(item.GetPath()))
+  {
+    CFileItem item_new(item);
+    if (XFILE::CUPnPDirectory::GetResource(item.GetPath(), item_new))
+      return PlayFile(item_new, false);
+    return false;
+  }
+#endif
+
+  // if we have a stacked set of files, we need to setup our stack routines for
+  // "seamless" seeking and total time of the movie etc.
+  // will recall with restart set to true
+  if (item.IsStack())
+    return PlayStack(item, bRestart);
+
+  //Is TuxBox, this should probably be moved to CTuxBoxFile
+  if(item.IsTuxBox())
+  {
+    CLog::Log(LOGDEBUG, "%s - TuxBox URL Detected %s",__FUNCTION__, item.GetPath().c_str());
+
+    if(g_tuxboxService.IsRunning())
+      g_tuxboxService.Stop();
+
+    CFileItem item_new;
+    if(g_tuxbox.CreateNewItem(item, item_new))
+    {
+
+      // Make sure it doesn't have a player
+      // so we actually select one normally
+      m_eCurrentPlayer = EPC_NONE;
+
+      // keep the tuxbox:// url as playing url
+      // and give the new url to the player
+      if(PlayFile(item_new, true))
+      {
+        if(!g_tuxboxService.IsRunning())
+          g_tuxboxService.Start();
+        return true;
+      }
+    }
+    return false;
+  }
+
+  CPlayerOptions options;
+
+  if( item.HasProperty("StartPercent") )
+  {
+    double fallback = 0.0f;
+    if(item.GetProperty("StartPercent").isString())
+      fallback = (double)atof(item.GetProperty("StartPercent").asString().c_str());
+    options.startpercent = item.GetProperty("StartPercent").asDouble(fallback);
+  }
+
+  PLAYERCOREID eNewCore = EPC_NONE;
+  if( bRestart )
+  {
+    // have to be set here due to playstack using this for starting the file
+    options.starttime = item.m_lStartOffset / 75.0;
+    if (m_itemCurrentFile->IsStack() && m_currentStack->Size() > 0 && m_itemCurrentFile->m_lStartOffset != 0)
+      m_itemCurrentFile->m_lStartOffset = STARTOFFSET_RESUME; // to force fullscreen switching
+
+    if( m_eForcedNextPlayer != EPC_NONE )
+      eNewCore = m_eForcedNextPlayer;
+    else if( m_eCurrentPlayer == EPC_NONE )
+      eNewCore = CPlayerCoreFactory::GetDefaultPlayer(item);
+    else
+      eNewCore = m_eCurrentPlayer;
+  }
+  else
+  {
+    options.starttime = item.m_lStartOffset / 75.0;
+
+    if (item.IsVideo())
+    {
+      // open the d/b and retrieve the bookmarks for the current movie
+      CVideoDatabase dbs;
+      dbs.Open();
+      dbs.GetVideoSettings(item.GetPath(), g_settings.m_currentVideoSettings);
+
+      if( item.m_lStartOffset == STARTOFFSET_RESUME )
+      {
+        options.starttime = 0.0f;
+        CBookmark bookmark;
+        CStdString path = item.GetPath();
+        if (item.HasVideoInfoTag() && item.GetVideoInfoTag()->m_strFileNameAndPath.Find("removable://") == 0)
+          path = item.GetVideoInfoTag()->m_strFileNameAndPath;
+        else if (item.HasProperty("original_listitem_url") && URIUtils::IsPlugin(item.GetProperty("original_listitem_url").asString()))
+          path = item.GetProperty("original_listitem_url").asString();
+        if(dbs.GetResumeBookMark(path, bookmark))
+        {
+          options.starttime = bookmark.timeInSeconds;
+          options.state = bookmark.playerState;
+        }
+        /*
+         override with information from the actual item if available.  We do this as the VFS (eg plugins)
+         may set the resume point to override whatever XBMC has stored, yet we ignore it until now so that,
+         should the playerState be required, it is fetched from the database.
+         See the note in CGUIWindowVideoBase::ShowResumeMenu.
+         */
+        if (item.HasVideoInfoTag() && item.GetVideoInfoTag()->m_resumePoint.IsSet())
+          options.starttime = item.GetVideoInfoTag()->m_resumePoint.timeInSeconds;
+      }
+      else if (item.HasVideoInfoTag())
+      {
+        const CVideoInfoTag *tag = item.GetVideoInfoTag();
+
+        if (tag->m_iBookmarkId != -1 && tag->m_iBookmarkId != 0)
+        {
+          CBookmark bookmark;
+          dbs.GetBookMarkForEpisode(*tag, bookmark);
+          options.starttime = bookmark.timeInSeconds;
+          options.state = bookmark.playerState;
+        }
+      }
+
+      dbs.Close();
+    }
+
+    if (m_eForcedNextPlayer != EPC_NONE)
+      eNewCore = m_eForcedNextPlayer;
+    else
+      eNewCore = CPlayerCoreFactory::GetDefaultPlayer(item);
+  }
+
+  // this really aught to be inside !bRestart, but since PlayStack
+  // uses that to init playback, we have to keep it outside
+  int playlist = g_playlistPlayer.GetCurrentPlaylist();
+  if (item.IsVideo() && g_playlistPlayer.GetPlaylist(playlist).size() > 1)
+  { // playing from a playlist by the looks
+    // don't switch to fullscreen if we are not playing the first item...
+    options.fullscreen = !g_playlistPlayer.HasPlayedFirstFile() && g_advancedSettings.m_fullScreenOnMovieStart && !g_settings.m_bStartVideoWindowed;
+  }
+  else if(m_itemCurrentFile->IsStack() && m_currentStack->Size() > 0)
+  {
+    // TODO - this will fail if user seeks back to first file in stack
+    if(m_currentStackPosition == 0 || m_itemCurrentFile->m_lStartOffset == STARTOFFSET_RESUME)
+      options.fullscreen = g_advancedSettings.m_fullScreenOnMovieStart && !g_settings.m_bStartVideoWindowed;
+    else
+      options.fullscreen = false;
+    // reset this so we don't think we are resuming on seek
+    m_itemCurrentFile->m_lStartOffset = 0;
+  }
+  else
+    options.fullscreen = g_advancedSettings.m_fullScreenOnMovieStart && !g_settings.m_bStartVideoWindowed;
+
+  // reset m_bStartVideoWindowed as it's a temp setting
+  g_settings.m_bStartVideoWindowed = false;
+  // reset any forced player
+  m_eForcedNextPlayer = EPC_NONE;
+
+#ifdef HAS_KARAOKE
+  //We have to stop parsing a cdg before mplayer is deallocated
+  // WHY do we have to do this????
+  if (m_pKaraokeMgr)
+    m_pKaraokeMgr->Stop();
+#endif
+
+  // tell system we are starting a file
+  m_bPlaybackStarting = true;
+
+  // We should restart the player, unless the previous and next tracks are using
+  // one of the players that allows gapless playback (paplayer, dvdplayer)
+  if (m_pPlayer)
+  {
+    if ( !(m_eCurrentPlayer == eNewCore && (m_eCurrentPlayer == EPC_DVDPLAYER || m_eCurrentPlayer  == EPC_PAPLAYER
+#if defined(HAS_OMXPLAYER)
+            || m_eCurrentPlayer == EPC_OMXPLAYER
+#endif            
+            )) )
+    {
+      delete m_pPlayer;
+      m_pPlayer = NULL;
+    }
+  }
+
+  if (!m_pPlayer)
+  {
+    m_eCurrentPlayer = eNewCore;
+    m_pPlayer = CPlayerCoreFactory::CreatePlayer(eNewCore, *this);
+  }
+
+  bool bResult;
+  if (m_pPlayer)
+  {
+    // don't hold graphicscontext here since player
+    // may wait on another thread, that requires gfx
+    CSingleExit ex(g_graphicsContext);
+    bResult = m_pPlayer->OpenFile(item, options);
+  }
+  else
+  {
+    CLog::Log(LOGERROR, "Error creating player for item %s (File doesn't exist?)", item.GetPath().c_str());
+    bResult = false;
+  }
+
+  if(bResult)
+  {
+    if (m_iPlaySpeed != 1)
+    {
+      int iSpeed = m_iPlaySpeed;
+      m_iPlaySpeed = 1;
+      SetPlaySpeed(iSpeed);
+    }
+
+    // if player has volume control, set it.
+    if (m_pPlayer && m_pPlayer->ControlsVolume())
+    {
+       m_pPlayer->SetVolume(g_settings.m_fVolumeLevel);
+       m_pPlayer->SetMute(g_settings.m_bMute);
+    }
+
+    if( IsPlayingAudio() )
+    {
+      if (g_windowManager.GetActiveWindow() == WINDOW_FULLSCREEN_VIDEO)
+        g_windowManager.ActivateWindow(WINDOW_VISUALISATION);
+    }
+
+#ifdef HAS_VIDEO_PLAYBACK
+    if( IsPlayingVideo() )
+    {
+      if (g_windowManager.GetActiveWindow() == WINDOW_VISUALISATION)
+        g_windowManager.ActivateWindow(WINDOW_FULLSCREEN_VIDEO);
+
+      // if player didn't manange to switch to fullscreen by itself do it here
+      if( options.fullscreen && g_renderManager.IsStarted()
+       && g_windowManager.GetActiveWindow() != WINDOW_FULLSCREEN_VIDEO )
+       SwitchToFullScreen();
+    }
+#endif
+
+#if !defined(TARGET_DARWIN) && !defined(_LINUX)
+    g_audioManager.Enable(false);
+#endif
+
+    if (item.HasPVRChannelInfoTag())
+      g_playlistPlayer.SetCurrentPlaylist(PLAYLIST_NONE);
+  }
+  m_bPlaybackStarting = false;
+
+  if (bResult)
+  {
+    // we must have started, otherwise player might send this later
+    if(IsPlaying())
+      OnPlayBackStarted();
+    else
+      OnPlayBackEnded();
+  }
+  else
+  {
+    // we send this if it isn't playlistplayer that is doing this
+    int next = g_playlistPlayer.GetNextSong();
+    int size = g_playlistPlayer.GetPlaylist(g_playlistPlayer.GetCurrentPlaylist()).size();
+    if(next < 0
+    || next >= size)
+      OnPlayBackStopped();
+  }
+
+  return bResult;
+}
+
+void CApplication::OnPlayBackEnded()
+{
+  if(m_bPlaybackStarting)
+    return;
+
+  if (CJobManager::GetInstance().IsPaused(kJobTypeMediaFlags))
+    CJobManager::GetInstance().UnPause(kJobTypeMediaFlags);
+
+  // informs python script currently running playback has ended
+  // (does nothing if python is not loaded)
+#ifdef HAS_PYTHON
+  g_pythonParser.OnPlayBackEnded();
+#endif
+
+  CVariant data(CVariant::VariantTypeObject);
+  data["end"] = true;
+  CAnnouncementManager::Announce(Player, "xbmc", "OnStop", m_itemCurrentFile, data);
+
+  if (IsPlayingAudio())
+  {
+    CLastfmScrobbler::GetInstance()->SubmitQueue();
+    CLibrefmScrobbler::GetInstance()->SubmitQueue();
+  }
+
+  CGUIMessage msg(GUI_MSG_PLAYBACK_ENDED, 0, 0);
+  g_windowManager.SendThreadMessage(msg);
+}
+
+void CApplication::OnPlayBackStarted()
+{
+  if(m_bPlaybackStarting)
+    return;
+
+  if (!CJobManager::GetInstance().IsPaused(kJobTypeMediaFlags))
+    CJobManager::GetInstance().Pause(kJobTypeMediaFlags);
+
+#ifdef HAS_PYTHON
+  // informs python script currently running playback has started
+  // (does nothing if python is not loaded)
+  g_pythonParser.OnPlayBackStarted();
+#endif
+
+  CGUIMessage msg(GUI_MSG_PLAYBACK_STARTED, 0, 0);
+  g_windowManager.SendThreadMessage(msg);
+}
+
+void CApplication::OnQueueNextItem()
+{
+  // informs python script currently running that we are requesting the next track
+  // (does nothing if python is not loaded)
+#ifdef HAS_PYTHON
+  g_pythonParser.OnQueueNextItem(); // currently unimplemented
+#endif
+
+  if(IsPlayingAudio())
+  {
+    CLastfmScrobbler::GetInstance()->SubmitQueue();
+    CLibrefmScrobbler::GetInstance()->SubmitQueue();
+  }
+
+  CGUIMessage msg(GUI_MSG_QUEUE_NEXT_ITEM, 0, 0);
+  g_windowManager.SendThreadMessage(msg);
+}
+
+void CApplication::OnPlayBackStopped()
+{
+  if(m_bPlaybackStarting)
+    return;
+
+  if (CJobManager::GetInstance().IsPaused(kJobTypeMediaFlags))
+    CJobManager::GetInstance().UnPause(kJobTypeMediaFlags);
+
+  // informs python script currently running playback has ended
+  // (does nothing if python is not loaded)
+#ifdef HAS_PYTHON
+  g_pythonParser.OnPlayBackStopped();
+#endif
+
+  CVariant data(CVariant::VariantTypeObject);
+  data["end"] = false;
+  CAnnouncementManager::Announce(Player, "xbmc", "OnStop", m_itemCurrentFile, data);
+
+  CLastfmScrobbler::GetInstance()->SubmitQueue();
+  CLibrefmScrobbler::GetInstance()->SubmitQueue();
+
+  CGUIMessage msg( GUI_MSG_PLAYBACK_STOPPED, 0, 0 );
+  g_windowManager.SendThreadMessage(msg);
+}
+
+void CApplication::OnPlayBackPaused()
+{
+#ifdef HAS_PYTHON
+  g_pythonParser.OnPlayBackPaused();
+#endif
+
+  CVariant param;
+  param["player"]["speed"] = 0;
+  param["player"]["playerid"] = g_playlistPlayer.GetCurrentPlaylist();
+  CAnnouncementManager::Announce(Player, "xbmc", "OnPause", m_itemCurrentFile, param);
+}
+
+void CApplication::OnPlayBackResumed()
+{
+#ifdef HAS_PYTHON
+  g_pythonParser.OnPlayBackResumed();
+#endif
+
+  CVariant param;
+  param["player"]["speed"] = 1;
+  param["player"]["playerid"] = g_playlistPlayer.GetCurrentPlaylist();
+  CAnnouncementManager::Announce(Player, "xbmc", "OnPlay", m_itemCurrentFile, param);
+}
+
+void CApplication::OnPlayBackSpeedChanged(int iSpeed)
+{
+#ifdef HAS_PYTHON
+  g_pythonParser.OnPlayBackSpeedChanged(iSpeed);
+#endif
+
+  CVariant param;
+  param["player"]["speed"] = iSpeed;
+  param["player"]["playerid"] = g_playlistPlayer.GetCurrentPlaylist();
+  CAnnouncementManager::Announce(Player, "xbmc", "OnSpeedChanged", m_itemCurrentFile, param);
+}
+
+void CApplication::OnPlayBackSeek(int iTime, int seekOffset)
+{
+#ifdef HAS_PYTHON
+  g_pythonParser.OnPlayBackSeek(iTime, seekOffset);
+#endif
+
+  CVariant param;
+  CJSONUtils::MillisecondsToTimeObject(iTime, param["player"]["time"]);
+  CJSONUtils::MillisecondsToTimeObject(seekOffset, param["player"]["seekoffset"]);;
+  param["player"]["playerid"] = g_playlistPlayer.GetCurrentPlaylist();
+  param["player"]["speed"] = GetPlaySpeed();
+  CAnnouncementManager::Announce(Player, "xbmc", "OnSeek", m_itemCurrentFile, param);
+  g_infoManager.SetDisplayAfterSeek(2500, seekOffset/1000);
+}
+
+void CApplication::OnPlayBackSeekChapter(int iChapter)
+{
+#ifdef HAS_PYTHON
+  g_pythonParser.OnPlayBackSeekChapter(iChapter);
+#endif
+}
+
+bool CApplication::IsPlaying() const
+{
+  if (!m_pPlayer)
+    return false;
+  if (!m_pPlayer->IsPlaying())
+    return false;
+  return true;
+}
+
+bool CApplication::IsPaused() const
+{
+  if (!m_pPlayer)
+    return false;
+  if (!m_pPlayer->IsPlaying())
+    return false;
+  return m_pPlayer->IsPaused();
+}
+
+bool CApplication::IsPlayingAudio() const
+{
+  if (!m_pPlayer)
+    return false;
+  if (!m_pPlayer->IsPlaying())
+    return false;
+  if (m_pPlayer->HasVideo())
+    return false;
+  if (m_pPlayer->HasAudio())
+    return true;
+  return false;
+}
+
+bool CApplication::IsPlayingVideo() const
+{
+  if (!m_pPlayer)
+    return false;
+  if (!m_pPlayer->IsPlaying())
+    return false;
+  if (m_pPlayer->HasVideo())
+    return true;
+
+  return false;
+}
+
+bool CApplication::IsPlayingFullScreenVideo() const
+{
+  return IsPlayingVideo() && g_graphicsContext.IsFullScreenVideo();
+}
+
+bool CApplication::IsFullScreen()
+{
+  return IsPlayingFullScreenVideo() ||
+        (g_windowManager.GetActiveWindow() == WINDOW_VISUALISATION) ||
+         g_windowManager.GetActiveWindow() == WINDOW_SLIDESHOW;
+}
+
+void CApplication::SaveFileState(bool bForeground /* = false */)
+{
+  if (m_progressTrackingItem->IsPVRChannel() || !g_settings.GetCurrentProfile().canWriteDatabases())
+    return;
+
+  if (bForeground)
+  {
+    CSaveFileStateJob job(*m_progressTrackingItem,
+    *m_stackFileItemToUpdate,
+    m_progressTrackingVideoResumeBookmark,
+    m_progressTrackingPlayCountUpdate);
+
+    // Run job in the foreground to make sure it finishes
+    job.DoWork();
+  }
+  else
+  {
+    CJob* job = new CSaveFileStateJob(*m_progressTrackingItem,
+        *m_stackFileItemToUpdate,
+        m_progressTrackingVideoResumeBookmark,
+        m_progressTrackingPlayCountUpdate);
+    CJobManager::GetInstance().AddJob(job, NULL);
+  }
+}
+
+void CApplication::UpdateFileState()
+{
+  // Did the file change?
+  if (m_progressTrackingItem->GetPath() != "" && m_progressTrackingItem->GetPath() != CurrentFile())
+  {
+    SaveFileState();
+
+    // Reset tracking item
+    m_progressTrackingItem->Reset();
+  }
+  else
+  {
+    if (IsPlayingVideo() || IsPlayingAudio())
+    {
+      if (m_progressTrackingItem->GetPath() == "")
+      {
+        // Init some stuff
+        *m_progressTrackingItem = CurrentFileItem();
+        m_progressTrackingPlayCountUpdate = false;
+      }
+
+      if ((m_progressTrackingItem->IsAudio() && g_advancedSettings.m_audioPlayCountMinimumPercent > 0 &&
+          GetPercentage() >= g_advancedSettings.m_audioPlayCountMinimumPercent) ||
+          (m_progressTrackingItem->IsVideo() && g_advancedSettings.m_videoPlayCountMinimumPercent > 0 &&
+          GetPercentage() >= g_advancedSettings.m_videoPlayCountMinimumPercent))
+      {
+        m_progressTrackingPlayCountUpdate = true;
+      }
+
+      // Check whether we're *really* playing video else we may race when getting eg. stream details
+      if (IsPlayingVideo())
+      {
+        // Special case for DVDs: Only extract streamdetails if title length > 15m. Should yield more correct info
+        if (!(m_progressTrackingItem->IsDVDImage() || m_progressTrackingItem->IsDVDFile()) || m_pPlayer->GetTotalTime() > 15*60*1000)
+        {
+          CStreamDetails details;
+          // Update with stream details from player, if any
+          if (m_pPlayer->GetStreamDetails(details))
+            m_progressTrackingItem->GetVideoInfoTag()->m_streamDetails = details;
+        }
+
+        // Update bookmark for save
+        m_progressTrackingVideoResumeBookmark.player = CPlayerCoreFactory::GetPlayerName(m_eCurrentPlayer);
+        m_progressTrackingVideoResumeBookmark.playerState = m_pPlayer->GetPlayerState();
+        m_progressTrackingVideoResumeBookmark.thumbNailImage.Empty();
+
+        if (g_advancedSettings.m_videoIgnorePercentAtEnd > 0 &&
+            GetTotalTime() - GetTime() < 0.01f * g_advancedSettings.m_videoIgnorePercentAtEnd * GetTotalTime())
+        {
+          // Delete the bookmark
+          m_progressTrackingVideoResumeBookmark.timeInSeconds = -1.0f;
+        }
+        else
+        if (GetTime() > g_advancedSettings.m_videoIgnoreSecondsAtStart)
+        {
+          // Update the bookmark
+          m_progressTrackingVideoResumeBookmark.timeInSeconds = GetTime();
+          m_progressTrackingVideoResumeBookmark.totalTimeInSeconds = GetTotalTime();
+        }
+        else
+        {
+          // Do nothing
+          m_progressTrackingVideoResumeBookmark.timeInSeconds = 0.0f;
+        }
+      }
+    }
+  }
+}
+
+void CApplication::StopPlaying()
+{
+  int iWin = g_windowManager.GetActiveWindow();
+  if ( IsPlaying() )
+  {
+#ifdef HAS_KARAOKE
+    if( m_pKaraokeMgr )
+      m_pKaraokeMgr->Stop();
+#endif
+
+    if (g_PVRManager.IsPlayingTV() || g_PVRManager.IsPlayingRadio())
+      g_PVRManager.SaveCurrentChannelSettings();
+
+    if (m_pPlayer)
+      m_pPlayer->CloseFile();
+
+    // turn off visualisation window when stopping
+    if ((iWin == WINDOW_VISUALISATION
+    ||  iWin == WINDOW_FULLSCREEN_VIDEO)
+    && !m_bStop)
+      g_windowManager.PreviousWindow();
+
+    g_partyModeManager.Disable();
+  }
+}
+
+void CApplication::ResetSystemIdleTimer()
+{
+  // reset system idle timer
+  m_idleTimer.StartZero();
+}
+
+void CApplication::ResetScreenSaver()
+{
+  // reset our timers
+  m_shutdownTimer.StartZero();
+
+  // screen saver timer is reset only if we're not already in screensaver or
+  // DPMS mode
+  if ((!m_bScreenSave && m_iScreenSaveLock == 0) && !m_dpmsIsActive)
+    ResetScreenSaverTimer();
+}
+
+void CApplication::ResetScreenSaverTimer()
+{
+  m_screenSaverTimer.StartZero();
+}
+
+void CApplication::StopScreenSaverTimer()
+{
+  m_screenSaverTimer.Stop();
+}
+
+bool CApplication::ToggleDPMS(bool manual)
+{
+  if (manual || (m_dpmsIsManual == manual))
+  {
+    if (m_dpmsIsActive)
+    {
+      m_dpmsIsActive = false;
+      m_dpmsIsManual = false;
+      return m_dpms->DisablePowerSaving();
+    }
+    else
+    {
+      if (m_dpms->EnablePowerSaving(m_dpms->GetSupportedModes()[0]))
+      {
+        m_dpmsIsActive = true;
+        m_dpmsIsManual = manual;
+        return true;
+      }
+    }
+  }
+  return false;
+}
+
+bool CApplication::WakeUpScreenSaverAndDPMS(bool bPowerOffKeyPressed /* = false */)
+{
+  bool result;
+
+#ifdef HAS_LCD
+    // turn on lcd backlight
+    if (g_lcd && g_advancedSettings.m_lcdDimOnScreenSave)
+      g_lcd->SetBackLight(1);
+#endif
+
+  // First reset DPMS, if active
+  if (m_dpmsIsActive)
+  {
+    if (m_dpmsIsManual)
+      return false;
+    // TODO: if screensaver lock is specified but screensaver is not active
+    // (DPMS came first), activate screensaver now.
+    ToggleDPMS(false);
+    ResetScreenSaverTimer();
+    result = !m_bScreenSave || WakeUpScreenSaver(bPowerOffKeyPressed);
+  }
+  else
+    result = WakeUpScreenSaver(bPowerOffKeyPressed);
+
+  if(result)
+  {
+    // allow listeners to ignore the deactivation if it preceeds a powerdown/suspend etc
+    CVariant data(bPowerOffKeyPressed);
+    CAnnouncementManager::Announce(GUI, "xbmc", "OnScreensaverDeactivated", data);
+  }
+
+  return result;
+}
+
+bool CApplication::WakeUpScreenSaver(bool bPowerOffKeyPressed /* = false */)
+{
+  if (m_iScreenSaveLock == 2)
+    return false;
+
+  // if Screen saver is active
+  if (m_bScreenSave && m_screenSaver)
+  {
+    if (m_iScreenSaveLock == 0)
+      if (g_settings.GetMasterProfile().getLockMode() != LOCK_MODE_EVERYONE &&
+          (g_settings.UsingLoginScreen() || g_guiSettings.GetBool("masterlock.startuplock")) &&
+          g_settings.GetCurrentProfile().getLockMode() != LOCK_MODE_EVERYONE &&
+          m_screenSaver->ID() != "screensaver.xbmc.builtin.dim" && m_screenSaver->ID() != "screensaver.xbmc.builtin.black" && !m_screenSaver->ID().empty() && m_screenSaver->ID() != "visualization")
+      {
+        m_iScreenSaveLock = 2;
+        CGUIMessage msg(GUI_MSG_CHECK_LOCK,0,0);
+
+        CGUIWindow* pWindow = g_windowManager.GetWindow(WINDOW_SCREENSAVER);
+        if (pWindow)
+          pWindow->OnMessage(msg);
+      }
+    if (m_iScreenSaveLock == -1)
+    {
+      m_iScreenSaveLock = 0;
+      return true;
+    }
+
+    // disable screensaver
+    m_bScreenSave = false;
+    m_iScreenSaveLock = 0;
+    ResetScreenSaverTimer();
+
+    if (m_screenSaver->ID() == "visualization")
+    {
+      // we can just continue as usual from vis mode
+      return false;
+    }
+    else if (m_screenSaver->ID() == "screensaver.xbmc.builtin.dim" || m_screenSaver->ID() == "screensaver.xbmc.builtin.black" || m_screenSaver->ID().empty())
+      return true;
+    else if (!m_screenSaver->ID().IsEmpty())
+    { // we're in screensaver window
+      if (g_windowManager.GetActiveWindow() == WINDOW_SCREENSAVER)
+        g_windowManager.PreviousWindow();  // show the previous window
+      if (g_windowManager.GetActiveWindow() == WINDOW_SLIDESHOW)
+        CApplicationMessenger::Get().SendAction(CAction(ACTION_STOP), WINDOW_SLIDESHOW);
+    }
+    return true;
+  }
+  else
+    return false;
+}
+
+void CApplication::CheckScreenSaverAndDPMS()
+{
+  if (!m_dpmsIsActive)
+    g_Windowing.ResetOSScreensaver();
+
+  bool maybeScreensaver =
+      !m_dpmsIsActive && !m_bScreenSave
+      && !g_guiSettings.GetString("screensaver.mode").IsEmpty();
+  bool maybeDPMS =
+      !m_dpmsIsActive && m_dpms->IsSupported()
+      && g_guiSettings.GetInt("powermanagement.displaysoff") > 0;
+
+  // Has the screen saver window become active?
+  if (maybeScreensaver && g_windowManager.IsWindowActive(WINDOW_SCREENSAVER))
+  {
+    m_bScreenSave = true;
+    maybeScreensaver = false;
+  }
+
+  if (m_bScreenSave && IsPlayingVideo() && !m_pPlayer->IsPaused())
+  {
+    WakeUpScreenSaverAndDPMS();
+    return;
+  }
+
+  if (!maybeScreensaver && !maybeDPMS) return;  // Nothing to do.
+
+  // See if we need to reset timer.
+  // * Are we playing a video and it is not paused?
+  if ((IsPlayingVideo() && !m_pPlayer->IsPaused())
+      // * Are we playing some music in fullscreen vis?
+      || (IsPlayingAudio() && g_windowManager.GetActiveWindow() == WINDOW_VISUALISATION
+          && !g_guiSettings.GetString("musicplayer.visualisation").IsEmpty()))
+  {
+    ResetScreenSaverTimer();
+    return;
+  }
+
+  float elapsed = m_screenSaverTimer.GetElapsedSeconds();
+
+  // DPMS has priority (it makes the screensaver not needed)
+  if (maybeDPMS
+      && elapsed > g_guiSettings.GetInt("powermanagement.displaysoff") * 60)
+  {
+    ToggleDPMS(false);
+    WakeUpScreenSaver();
+  }
+  else if (maybeScreensaver
+           && elapsed > g_guiSettings.GetInt("screensaver.time") * 60)
+  {
+    ActivateScreenSaver();
+  }
+}
+
+// activate the screensaver.
+// if forceType is true, we ignore the various conditions that can alter
+// the type of screensaver displayed
+void CApplication::ActivateScreenSaver(bool forceType /*= false */)
+{
+  m_bScreenSave = true;
+
+  // Get Screensaver Mode
+  m_screenSaver.reset();
+  if (!CAddonMgr::Get().GetAddon(g_guiSettings.GetString("screensaver.mode"), m_screenSaver))
+    m_screenSaver.reset(new CScreenSaver(""));
+
+#ifdef HAS_LCD
+  // turn off lcd backlight if requested
+  if (g_lcd && g_advancedSettings.m_lcdDimOnScreenSave)
+    g_lcd->SetBackLight(0);
+#endif
+
+  CAnnouncementManager::Announce(GUI, "xbmc", "OnScreensaverActivated");
+
+  // disable screensaver lock from the login screen
+  m_iScreenSaveLock = g_windowManager.GetActiveWindow() == WINDOW_LOGIN_SCREEN ? 1 : 0;
+  if (!forceType)
+  {
+    // set to Dim in the case of a dialog on screen or playing video
+    if (g_windowManager.HasModalDialog() || (IsPlayingVideo() && g_guiSettings.GetBool("screensaver.usedimonpause")) || g_PVRManager.IsRunningChannelScan())
+    {
+      if (!CAddonMgr::Get().GetAddon("screensaver.xbmc.builtin.dim", m_screenSaver))
+        m_screenSaver.reset(new CScreenSaver(""));
+    }
+    // Check if we are Playing Audio and Vis instead Screensaver!
+    else if (IsPlayingAudio() && g_guiSettings.GetBool("screensaver.usemusicvisinstead") && !g_guiSettings.GetString("musicplayer.visualisation").IsEmpty())
+    { // activate the visualisation
+      m_screenSaver.reset(new CScreenSaver("visualization"));
+      g_windowManager.ActivateWindow(WINDOW_VISUALISATION);
+      return;
+    }
+  }
+  if (m_screenSaver->ID() == "screensaver.xbmc.builtin.dim" || m_screenSaver->ID().empty())
+    return;
+  else if (m_screenSaver->ID() == "screensaver.xbmc.builtin.black")
+    return;
+  else if (!m_screenSaver->ID().IsEmpty())
+    g_windowManager.ActivateWindow(WINDOW_SCREENSAVER);
+}
+
+void CApplication::CheckShutdown()
+{
+  // first check if we should reset the timer
+  bool resetTimer = m_bInhibitIdleShutdown;
+
+  if (IsPlaying() || IsPaused()) // is something playing?
+    resetTimer = true;
+
+  if (m_musicInfoScanner->IsScanning())
+    resetTimer = true;
+
+  if (m_videoInfoScanner->IsScanning())
+    resetTimer = true;
+
+  if (g_windowManager.IsWindowActive(WINDOW_DIALOG_PROGRESS)) // progress dialog is onscreen
+    resetTimer = true;
+
+  if (g_guiSettings.GetBool("pvrmanager.enabled") &&  !g_PVRManager.IsIdle())
+    resetTimer = true;
+
+  if (resetTimer)
+  {
+    m_shutdownTimer.StartZero();
+    return;
+  }
+
+  if ( m_shutdownTimer.GetElapsedSeconds() > g_guiSettings.GetInt("powermanagement.shutdowntime") * 60 )
+  {
+    // Since it is a sleep instead of a shutdown, let's set everything to reset when we wake up.
+    m_shutdownTimer.Stop();
+
+    // Sleep the box
+    CApplicationMessenger::Get().Shutdown();
+  }
+}
+
+void CApplication::InhibitIdleShutdown(bool inhibit)
+{
+  m_bInhibitIdleShutdown = inhibit;
+}
+
+bool CApplication::IsIdleShutdownInhibited() const
+{
+  return m_bInhibitIdleShutdown;
+}
+
+bool CApplication::OnMessage(CGUIMessage& message)
+{
+  switch ( message.GetMessage() )
+  {
+  case GUI_MSG_NOTIFY_ALL:
+    {
+      if (message.GetParam1()==GUI_MSG_REMOVED_MEDIA)
+      {
+        // Update general playlist: Remove DVD playlist items
+        int nRemoved = g_playlistPlayer.RemoveDVDItems();
+        if ( nRemoved > 0 )
+        {
+          CGUIMessage msg( GUI_MSG_PLAYLIST_CHANGED, 0, 0 );
+          g_windowManager.SendMessage( msg );
+        }
+        // stop the file if it's on dvd (will set the resume point etc)
+        if (m_itemCurrentFile->IsOnDVD())
+          StopPlaying();
+      }
+    }
+    break;
+
+  case GUI_MSG_PLAYBACK_STARTED:
+    {
+#ifdef TARGET_DARWIN
+      DarwinSetScheduling(message.GetMessage());
+#endif
+      // reset the seek handler
+      m_seekHandler->Reset();
+      CPlayList playList = g_playlistPlayer.GetPlaylist(g_playlistPlayer.GetCurrentPlaylist());
+
+      // Update our infoManager with the new details etc.
+      if (m_nextPlaylistItem >= 0)
+      { 
+        // playing an item which is not in the list - player might be stopped already
+        // so do nothing
+        if (playList.size() <= m_nextPlaylistItem)
+          return true;
+
+        // we've started a previously queued item
+        CFileItemPtr item = playList[m_nextPlaylistItem];
+        // update the playlist manager
+        int currentSong = g_playlistPlayer.GetCurrentSong();
+        int param = ((currentSong & 0xffff) << 16) | (m_nextPlaylistItem & 0xffff);
+        CGUIMessage msg(GUI_MSG_PLAYLISTPLAYER_CHANGED, 0, 0, g_playlistPlayer.GetCurrentPlaylist(), param, item);
+        g_windowManager.SendThreadMessage(msg);
+        g_playlistPlayer.SetCurrentSong(m_nextPlaylistItem);
+        *m_itemCurrentFile = *item;
+      }
+      g_infoManager.SetCurrentItem(*m_itemCurrentFile);
+      CLastFmManager::GetInstance()->OnSongChange(*m_itemCurrentFile);
+      g_partyModeManager.OnSongChange(true);
+
+      CVariant param;
+      param["player"]["speed"] = 1;
+      param["player"]["playerid"] = g_playlistPlayer.GetCurrentPlaylist();
+      CAnnouncementManager::Announce(Player, "xbmc", "OnPlay", m_itemCurrentFile, param);
+
+      DimLCDOnPlayback(true);
+
+      if (IsPlayingAudio())
+      {
+        // Start our cdg parser as appropriate
+#ifdef HAS_KARAOKE
+        if (m_pKaraokeMgr && g_guiSettings.GetBool("karaoke.enabled") && !m_itemCurrentFile->IsInternetStream())
+        {
+          m_pKaraokeMgr->Stop();
+          if (m_itemCurrentFile->IsMusicDb())
+          {
+            if (!m_itemCurrentFile->HasMusicInfoTag() || !m_itemCurrentFile->GetMusicInfoTag()->Loaded())
+            {
+              IMusicInfoTagLoader* tagloader = CMusicInfoTagLoaderFactory::CreateLoader(m_itemCurrentFile->GetPath());
+              tagloader->Load(m_itemCurrentFile->GetPath(),*m_itemCurrentFile->GetMusicInfoTag());
+              delete tagloader;
+            }
+            m_pKaraokeMgr->Start(m_itemCurrentFile->GetMusicInfoTag()->GetURL());
+          }
+          else
+            m_pKaraokeMgr->Start(m_itemCurrentFile->GetPath());
+        }
+#endif
+        // Let scrobbler know about the track
+        const CMusicInfoTag* tag=g_infoManager.GetCurrentSongTag();
+        if (tag)
+        {
+          CLastfmScrobbler::GetInstance()->AddSong(*tag, CLastFmManager::GetInstance()->IsRadioEnabled());
+          CLibrefmScrobbler::GetInstance()->AddSong(*tag, CLastFmManager::GetInstance()->IsRadioEnabled());
+        }
+      }
+
+      return true;
+    }
+    break;
+
+  case GUI_MSG_QUEUE_NEXT_ITEM:
+    {
+      // Check to see if our playlist player has a new item for us,
+      // and if so, we check whether our current player wants the file
+      int iNext = g_playlistPlayer.GetNextSong();
+      CPlayList& playlist = g_playlistPlayer.GetPlaylist(g_playlistPlayer.GetCurrentPlaylist());
+      if (iNext < 0 || iNext >= playlist.size())
+      {
+        if (m_pPlayer) m_pPlayer->OnNothingToQueueNotify();
+        return true; // nothing to do
+      }
+
+      // ok, grab the next song
+      CFileItem file(*playlist[iNext]);
+      // handle plugin://
+      CURL url(file.GetPath());
+      if (url.GetProtocol() == "plugin")
+        XFILE::CPluginDirectory::GetPluginResult(url.Get(), file);
+
+#ifdef HAS_UPNP
+      if (URIUtils::IsUPnP(file.GetPath()))
+      {
+        if (!XFILE::CUPnPDirectory::GetResource(file.GetPath(), file))
+          return true;
+      }
+#endif
+
+      // ok - send the file to the player, if it accepts it
+      if (m_pPlayer)
+      {
+        if (m_pPlayer->QueueNextFile(file))
+        {
+          // player accepted the next file
+          m_nextPlaylistItem = iNext;
+        }
+        else
+        {
+          /* Player didn't accept next file: *ALWAYS* advance playlist in this case so the player can
+             queue the next (if it wants to) and it doesn't keep looping on this song */
+          g_playlistPlayer.SetCurrentSong(iNext);
+        }
+      }
+
+      return true;
+    }
+    break;
+
+  case GUI_MSG_PLAYBACK_STOPPED:
+  case GUI_MSG_PLAYBACK_ENDED:
+  case GUI_MSG_PLAYLISTPLAYER_STOPPED:
+    {
+#ifdef HAS_KARAOKE
+      if (m_pKaraokeMgr )
+        m_pKaraokeMgr->Stop();
+#endif
+#ifdef TARGET_DARWIN
+      DarwinSetScheduling(message.GetMessage());
+#endif
+      // first check if we still have items in the stack to play
+      if (message.GetMessage() == GUI_MSG_PLAYBACK_ENDED)
+      {
+        if (m_itemCurrentFile->IsStack() && m_currentStack->Size() > 0 && m_currentStackPosition < m_currentStack->Size() - 1)
+        { // just play the next item in the stack
+          PlayFile(*(*m_currentStack)[++m_currentStackPosition], true);
+          return true;
+        }
+      }
+
+      // In case playback ended due to user eg. skipping over the end, clear
+      // our resume bookmark here
+      if (message.GetMessage() == GUI_MSG_PLAYBACK_ENDED && m_progressTrackingPlayCountUpdate && g_advancedSettings.m_videoIgnorePercentAtEnd > 0)
+      {
+        // Delete the bookmark
+        m_progressTrackingVideoResumeBookmark.timeInSeconds = -1.0f;
+      }
+
+      // reset the current playing file
+      m_itemCurrentFile->Reset();
+      g_infoManager.ResetCurrentItem();
+      m_currentStack->Clear();
+
+      if (message.GetMessage() == GUI_MSG_PLAYBACK_ENDED)
+      {
+        g_playlistPlayer.PlayNext(1, true);
+      }
+      else
+      {
+        // stop lastfm
+        if (CLastFmManager::GetInstance()->IsRadioEnabled())
+          CLastFmManager::GetInstance()->StopRadio();
+
+        delete m_pPlayer;
+        m_pPlayer = 0;
+
+        // Reset playspeed
+        m_iPlaySpeed = 1;
+      }
+
+      if (!IsPlaying())
+      {
+        g_audioManager.Enable(true);
+        DimLCDOnPlayback(false);
+      }
+
+      if (!IsPlayingVideo())
+      {
+        if(g_windowManager.GetActiveWindow() == WINDOW_FULLSCREEN_VIDEO)
+        {
+          g_windowManager.PreviousWindow();
+        }
+        else
+        {
+          CSingleLock lock(g_graphicsContext);
+          //  resets to res_desktop or look&feel resolution (including refreshrate)
+          g_graphicsContext.SetFullScreenVideo(false);
+        }
+      }
+
+      if (!IsPlayingAudio() && g_playlistPlayer.GetCurrentPlaylist() == PLAYLIST_NONE && g_windowManager.GetActiveWindow() == WINDOW_VISUALISATION)
+      {
+        g_settings.Save();  // save vis settings
+        WakeUpScreenSaverAndDPMS();
+        g_windowManager.PreviousWindow();
+      }
+
+      // DVD ejected while playing in vis ?
+      if (!IsPlayingAudio() && (m_itemCurrentFile->IsCDDA() || m_itemCurrentFile->IsOnDVD()) && !g_mediaManager.IsDiscInDrive() && g_windowManager.GetActiveWindow() == WINDOW_VISUALISATION)
+      {
+        // yes, disable vis
+        g_settings.Save();    // save vis settings
+        WakeUpScreenSaverAndDPMS();
+        g_windowManager.PreviousWindow();
+      }
+
+      if (IsEnableTestMode())
+        CApplicationMessenger::Get().Quit();
+      return true;
+    }
+    break;
+
+  case GUI_MSG_PLAYLISTPLAYER_STARTED:
+  case GUI_MSG_PLAYLISTPLAYER_CHANGED:
+    {
+      return true;
+    }
+    break;
+  case GUI_MSG_FULLSCREEN:
+    { // Switch to fullscreen, if we can
+      SwitchToFullScreen();
+      return true;
+    }
+    break;
+  case GUI_MSG_EXECUTE:
+    if (message.GetNumStringParams())
+      return ExecuteXBMCAction(message.GetStringParam());
+    break;
+  }
+  return false;
+}
+
+bool CApplication::ExecuteXBMCAction(std::string actionStr)
+{
+  // see if it is a user set string
+  CLog::Log(LOGDEBUG,"%s : Translating %s", __FUNCTION__, actionStr.c_str());
+  CGUIInfoLabel info(actionStr, "");
+  actionStr = info.GetLabel(0);
+  CLog::Log(LOGDEBUG,"%s : To %s", __FUNCTION__, actionStr.c_str());
+
+  // user has asked for something to be executed
+  if (CBuiltins::HasCommand(actionStr))
+    CBuiltins::Execute(actionStr);
+  else
+  {
+    // try translating the action from our ButtonTranslator
+    int actionID;
+    if (CButtonTranslator::TranslateActionString(actionStr.c_str(), actionID))
+    {
+      OnAction(CAction(actionID));
+      return true;
+    }
+    CFileItem item(actionStr, false);
+#ifdef HAS_PYTHON
+    if (item.IsPythonScript())
+    { // a python script
+      g_pythonParser.evalFile(item.GetPath().c_str(),ADDON::AddonPtr());
+    }
+    else
+#endif
+    if (item.IsAudio() || item.IsVideo())
+    { // an audio or video file
+      PlayFile(item);
+    }
+    else
+      return false;
+  }
+  return true;
+}
+
+void CApplication::Process()
+{
+  MEASURE_FUNCTION;
+
+  // dispatch the messages generated by python or other threads to the current window
+  g_windowManager.DispatchThreadMessages();
+
+  // process messages which have to be send to the gui
+  // (this can only be done after g_windowManager.Render())
+  CApplicationMessenger::Get().ProcessWindowMessages();
+
+#ifdef HAS_PYTHON
+  // process any Python scripts
+  g_pythonParser.Process();
+#endif
+
+  // process messages, even if a movie is playing
+  CApplicationMessenger::Get().ProcessMessages();
+  if (g_application.m_bStop) return; //we're done, everything has been unloaded
+
+  // check how far we are through playing the current item
+  // and do anything that needs doing (lastfm submission, playcount updates etc)
+  CheckPlayingProgress();
+
+  // update sound
+  if (m_pPlayer)
+    m_pPlayer->DoAudioWork();
+
+  // do any processing that isn't needed on each run
+  if( m_slowTimer.GetElapsedMilliseconds() > 500 )
+  {
+    m_slowTimer.Reset();
+    ProcessSlow();
+  }
+
+  g_cpuInfo.getUsedPercentage(); // must call it to recalculate pct values
+}
+
+// We get called every 500ms
+void CApplication::ProcessSlow()
+{
+  g_powerManager.ProcessEvents();
+
+#if defined(TARGET_DARWIN_OSX)
+  // There is an issue on OS X that several system services ask the cursor to become visible
+  // during their startup routines.  Given that we can't control this, we hack it in by
+  // forcing the
+  if (g_Windowing.IsFullScreen())
+  { // SDL thinks it's hidden
+    Cocoa_HideMouse();
+  }
+#endif
+
+  // Store our file state for use on close()
+  UpdateFileState();
+
+  if (IsPlayingAudio())
+  {
+    CLastfmScrobbler::GetInstance()->UpdateStatus();
+    CLibrefmScrobbler::GetInstance()->UpdateStatus();
+  }
+
+  // Check if we need to activate the screensaver / DPMS.
+  CheckScreenSaverAndDPMS();
+
+  // Check if we need to shutdown (if enabled).
+#if defined(TARGET_DARWIN)
+  if (g_guiSettings.GetInt("powermanagement.shutdowntime") && g_advancedSettings.m_fullScreen)
+#else
+  if (g_guiSettings.GetInt("powermanagement.shutdowntime"))
+#endif
+  {
+    CheckShutdown();
+  }
+
+  // check if we should restart the player
+  CheckDelayedPlayerRestart();
+
+  //  check if we can unload any unreferenced dlls or sections
+  if (!IsPlayingVideo())
+    CSectionLoader::UnloadDelayed();
+
+  // check for any idle curl connections
+  g_curlInterface.CheckIdle();
+
+  // check for any idle myth sessions
+  CMythSession::CheckIdle();
+
+#ifdef HAS_FILESYSTEM_HTSP
+  // check for any idle htsp sessions
+  HTSP::CHTSPDirectorySession::CheckIdle();
+#endif
+
+#ifdef HAS_KARAOKE
+  if ( m_pKaraokeMgr )
+    m_pKaraokeMgr->ProcessSlow();
+#endif
+
+  // LED - LCD SwitchOn On Paused! m_bIsPaused=TRUE -> LED/LCD is ON!
+  if(IsPaused() != m_bIsPaused)
+  {
+#ifdef HAS_LCD
+    DimLCDOnPlayback(m_bIsPaused);
+#endif
+    m_bIsPaused = IsPaused();
+  }
+
+  if (!IsPlayingVideo())
+    g_largeTextureManager.CleanupUnusedImages();
+
+  g_TextureManager.FreeUnusedTextures();
+
+#ifdef HAS_DVD_DRIVE
+  // checks whats in the DVD drive and tries to autostart the content (xbox games, dvd, cdda, avi files...)
+  if (!IsPlayingVideo())
+    m_Autorun->HandleAutorun();
+#endif
+
+  // update upnp server/renderer states
+#ifdef HAS_UPNP
+  if(UPNP::CUPnP::IsInstantiated())
+    UPNP::CUPnP::GetInstance()->UpdateState();
+#endif
+
+#if defined(_LINUX) && defined(HAS_FILESYSTEM_SMB)
+  smb.CheckIfIdle();
+#endif
+
+#ifdef HAS_FILESYSTEM_NFS
+  gNfsConnection.CheckIfIdle();
+#endif
+
+#ifdef HAS_FILESYSTEM_AFP
+  gAfpConnection.CheckIfIdle();
+#endif
+
+#ifdef HAS_FILESYSTEM_SFTP
+  CSFTPSessionManager::ClearOutIdleSessions();
+#endif
+
+  g_mediaManager.ProcessEvents();
+
+#ifdef HAS_LIRC
+  if (g_RemoteControl.IsInUse() && !g_RemoteControl.IsInitialized())
+    g_RemoteControl.Initialize();
+#endif
+
+#ifdef HAS_LCD
+  // attempt to reinitialize the LCD (e.g. after resuming from sleep)
+  if (!IsPlayingVideo())
+  {
+    if (g_lcd && !g_lcd->IsConnected())
+    {
+      g_lcd->Stop();
+      g_lcd->Initialize();
+    }
+  }
+#endif
+
+  if (!IsPlayingVideo())
+    CAddonInstaller::Get().UpdateRepos();
+
+  CAEFactory::GarbageCollect();
+}
+
+// Global Idle Time in Seconds
+// idle time will be resetet if on any OnKey()
+// int return: system Idle time in seconds! 0 is no idle!
+int CApplication::GlobalIdleTime()
+{
+  if(!m_idleTimer.IsRunning())
+  {
+    m_idleTimer.Stop();
+    m_idleTimer.StartZero();
+  }
+  return (int)m_idleTimer.GetElapsedSeconds();
+}
+
+float CApplication::NavigationIdleTime()
+{
+  if (!m_navigationTimer.IsRunning())
+  {
+    m_navigationTimer.Stop();
+    m_navigationTimer.StartZero();
+  }
+  return m_navigationTimer.GetElapsedSeconds();
+}
+
+void CApplication::DelayedPlayerRestart()
+{
+  m_restartPlayerTimer.StartZero();
+}
+
+void CApplication::CheckDelayedPlayerRestart()
+{
+  if (m_restartPlayerTimer.GetElapsedSeconds() > 3)
+  {
+    m_restartPlayerTimer.Stop();
+    m_restartPlayerTimer.Reset();
+    Restart(true);
+  }
+}
+
+void CApplication::Restart(bool bSamePosition)
+{
+  // this function gets called when the user changes a setting (like noninterleaved)
+  // and which means we gotta close & reopen the current playing file
+
+  // first check if we're playing a file
+  if ( !IsPlayingVideo() && !IsPlayingAudio())
+    return ;
+
+  if( !m_pPlayer )
+    return ;
+
+  SaveFileState();
+
+  // do we want to return to the current position in the file
+  if (false == bSamePosition)
+  {
+    // no, then just reopen the file and start at the beginning
+    PlayFile(*m_itemCurrentFile, true);
+    return ;
+  }
+
+  // else get current position
+  double time = GetTime();
+
+  // get player state, needed for dvd's
+  CStdString state = m_pPlayer->GetPlayerState();
+
+  // set the requested starttime
+  m_itemCurrentFile->m_lStartOffset = (long)(time * 75.0);
+
+  // reopen the file
+  if ( PlayFile(*m_itemCurrentFile, true) && m_pPlayer )
+    m_pPlayer->SetPlayerState(state);
+}
+
+const CStdString& CApplication::CurrentFile()
+{
+  return m_itemCurrentFile->GetPath();
+}
+
+CFileItem& CApplication::CurrentFileItem()
+{
+  return *m_itemCurrentFile;
+}
+
+void CApplication::ShowVolumeBar(const CAction *action)
+{
+  CGUIDialog *volumeBar = (CGUIDialog *)g_windowManager.GetWindow(WINDOW_DIALOG_VOLUME_BAR);
+  if (volumeBar)
+  {
+    volumeBar->Show();
+    if (action)
+      volumeBar->OnAction(*action);
+  }
+}
+
+bool CApplication::IsMuted() const
+{
+  if (g_peripherals.IsMuted())
+    return true;
+  return CAEFactory::IsMuted();
+}
+
+void CApplication::ToggleMute(void)
+{
+  if (g_settings.m_bMute)
+    UnMute();
+  else
+    Mute();
+}
+
+void CApplication::Mute()
+{
+  if (g_peripherals.Mute())
+    return;
+
+  CAEFactory::SetMute(true);
+  g_settings.m_bMute = true;
+  VolumeChanged();
+}
+
+void CApplication::UnMute()
+{
+  if (g_peripherals.UnMute())
+    return;
+
+  CAEFactory::SetMute(false);
+  g_settings.m_bMute = false;
+  VolumeChanged();
+}
+
+void CApplication::SetVolume(float iValue, bool isPercentage/*=true*/)
+{
+  float hardwareVolume = iValue;
+
+  if(isPercentage)
+    hardwareVolume /= 100.0f;
+
+  SetHardwareVolume(hardwareVolume);
+  VolumeChanged();
+}
+
+void CApplication::SetHardwareVolume(float hardwareVolume)
+{
+  hardwareVolume = std::max(VOLUME_MINIMUM, std::min(VOLUME_MAXIMUM, hardwareVolume));
+  g_settings.m_fVolumeLevel = hardwareVolume;
+
+  float value = 0.0f;
+  if (hardwareVolume > VOLUME_MINIMUM)
+  {
+    float dB = CAEUtil::PercentToGain(hardwareVolume);
+    value = CAEUtil::GainToScale(dB);
+  }
+  if (value >= 0.99f)
+    value = 1.0f;
+
+  CAEFactory::SetVolume(value);
+}
+
+int CApplication::GetVolume() const
+{
+  // converts the hardware volume to a percentage
+  return (int)(g_settings.m_fVolumeLevel * 100.0f);
+}
+
+void CApplication::VolumeChanged() const
+{
+  CVariant data(CVariant::VariantTypeObject);
+  data["volume"] = GetVolume();
+  data["muted"] = g_settings.m_bMute;
+  CAnnouncementManager::Announce(Application, "xbmc", "OnVolumeChanged", data);
+
+  // if player has volume control, set it.
+  if (m_pPlayer && m_pPlayer->ControlsVolume())
+  {
+     m_pPlayer->SetVolume(g_settings.m_fVolumeLevel);
+     m_pPlayer->SetMute(g_settings.m_bMute);
+  }
+}
+
+int CApplication::GetSubtitleDelay() const
+{
+  // converts subtitle delay to a percentage
+  return int(((float)(g_settings.m_currentVideoSettings.m_SubtitleDelay + g_advancedSettings.m_videoSubsDelayRange)) / (2 * g_advancedSettings.m_videoSubsDelayRange)*100.0f + 0.5f);
+}
+
+int CApplication::GetAudioDelay() const
+{
+  // converts subtitle delay to a percentage
+  return int(((float)(g_settings.m_currentVideoSettings.m_AudioDelay + g_advancedSettings.m_videoAudioDelayRange)) / (2 * g_advancedSettings.m_videoAudioDelayRange)*100.0f + 0.5f);
+}
+
+void CApplication::SetPlaySpeed(int iSpeed)
+{
+  if (!IsPlayingAudio() && !IsPlayingVideo())
+    return ;
+  if (m_iPlaySpeed == iSpeed)
+    return ;
+  if (!m_pPlayer->CanSeek())
+    return;
+  if (m_pPlayer->IsPaused())
+  {
+    if (
+      ((m_iPlaySpeed > 1) && (iSpeed > m_iPlaySpeed)) ||
+      ((m_iPlaySpeed < -1) && (iSpeed < m_iPlaySpeed))
+    )
+    {
+      iSpeed = m_iPlaySpeed; // from pause to ff/rw, do previous ff/rw speed
+    }
+    m_pPlayer->Pause();
+  }
+  m_iPlaySpeed = iSpeed;
+
+  m_pPlayer->ToFFRW(m_iPlaySpeed);
+
+  // if player has volume control, set it.
+  if (m_pPlayer->ControlsVolume())
+  {
+    if (m_iPlaySpeed == 1)
+    { // restore volume
+      m_pPlayer->SetVolume(VOLUME_MAXIMUM);
+    }
+    else
+    { // mute volume
+      m_pPlayer->SetVolume(VOLUME_MINIMUM);
+    }
+    m_pPlayer->SetMute(g_settings.m_bMute);
+  }
+}
+
+int CApplication::GetPlaySpeed() const
+{
+  return m_iPlaySpeed;
+}
+
+// Returns the total time in seconds of the current media.  Fractional
+// portions of a second are possible - but not necessarily supported by the
+// player class.  This returns a double to be consistent with GetTime() and
+// SeekTime().
+double CApplication::GetTotalTime() const
+{
+  double rc = 0.0;
+
+  if (IsPlaying() && m_pPlayer)
+  {
+    if (m_itemCurrentFile->IsStack() && m_currentStack->Size() > 0)
+      rc = (*m_currentStack)[m_currentStack->Size() - 1]->m_lEndOffset;
+    else
+      rc = static_cast<double>(m_pPlayer->GetTotalTime() * 0.001f);
+  }
+
+  return rc;
+}
+
+void CApplication::StopShutdownTimer()
+{
+  if (m_shutdownTimer.IsRunning())
+    m_shutdownTimer.Stop();
+}
+
+void CApplication::ResetShutdownTimers()
+{
+  // reset system shutdown timer
+  m_shutdownTimer.StartZero();
+
+  // delete custom shutdown timer
+  if (g_alarmClock.HasAlarm("shutdowntimer"))
+    g_alarmClock.Stop("shutdowntimer", true);
+}
+
+// Returns the current time in seconds of the currently playing media.
+// Fractional portions of a second are possible.  This returns a double to
+// be consistent with GetTotalTime() and SeekTime().
+double CApplication::GetTime() const
+{
+  double rc = 0.0;
+
+  if (IsPlaying() && m_pPlayer)
+  {
+    if (m_itemCurrentFile->IsStack() && m_currentStack->Size() > 0)
+    {
+      long startOfCurrentFile = (m_currentStackPosition > 0) ? (*m_currentStack)[m_currentStackPosition-1]->m_lEndOffset : 0;
+      rc = (double)startOfCurrentFile + m_pPlayer->GetTime() * 0.001;
+    }
+    else
+      rc = static_cast<double>(m_pPlayer->GetTime() * 0.001f);
+  }
+
+  return rc;
+}
+
+// Sets the current position of the currently playing media to the specified
+// time in seconds.  Fractional portions of a second are valid.  The passed
+// time is the time offset from the beginning of the file as opposed to a
+// delta from the current position.  This method accepts a double to be
+// consistent with GetTime() and GetTotalTime().
+void CApplication::SeekTime( double dTime )
+{
+  if (IsPlaying() && m_pPlayer && (dTime >= 0.0))
+  {
+    if (!m_pPlayer->CanSeek()) return;
+    if (m_itemCurrentFile->IsStack() && m_currentStack->Size() > 0)
+    {
+      // find the item in the stack we are seeking to, and load the new
+      // file if necessary, and calculate the correct seek within the new
+      // file.  Otherwise, just fall through to the usual routine if the
+      // time is higher than our total time.
+      for (int i = 0; i < m_currentStack->Size(); i++)
+      {
+        if ((*m_currentStack)[i]->m_lEndOffset > dTime)
+        {
+          long startOfNewFile = (i > 0) ? (*m_currentStack)[i-1]->m_lEndOffset : 0;
+          if (m_currentStackPosition == i)
+            m_pPlayer->SeekTime((int64_t)((dTime - startOfNewFile) * 1000.0));
+          else
+          { // seeking to a new file
+            m_currentStackPosition = i;
+            CFileItem item(*(*m_currentStack)[i]);
+            item.m_lStartOffset = (long)((dTime - startOfNewFile) * 75.0);
+            // don't just call "PlayFile" here, as we are quite likely called from the
+            // player thread, so we won't be able to delete ourselves.
+            CApplicationMessenger::Get().PlayFile(item, true);
+          }
+          return;
+        }
+      }
+    }
+    // convert to milliseconds and perform seek
+    m_pPlayer->SeekTime( static_cast<int64_t>( dTime * 1000.0 ) );
+  }
+}
+
+float CApplication::GetPercentage() const
+{
+  if (IsPlaying() && m_pPlayer)
+  {
+    if (m_pPlayer->GetTotalTime() == 0 && IsPlayingAudio() && m_itemCurrentFile->HasMusicInfoTag())
+    {
+      const CMusicInfoTag& tag = *m_itemCurrentFile->GetMusicInfoTag();
+      if (tag.GetDuration() > 0)
+        return (float)(GetTime() / tag.GetDuration() * 100);
+    }
+
+    if (m_itemCurrentFile->IsStack() && m_currentStack->Size() > 0)
+    {
+      double totalTime = GetTotalTime();
+      if (totalTime > 0.0f)
+        return (float)(GetTime() / totalTime * 100);
+    }
+    else
+      return m_pPlayer->GetPercentage();
+  }
+  return 0.0f;
+}
+
+float CApplication::GetCachePercentage() const
+{
+  if (IsPlaying() && m_pPlayer)
+  {
+    // Note that the player returns a relative cache percentage and we want an absolute percentage
+    if (m_itemCurrentFile->IsStack() && m_currentStack->Size() > 0)
+    {
+      float stackedTotalTime = (float) GetTotalTime();
+      // We need to take into account the stack's total time vs. currently playing file's total time
+      if (stackedTotalTime > 0.0f)
+        return min( 100.0f, GetPercentage() + (m_pPlayer->GetCachePercentage() * m_pPlayer->GetTotalTime() * 0.001f / stackedTotalTime ) );
+    }
+    else
+      return min( 100.0f, m_pPlayer->GetPercentage() + m_pPlayer->GetCachePercentage() );
+  }
+  return 0.0f;
+}
+
+void CApplication::SeekPercentage(float percent)
+{
+  if (IsPlaying() && m_pPlayer && (percent >= 0.0))
+  {
+    if (!m_pPlayer->CanSeek()) return;
+    if (m_itemCurrentFile->IsStack() && m_currentStack->Size() > 0)
+      SeekTime(percent * 0.01 * GetTotalTime());
+    else
+      m_pPlayer->SeekPercentage(percent);
+  }
+}
+
+// SwitchToFullScreen() returns true if a switch is made, else returns false
+bool CApplication::SwitchToFullScreen()
+{
+  // if playing from the video info window, close it first!
+  if (g_windowManager.HasModalDialog() && g_windowManager.GetTopMostModalDialogID() == WINDOW_DIALOG_VIDEO_INFO)
+  {
+    CGUIDialogVideoInfo* pDialog = (CGUIDialogVideoInfo*)g_windowManager.GetWindow(WINDOW_DIALOG_VIDEO_INFO);
+    if (pDialog) pDialog->Close(true);
+  }
+
+  // don't switch if there is a dialog on screen or the slideshow is active
+  if (/*g_windowManager.HasModalDialog() ||*/ g_windowManager.GetActiveWindow() == WINDOW_SLIDESHOW)
+    return false;
+
+  // See if we're playing a video, and are in GUI mode
+  if ( IsPlayingVideo() && g_windowManager.GetActiveWindow() != WINDOW_FULLSCREEN_VIDEO)
+  {
+    // Reset frame count so that timing is FPS will be correct.
+    {
+      CSingleLock lock(m_frameMutex);
+      m_frameCount = 0;
+    }
+
+    // then switch to fullscreen mode
+    g_windowManager.ActivateWindow(WINDOW_FULLSCREEN_VIDEO);
+    return true;
+  }
+  // special case for switching between GUI & visualisation mode. (only if we're playing an audio song)
+  if (IsPlayingAudio() && g_windowManager.GetActiveWindow() != WINDOW_VISUALISATION)
+  { // then switch to visualisation
+    g_windowManager.ActivateWindow(WINDOW_VISUALISATION);
+    return true;
+  }
+  return false;
+}
+
+void CApplication::Minimize()
+{
+  g_Windowing.Minimize();
+}
+
+PLAYERCOREID CApplication::GetCurrentPlayer()
+{
+  return m_eCurrentPlayer;
+}
+
+void CApplication::UpdateLibraries()
+{
+  if (g_guiSettings.GetBool("videolibrary.updateonstartup"))
+  {
+    CLog::Log(LOGNOTICE, "%s - Starting video library startup scan", __FUNCTION__);
+    StartVideoScan("");
+  }
+
+  if (g_guiSettings.GetBool("musiclibrary.updateonstartup"))
+  {
+    CLog::Log(LOGNOTICE, "%s - Starting music library startup scan", __FUNCTION__);
+    StartMusicScan("");
+  }
+}
+
+bool CApplication::IsVideoScanning() const
+{
+  return m_videoInfoScanner->IsScanning();
+}
+
+bool CApplication::IsMusicScanning() const
+{
+  return m_musicInfoScanner->IsScanning();
+}
+
+void CApplication::StopVideoScan()
+{
+  if (m_videoInfoScanner->IsScanning())
+    m_videoInfoScanner->Stop();
+}
+
+void CApplication::StopMusicScan()
+{
+  if (m_musicInfoScanner->IsScanning())
+    m_musicInfoScanner->Stop();
+}
+
+void CApplication::StartVideoCleanup()
+{
+  if (m_videoInfoScanner->IsScanning())
+    return;
+
+  m_videoInfoScanner->CleanDatabase();
+}
+
+void CApplication::StartVideoScan(const CStdString &strDirectory, bool scanAll)
+{
+  if (m_videoInfoScanner->IsScanning())
+    return;
+
+  m_videoInfoScanner->ShowDialog(true);
+
+  m_videoInfoScanner->Start(strDirectory,scanAll);
+}
+
+void CApplication::StartMusicScan(const CStdString &strDirectory, int flags)
+{
+  if (m_musicInfoScanner->IsScanning())
+    return;
+
+  if (!flags)
+  { // setup default flags
+    if (g_guiSettings.GetBool("musiclibrary.downloadinfo"))
+      flags |= CMusicInfoScanner::SCAN_ONLINE;
+    if (g_guiSettings.GetBool("musiclibrary.backgroundupdate"))
+      flags |= CMusicInfoScanner::SCAN_BACKGROUND;
+  }
+
+  if (!(flags & CMusicInfoScanner::SCAN_BACKGROUND))
+    m_musicInfoScanner->ShowDialog(true);
+
+  m_musicInfoScanner->Start(strDirectory, flags);
+}
+
+void CApplication::StartMusicAlbumScan(const CStdString& strDirectory,
+                                       bool refresh)
+{
+  if (m_musicInfoScanner->IsScanning())
+    return;
+
+  m_musicInfoScanner->ShowDialog(true);
+
+  m_musicInfoScanner->FetchAlbumInfo(strDirectory,refresh);
+}
+
+void CApplication::StartMusicArtistScan(const CStdString& strDirectory,
+                                        bool refresh)
+{
+  if (m_musicInfoScanner->IsScanning())
+    return;
+
+  m_musicInfoScanner->ShowDialog(true);
+
+  m_musicInfoScanner->FetchArtistInfo(strDirectory,refresh);
+}
+
+void CApplication::CheckPlayingProgress()
+{
+  // check if we haven't rewound past the start of the file
+  if (IsPlaying())
+  {
+    int iSpeed = g_application.GetPlaySpeed();
+    if (iSpeed < 1)
+    {
+      iSpeed *= -1;
+      int iPower = 0;
+      while (iSpeed != 1)
+      {
+        iSpeed >>= 1;
+        iPower++;
+      }
+      if (g_infoManager.GetPlayTime() / 1000 < iPower)
+      {
+        g_application.SetPlaySpeed(1);
+        g_application.SeekTime(0);
+      }
+    }
+  }
+}
+
+bool CApplication::ProcessAndStartPlaylist(const CStdString& strPlayList, CPlayList& playlist, int iPlaylist, int track)
+{
+  CLog::Log(LOGDEBUG,"CApplication::ProcessAndStartPlaylist(%s, %i)",strPlayList.c_str(), iPlaylist);
+
+  // initial exit conditions
+  // no songs in playlist just return
+  if (playlist.size() == 0)
+    return false;
+
+  // illegal playlist
+  if (iPlaylist < PLAYLIST_MUSIC || iPlaylist > PLAYLIST_VIDEO)
+    return false;
+
+  // setup correct playlist
+  g_playlistPlayer.ClearPlaylist(iPlaylist);
+
+  // if the playlist contains an internet stream, this file will be used
+  // to generate a thumbnail for musicplayer.cover
+  g_application.m_strPlayListFile = strPlayList;
+
+  // add the items to the playlist player
+  g_playlistPlayer.Add(iPlaylist, playlist);
+
+  // if we have a playlist
+  if (g_playlistPlayer.GetPlaylist(iPlaylist).size())
+  {
+    // start playing it
+    g_playlistPlayer.SetCurrentPlaylist(iPlaylist);
+    g_playlistPlayer.Reset();
+    g_playlistPlayer.Play(track);
+    return true;
+  }
+  return false;
+}
+
+void CApplication::SaveCurrentFileSettings()
+{
+  // don't store settings for PVR in video database
+  if (m_itemCurrentFile->IsVideo() && !m_itemCurrentFile->IsPVRChannel())
+  {
+    // save video settings
+    if (g_settings.m_currentVideoSettings != g_settings.m_defaultVideoSettings)
+    {
+      CVideoDatabase dbs;
+      dbs.Open();
+      dbs.SetVideoSettings(m_itemCurrentFile->GetPath(), g_settings.m_currentVideoSettings);
+      dbs.Close();
+    }
+  }
+  else if (m_itemCurrentFile->IsPVRChannel())
+  {
+    g_PVRManager.SaveCurrentChannelSettings();
+  }
+}
+
+bool CApplication::AlwaysProcess(const CAction& action)
+{
+  // check if this button is mapped to a built-in function
+  if (!action.GetName().IsEmpty())
+  {
+    CStdString builtInFunction;
+    vector<CStdString> params;
+    CUtil::SplitExecFunction(action.GetName(), builtInFunction, params);
+    builtInFunction.ToLower();
+
+    // should this button be handled normally or just cancel the screensaver?
+    if (   builtInFunction.Equals("powerdown")
+        || builtInFunction.Equals("reboot")
+        || builtInFunction.Equals("restart")
+        || builtInFunction.Equals("restartapp")
+        || builtInFunction.Equals("suspend")
+        || builtInFunction.Equals("hibernate")
+        || builtInFunction.Equals("quit")
+        || builtInFunction.Equals("shutdown"))
+    {
+      return true;
+    }
+  }
+
+  return false;
+}
+
+bool CApplication::IsCurrentThread() const
+{
+  return CThread::IsCurrentThread(m_threadID);
+}
+
+bool CApplication::IsPresentFrame()
+{
+  CSingleLock lock(m_frameMutex);
+  bool ret = m_bPresentFrame;
+
+  return ret;
+}
+
+void CApplication::SetRenderGUI(bool renderGUI)
+{
+  if (renderGUI && ! m_renderGUI)
+    g_windowManager.MarkDirty();
+  m_renderGUI = renderGUI;
+}
+
+CNetwork& CApplication::getNetwork()
+{
+  return *m_network;
+}
+#ifdef HAS_PERFORMANCE_SAMPLE
+CPerformanceStats &CApplication::GetPerformanceStats()
+{
+  return m_perfStats;
+}
+#endif
+
diff -Nur xbmc-nightly.org/xbmc/cores/AudioEngine/AEFactory.cpp xbmc-nightly/xbmc/cores/AudioEngine/AEFactory.cpp
--- xbmc-nightly.org/xbmc/cores/AudioEngine/AEFactory.cpp	2014-01-24 22:02:28.157028793 -0800
+++ xbmc-nightly/xbmc/cores/AudioEngine/AEFactory.cpp	2014-02-14 18:27:05.136589309 -0800
@@ -42,6 +42,7 @@
 
 bool CAEFactory::LoadEngine()
 {
+#if HAS_AUDIOENGINE 
 #if defined(TARGET_RASPBERRY_PI)
   return true;
 #endif
@@ -79,6 +80,9 @@
 #endif
 
   return loaded;
+#else
+  return true;
+#endif
 }
 
 bool CAEFactory::LoadEngine(enum AEEngine engine)
@@ -124,6 +128,7 @@
 
 bool CAEFactory::StartEngine()
 {
+#if HAS_AUDIOENGINE 
 #if defined(TARGET_RASPBERRY_PI)
   return true;
 #endif
@@ -137,6 +142,9 @@
   delete AE;
   AE = NULL;
   return false;
+#else
+  return true;
+#endif
 }
 
 bool CAEFactory::Suspend()
diff -Nur xbmc-nightly.org/xbmc/cores/DllLoader/DllLoaderContainer.cpp xbmc-nightly/xbmc/cores/DllLoader/DllLoaderContainer.cpp
--- xbmc-nightly.org/xbmc/cores/DllLoader/DllLoaderContainer.cpp	2014-01-24 22:02:28.187032606 -0800
+++ xbmc-nightly/xbmc/cores/DllLoader/DllLoaderContainer.cpp	2014-02-14 18:27:05.137589436 -0800
@@ -42,6 +42,7 @@
                  "special://xbmc/system/players/mplayer/;" \
                  "special://xbmc/system/players/dvdplayer/;" \
                  "special://xbmc/system/players/paplayer/;" \
+                 "special://xbmc/system/players/gstplayer/;" \
                  "special://xbmc/system/python/"
 
 #if defined(TARGET_DARWIN)
diff -Nur xbmc-nightly.org/xbmc/cores/DllLoader/DllLoader.h xbmc-nightly/xbmc/cores/DllLoader/DllLoader.h
--- xbmc-nightly.org/xbmc/cores/DllLoader/DllLoader.h	2014-01-24 22:02:28.187032606 -0800
+++ xbmc-nightly/xbmc/cores/DllLoader/DllLoader.h	2014-02-14 18:27:05.137589436 -0800
@@ -23,7 +23,7 @@
 #include "coffldr.h"
 #include "LibraryLoader.h"
 
-#if defined(__linux__) && !defined(__powerpc__) && !defined(__arm__)
+#if defined(__linux__) && !defined(__powerpc__) && !defined(__arm__) && !defined(__sh__)
 #define USE_LDT_KEEPER
 #include "ldt_keeper.h"
 #endif
diff -Nur xbmc-nightly.org/xbmc/cores/DllLoader/ldt_keeper.c xbmc-nightly/xbmc/cores/DllLoader/ldt_keeper.c
--- xbmc-nightly.org/xbmc/cores/DllLoader/ldt_keeper.c	2014-01-24 22:02:28.198034006 -0800
+++ xbmc-nightly/xbmc/cores/DllLoader/ldt_keeper.c	2014-02-14 18:27:05.137589436 -0800
@@ -19,7 +19,7 @@
  */
 
 //#ifndef __powerpc__
-#if !defined(__powerpc__) && !defined(__ppc__) && !defined(__arm__)
+#if !defined(__powerpc__) && !defined(__ppc__) && !defined(__arm__) && !defined(__sh__)
 
 #include "ldt_keeper.h"
 
diff -Nur xbmc-nightly.org/xbmc/cores/gstplayer/GSTPlayer.cpp xbmc-nightly/xbmc/cores/gstplayer/GSTPlayer.cpp
--- xbmc-nightly.org/xbmc/cores/gstplayer/GSTPlayer.cpp	1969-12-31 16:00:00.000000000 -0800
+++ xbmc-nightly/xbmc/cores/gstplayer/GSTPlayer.cpp	2014-02-14 18:27:05.138589563 -0800
@@ -0,0 +1,800 @@
+/*
+ *      Copyright (C) 2005-2008 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "system.h"
+#include "threads/SystemClock.h"
+#include "GSTPlayer.h"
+#include "GUIInfoManager.h"
+#include "Application.h"
+#include "ApplicationMessenger.h"
+#include "FileItem.h"
+#include "settings/AdvancedSettings.h"
+#include "settings/GUISettings.h"
+#include "settings/Settings.h"
+#include "music/tags/MusicInfoTag.h"
+#include "utils/TimeUtils.h"
+#include "utils/log.h"
+#include "utils/MathUtils.h"
+#include "filesystem/SpecialProtocol.h"
+
+#ifdef HAS_VIDEO_PLAYBACK
+#include "cores/VideoRenderers/RenderManager.h"
+#endif
+
+GSTPlayer::GSTPlayer(IPlayerCallback& callback) :
+  IPlayer            (callback),
+  CThread            ("GSTPlayer")
+{
+  printf("%s:%s[%d] ->\n", __FILE__, __func__, __LINE__);
+  int argc = 0;
+  char**argv = NULL;
+
+  m_bIsPlaying = false;
+  m_bPaused = false;
+  m_bQueueFailed = false;
+  m_iSpeed = 1;
+
+  m_timeOffset = 0;
+
+  m_currentFile = new CFileItem;
+  m_nextFile = new CFileItem;
+
+  gst_init(&argc, &argv);
+  m_pGstPlaybin = gst_element_factory_make("playbin2", "playbin");
+
+  GstBus *bus = gst_pipeline_get_bus(GST_PIPELINE (m_pGstPlaybin));
+  gst_bus_set_sync_handler(bus, gstBusSyncHandler, this);
+  gst_object_unref(bus);
+  printf("%s:%s[%d] <-\n", __FILE__, __func__, __LINE__);
+}
+
+GSTPlayer::~GSTPlayer()
+{
+  printf("%s:%s[%d] ->\n", __FILE__, __func__, __LINE__);
+
+  CloseFile();
+
+  if (m_pGstPlaybin)
+  {
+    GstBus *bus = gst_pipeline_get_bus(GST_PIPELINE (m_pGstPlaybin));
+    gst_bus_set_sync_handler(bus, NULL, NULL);
+    gst_object_unref(bus);
+  }
+
+  gst_element_set_state(m_pGstPlaybin, GST_STATE_NULL);
+
+/*
+  if (audioSink)
+  {
+    gst_object_unref(GST_OBJECT(audioSink));
+    audioSink = NULL;
+  }
+
+  if (videoSink)
+  {
+    gst_object_unref(GST_OBJECT(videoSink));
+    videoSink = NULL;
+  }
+*/
+
+  if (m_pGstPlaybin)
+    gst_object_unref (GST_OBJECT (m_pGstPlaybin));
+  printf("%s:%s[%d] <-\n", __FILE__, __func__, __LINE__);
+}
+
+void GSTPlayer::OnExit()
+{
+  printf("%s:%s[%d] ->\n", __FILE__, __func__, __LINE__);
+  printf("%s:%s[%d] <-\n", __FILE__, __func__, __LINE__);
+
+}
+
+bool GSTPlayer::OpenFile(const CFileItem& file, const CPlayerOptions &options)
+{
+  printf("%s:%s[%d] ->\n", __FILE__, __func__, __LINE__);
+  gchar *uri;
+  int flags;
+
+  m_iSpeed = 1;
+  m_bPaused = false;
+  m_bStopPlaying = false;
+
+  int audioMode = g_guiSettings.GetInt("audiooutput.mode");
+  bool passthrough = AUDIO_IS_BITSTREAM(audioMode);
+  
+  printf("%s:%s[%d] bitstream=%d mode=%d\n", __FILE__, __func__, __LINE__, passthrough, audioMode);
+  
+  FILE* fpAc3 = fopen("/proc/stb/audio/ac3", "w");
+  FILE* fpHdmiSource = fopen("/proc/stb/hdmi/audio_source", "w");
+  if (passthrough)
+  {
+    fprintf(fpAc3, "%s", "passthrough");
+    fprintf(fpHdmiSource, "%s", "spdif");
+  }
+  else
+  {
+    fprintf(fpAc3, "%s", "downmix");
+    fprintf(fpHdmiSource, "%s", "pcm");
+  }
+  fclose(fpAc3);
+  fclose(fpHdmiSource);
+
+  CLog::Log(LOGINFO, "GSTPlayer: Playing %s", file.GetPath().c_str());
+
+  m_timeOffset = (__int64)(options.starttime * 1000);
+
+  uri = g_filename_to_uri(file.GetPath().c_str(), NULL, NULL);
+  if (uri == NULL)
+    uri = strdup(file.GetPath().c_str());
+
+  if (!g_ascii_strncasecmp(uri, "nfs://", 6)) {
+    gchar* url = uri + 6;
+    gchar* new_uri;
+    gchar** tokens = g_strsplit(url, "/", 3);
+    gchar* cmd = g_strdup_printf("mount -tnfs  -onolock %s:/%s /tmp/nfs", tokens[0], tokens[1]);
+    
+    new_uri = g_strdup_printf("file:///tmp/nfs/%s", tokens[2]);
+    g_free(uri);
+    uri = new_uri;
+    
+    printf ("Playing: %s\n", uri);
+    
+    printf ("mkdir -p /tmp/nfs\n");
+    system("mkdir -p /tmp/nfs");
+    printf ("umount /tmp/nfs\n");
+    system("umount /tmp/nfs");
+    printf ("%s\n", cmd);
+    system(cmd);
+    g_free(cmd);
+  }
+
+  g_object_set (G_OBJECT (m_pGstPlaybin), "uri", uri, NULL);
+  g_free(uri);
+
+  // ( GST_PLAY_FLAG_VIDEO | GST_PLAY_FLAG_AUDIO | GST_PLAY_FLAG_NATIVE_VIDEO | GST_PLAY_FLAG_TEXT );
+  flags = GST_PLAY_FLAG_VIDEO | GST_PLAY_FLAG_AUDIO | GST_PLAY_FLAG_NATIVE_VIDEO; 
+  g_object_set (G_OBJECT (m_pGstPlaybin), "flags", flags, NULL);
+
+  *m_currentFile = file;
+
+  if (!IsRunning())
+    Create();
+
+  m_startEvent.Set();
+  
+  m_bIsPlaying = true;
+  m_bQueueFailed = false;
+  m_iCurrentAudioStream = -1;
+
+
+
+    m_iVideoWidth = 1280;
+    m_iVideoHeight = 720;
+    m_iVideoFramerate = 50000;
+    
+    m_evVideoSizeChanged = 0;
+    m_evVideoFramerateChanged = 0;
+    m_evVideoProgressiveChanged = 0;
+
+  gst_element_set_state (m_pGstPlaybin, GST_STATE_PLAYING);
+
+#if defined(HAS_VIDEO_PLAYBACK)
+    g_renderManager.PreInit();
+
+
+
+    
+    //g_renderManager.Configure(m_iVideoWidth, m_iVideoHeight, 1280, 720, m_iVideoFramerate/1000.0, 0, RENDER_FMT_NONE, 0);
+#endif
+
+  printf("%s:%s[%d] <-\n", __FILE__, __func__, __LINE__);
+  return true;
+}
+
+//Finished
+bool GSTPlayer::QueueNextFile(const CFileItem &file)
+{
+  printf("%s:%s[%d] ->\n", __FILE__, __func__, __LINE__);
+  if (IsPaused())
+    Pause();
+
+  if (file.GetPath() == m_currentFile->GetPath() &&
+      file.m_lStartOffset > 0 &&
+      file.m_lStartOffset == m_currentFile->m_lEndOffset)
+  { // continuing on a .cue sheet item - return true to say we'll handle the transistion
+    *m_nextFile = file;
+    return true;
+  }
+
+  // ok, we're good to go on queuing this one up
+  CLog::Log(LOGINFO, "GSTPlayer: Queuing next file %s", file.GetPath().c_str());
+
+  *m_nextFile = file;
+
+  printf("%s:%s[%d] <-\n", __FILE__, __func__, __LINE__);
+  return true;
+}
+
+//Finished
+void GSTPlayer::OnNothingToQueueNotify()
+{
+  printf("%s:%s[%d] ->\n", __FILE__, __func__, __LINE__);
+  //nothing to queue, stop playing
+  m_bQueueFailed = true;
+  printf("%s:%s[%d] <-\n", __FILE__, __func__, __LINE__);
+}
+
+bool GSTPlayer::CloseFile()
+{
+  printf("%s:%s[%d] ->\n", __FILE__, __func__, __LINE__);
+  if (IsPaused())
+    Pause();
+
+  m_bStopPlaying = true;
+  m_bStop = true;
+
+  StopThread();
+
+  gst_element_set_state(m_pGstPlaybin, GST_STATE_NULL);
+
+  m_currentFile->Reset();
+  m_nextFile->Reset();
+
+#if defined(HAS_VIDEO_PLAYBACK)
+  g_renderManager.UnInit();
+#endif
+  printf ("umount /tmp/nfs ->\n");
+  system("umount /tmp/nfs");
+  printf ("umount /tmp/nfs <-\n");
+  return true;
+  printf("%s:%s[%d] <-\n", __FILE__, __func__, __LINE__);
+}
+
+//Finished
+void GSTPlayer::Pause()
+{
+  printf("%s:%s[%d] ->\n", __FILE__, __func__, __LINE__);
+  CLog::Log(LOGDEBUG,"GSTPlayer: pause m_bplaying: %d", m_bIsPlaying);
+  if (!m_bIsPlaying || !m_pGstPlaybin) {
+    printf("%s:%s[%d] <<-\n", __FILE__, __func__, __LINE__);
+    return;
+  }
+
+
+  if (m_bPaused)
+    gst_element_set_state (m_pGstPlaybin, GST_STATE_PLAYING);
+  else
+    gst_element_set_state (m_pGstPlaybin, GST_STATE_PAUSED);
+  
+  m_bPaused = !m_bPaused;
+  
+  printf("%s:%s[%d] <-\n", __FILE__, __func__, __LINE__);
+}
+
+__int64 GSTPlayer::GetTotalTime()
+{
+  //d1printf("%s:%s[%d] ->\n", __FILE__, __func__, __LINE__);
+  __int64 total;
+  gint64 len;
+  GstFormat fmt = GST_FORMAT_TIME; //Returns time in nanosecs
+  gst_element_query_duration(m_pGstPlaybin, &fmt, &len);
+  total = len / 1000000;
+
+
+  if (m_currentFile->m_lEndOffset)
+    total = m_currentFile->m_lEndOffset * 1000 / 75;
+  if (m_currentFile->m_lStartOffset)
+    total -= m_currentFile->m_lStartOffset * 1000 / 75;
+
+  m_duration_ms = total;
+
+  //d1printf("%s:%s[%d] <- len=%lld\n", __FILE__, __func__, __LINE__, total);
+  return total;
+}
+
+
+float GSTPlayer::GetPercentage()
+{
+  //d1printf("%s:%s[%d] ->\n", __FILE__, __func__, __LINE__);
+  float percent = (GetTime() * 100.0f) / GetTotalTime();
+  //d1printf("%s:%s[%d] <- percent=%f%%\n", __FILE__, __func__, __LINE__, percent);
+  return percent;
+}
+
+__int64 GSTPlayer::GetTime()
+{
+  //d1printf("%s:%s[%d] ->\n", __FILE__, __func__, __LINE__);
+  __int64 ret;
+  __int64 timeplus;
+  gint64 pos;
+  GstFormat fmt = GST_FORMAT_TIME; //Returns time in nanosecs
+  gst_element_query_position(m_pGstPlaybin, &fmt, &pos);
+  timeplus = pos / 1000000;
+
+  ret = m_timeOffset + timeplus - m_currentFile->m_lStartOffset * 1000 / 75;
+
+  m_elapsed_ms = ret;
+
+  //d1printf("%s:%s[%d] <- pos=%lld\n", __FILE__, __func__, __LINE__, ret);
+  return ret;
+}
+
+bool GSTPlayer::CanSeek()
+{
+  printf("%s:%s[%d] ->\n", __FILE__, __func__, __LINE__);
+  printf("%s:%s[%d] <- %d\n", __FILE__, __func__, __LINE__, GetTotalTime() > 0);
+  return GetTotalTime() > 0;
+}
+
+void GSTPlayer::Seek(bool bPlus, bool bLargeStep)
+{
+  printf("%s:%s[%d] -> bPlus=%d bLargeStep=%d\n", __FILE__, __func__, __LINE__, bPlus, bLargeStep);
+
+#if 0
+  // try chapter seeking first, chapter_index is ones based.
+  int chapter_index = GetChapter();
+  if (bLargeStep)
+  {
+    // seek to next chapter
+    if (bPlus && (chapter_index < GetChapterCount()))
+    {
+      SeekChapter(chapter_index + 1);
+      return;
+    }
+    // seek to previous chapter
+    if (!bPlus && chapter_index)
+    {
+      SeekChapter(chapter_index - 1);
+      return;
+    }
+  }
+#endif
+
+  int64_t seek_ms;
+  if (g_advancedSettings.m_videoUseTimeSeeking)
+  {
+    if (bLargeStep && (GetTotalTime() > (2000 * g_advancedSettings.m_videoTimeSeekForwardBig)))
+      seek_ms = bPlus ? g_advancedSettings.m_videoTimeSeekForwardBig : g_advancedSettings.m_videoTimeSeekBackwardBig;
+    else
+      seek_ms = bPlus ? g_advancedSettings.m_videoTimeSeekForward    : g_advancedSettings.m_videoTimeSeekBackward;
+    // convert to milliseconds
+    seek_ms *= 1000;
+    seek_ms += m_elapsed_ms;
+  }
+  else
+  {
+    float percent;
+    if (bLargeStep)
+      percent = bPlus ? g_advancedSettings.m_videoPercentSeekForwardBig : g_advancedSettings.m_videoPercentSeekBackwardBig;
+    else
+      percent = bPlus ? g_advancedSettings.m_videoPercentSeekForward    : g_advancedSettings.m_videoPercentSeekBackward;
+    percent /= 100.0f;
+    percent += (float)m_elapsed_ms/(float)m_duration_ms;
+    // convert to milliseconds
+    seek_ms = m_duration_ms * percent;
+  }
+
+  // handle stacked videos, dvdplayer does it so we do it too.
+  if (g_application.CurrentFileItem().IsStack() &&
+    (seek_ms > m_duration_ms || seek_ms < 0))
+  {
+    CLog::Log(LOGDEBUG, "CAMLPlayer::Seek: In mystery code, what did I do");
+    g_application.SeekTime((seek_ms - m_elapsed_ms) * 0.001 + g_application.GetTime());
+    // warning, don't access any object variables here as
+    // the object may have been destroyed
+    return;
+  }
+
+  if (seek_ms <= 1000)
+    seek_ms = 1000;
+
+  if (seek_ms > m_duration_ms)
+    seek_ms = m_duration_ms;
+
+  // do seek here
+  g_infoManager.SetDisplayAfterSeek(100000);
+  SeekTime(seek_ms);
+  m_callback.OnPlayBackSeek((int)seek_ms, (int)(seek_ms - m_elapsed_ms));
+  g_infoManager.SetDisplayAfterSeek();
+  printf("%s:%s[%d] <-\n", __FILE__, __func__, __LINE__);
+}
+
+void GSTPlayer::SeekTime(__int64 seek_ms)
+{
+  printf("%s:%s[%d] -> seek_ms=%ld\n", __FILE__, __func__, __LINE__, seek_ms);
+  // we cannot seek if paused
+  if (m_bPaused)
+    return;
+
+  if (seek_ms <= 0)
+    seek_ms = 100;
+
+  // seek here
+    // player_timesearch is nanoseconds (int64).
+    gst_element_seek (m_pGstPlaybin, 1.0, GST_FORMAT_TIME, GST_SEEK_FLAG_FLUSH,
+        GST_SEEK_TYPE_SET, seek_ms*1000000,
+        GST_SEEK_TYPE_NONE, GST_CLOCK_TIME_NONE);
+    //WaitForSearchOK(5000);
+    //WaitForPlaying(5000);
+  printf("%s:%s[%d] <-\n", __FILE__, __func__, __LINE__);
+}
+
+void GSTPlayer::Process()
+{
+  CLog::Log(LOGDEBUG, "GSTPlayer: Thread started");
+  
+  
+  if (m_startEvent.WaitMSec(100))
+  {
+    m_startEvent.Reset();
+    do
+    {
+      if (!m_bPaused)
+      {
+      }
+      else
+      {
+        
+      }
+      Sleep(100);
+    }
+    while (!m_bStopPlaying && m_bIsPlaying && !m_bStop);
+
+    CLog::Log(LOGINFO, "GSTPlayer: End of playback reached");
+    m_bIsPlaying = false;
+    if (!m_bStopPlaying && !m_bStop)
+      m_callback.OnPlayBackEnded();
+    else
+      m_callback.OnPlayBackStopped();
+  }
+  CLog::Log(LOGDEBUG, "GSTPlayer: Thread end");
+}
+
+void GSTPlayer::SetVolume(long nVolume)
+{
+  printf("%s:%s[%d] -> nVolume=%ld\n", __FILE__, __func__, __LINE__, nVolume);
+  //-6000 = mute, 0 is max
+  //64 = mute, 0 is max
+  FILE* fp = fopen("/proc/stb/avs/0/volume", "w");
+  fprintf(fp, "%d", (int)((nVolume*-64)/6000.0));
+  fclose(fp);
+  printf("%s:%s[%d] <-\n", __FILE__, __func__, __LINE__);
+}
+
+float GSTPlayer::GetActualFPS()
+{
+  //d1printf("%s:%s[%d] ->\n", __FILE__, __func__, __LINE__);
+  FILE* fp = fopen("/proc/stb/vmpeg/0/framerate", "r");
+  int video_fps_tmp = 0;
+  float video_fps = 0.0f;
+  fscanf(fp, "%x", &video_fps_tmp);
+  fclose(fp);
+  video_fps = video_fps_tmp / 1000.0f;
+  
+  //d1printf("%s:%s[%d] <- video_fps=%f\n", __FILE__, __func__, __LINE__, video_fps);
+  return video_fps;
+}
+
+int GSTPlayer::GetPictureWidth()
+{
+  //d1printf("%s:%s[%d] ->\n", __FILE__, __func__, __LINE__);
+  FILE* fp = fopen("/proc/stb/vmpeg/0/xres", "r");
+  int video_width = 0;
+  fscanf(fp, "%x", &video_width);
+  fclose(fp);
+  //d1printf("%s:%s[%d] <- video_width=%d\n", __FILE__, __func__, __LINE__, video_width);
+  return video_width;
+}
+
+int GSTPlayer::GetPictureHeight()
+{
+  //d1printf("%s:%s[%d] ->\n", __FILE__, __func__, __LINE__);
+  FILE* fp = fopen("/proc/stb/vmpeg/0/yres", "r");
+  int video_height = 0;
+  fscanf(fp, "%x", &video_height);
+  fclose(fp);
+  //d1printf("%s:%s[%d] <- video_height=%d\n", __FILE__, __func__, __LINE__, video_height);
+  return video_height;
+}
+
+void GSTPlayer::gstBusCall(GstMessage *msg)
+{
+  //d2printf("%s:%s[%d] ->\n", __FILE__, __func__, __LINE__);
+  if (!msg) {
+    //d2printf("%s:%s[%d] <<-\n", __FILE__, __func__, __LINE__);
+    return;
+  }
+  
+  printf("%s:%s[%d] ->\n", __FILE__, __func__, __LINE__);
+  
+  gchar *sourceName;
+  GstObject *source;
+  source = GST_MESSAGE_SRC(msg);
+  if (!GST_IS_OBJECT(source)) return;
+  sourceName = gst_object_get_name(source);
+
+  switch (GST_MESSAGE_TYPE (msg))
+  {
+    case GST_MESSAGE_EOS:
+      m_bIsPlaying = false;
+      break;
+    case GST_MESSAGE_STATE_CHANGED:
+    {
+      if(GST_MESSAGE_SRC(msg) != GST_OBJECT(m_pGstPlaybin))
+        break;
+      GstState old_state, new_state;
+      gst_message_parse_state_changed(msg, &old_state, &new_state, NULL);
+      if(old_state == new_state)
+        break;
+      printf("%s:%s[%d] state transition %s -> %s\n", __FILE__, __func__, __LINE__, 
+        gst_element_state_get_name(old_state), gst_element_state_get_name(new_state));
+      
+      GstStateChange transition = (GstStateChange)GST_STATE_TRANSITION(old_state, new_state);
+      switch(transition)
+      {
+        case GST_STATE_CHANGE_NULL_TO_READY:
+        case GST_STATE_CHANGE_READY_TO_PAUSED:
+        case GST_STATE_CHANGE_PAUSED_TO_PLAYING:
+        case GST_STATE_CHANGE_PLAYING_TO_PAUSED:
+        case GST_STATE_CHANGE_PAUSED_TO_READY:
+        case GST_STATE_CHANGE_READY_TO_NULL:
+        default:
+        break;
+      }
+      break;
+    }
+    case GST_MESSAGE_ERROR:
+      break;
+    case GST_MESSAGE_INFO:
+      break;
+    case GST_MESSAGE_TAG:
+#if 0
+      GstTagList *tags, *result;
+      gst_message_parse_tag(msg, &tags);
+      
+      result = gst_tag_list_merge(m_stream_tags, tags, GST_TAG_MERGE_REPLACE);
+      if (result)
+      {
+        if (m_stream_tags)
+          gst_tag_list_free(m_stream_tags);
+        m_stream_tags = result;
+      }
+#endif
+      
+#if 0
+      const GValue *gv_image = gst_tag_list_get_value_index(tags, GST_TAG_IMAGE, 0);
+      if ( gv_image )
+      {
+        GstBuffer *buf_image;
+        buf_image = gst_value_get_buffer (gv_image);
+        int fd = open("/tmp/.id3coverart", O_CREAT|O_WRONLY|O_TRUNC, 0644);
+        if (fd >= 0)
+        {
+          int ret = write(fd, GST_BUFFER_DATA(buf_image), GST_BUFFER_SIZE(buf_image));
+          close(fd);
+          eDebug("eServiceMP3::/tmp/.id3coverart %d bytes written ", ret);
+        }
+      }
+#endif
+      //gst_tag_list_free(tags);
+      break;
+
+    case GST_MESSAGE_ASYNC_DONE:
+    {
+      if(GST_MESSAGE_SRC(msg) != GST_OBJECT(m_pGstPlaybin))
+        break;
+
+      GstTagList *tags;
+      gint i, active_idx, n_video = 0, n_audio = 0, n_text = 0;
+
+      g_object_get (m_pGstPlaybin, "n-video", &n_video, NULL);
+      g_object_get (m_pGstPlaybin, "n-audio", &n_audio, NULL);
+      g_object_get (m_pGstPlaybin, "n-text", &n_text, NULL);
+
+      if (n_audio > 0)
+        m_bHasAudio = true;
+      if (n_video > 0)
+        m_bHasVideo = true;
+
+      m_AudioStreams.size();
+
+      for (i = 0; i < n_audio; i++)
+      {
+        AudioStream audio;
+        gchar *g_codec, *g_lang;
+        GstPad* pad = 0;
+        g_signal_emit_by_name (m_pGstPlaybin, "get-audio-pad", i, &pad);
+        GstCaps* caps = gst_pad_get_negotiated_caps(pad);
+        if (!caps)
+          continue;
+        GstStructure* str = gst_caps_get_structure(caps, 0);
+        const gchar *g_type = gst_structure_get_name(str);
+        
+        //audio.m_AudioType = gstCheckAudioPad(str);
+        g_codec = g_strdup(g_type);
+        g_lang = g_strdup_printf ("Unknown");
+        g_signal_emit_by_name (m_pGstPlaybin, "get-audio-tags", i, &tags);
+        if ( tags && gst_is_tag_list(tags) )
+        {
+          gst_tag_list_get_string(tags, GST_TAG_AUDIO_CODEC, &g_codec);
+          gst_tag_list_get_string(tags, GST_TAG_LANGUAGE_CODE, &g_lang);
+          gst_tag_list_free(tags);
+        }
+        audio.m_sLanguageCode = g_lang;
+        audio.m_sCodec = g_codec;
+
+        m_AudioStreams.push_back(audio);
+
+        g_free (g_lang);
+        g_free (g_codec);
+        gst_caps_unref(caps);
+      }
+
+      break;
+    }
+    case GST_MESSAGE_ELEMENT:
+    {
+      const GstStructure *msgstruct = gst_message_get_structure(msg);
+      if (msgstruct)
+      {
+        //if ( gst_is_missing_plugin_message(msg) )
+        //  break;
+
+        const gchar *eventname = gst_structure_get_name(msgstruct);
+        if ( eventname == NULL )
+          break;
+
+        if (!strcmp(eventname, "eventSizeChanged") || !strcmp(eventname, "eventSizeAvail"))
+        {
+          gst_structure_get_int (msgstruct, "aspect_ratio", &m_iVideoAspect);
+          gst_structure_get_int (msgstruct, "width", &m_iVideoWidth);
+          gst_structure_get_int (msgstruct, "height", &m_iVideoHeight);
+          if (strstr(eventname, "Changed"))
+          {
+            m_evVideoSizeChanged = 1;
+            printf("%s:%s[%d] VideoSize Changed a=%d w=%d h=%d\n", __FILE__, __func__, __LINE__, m_iVideoAspect, m_iVideoWidth, m_iVideoHeight);
+            if (m_evVideoFramerateChanged)
+            {
+              g_renderManager.Configure(m_iVideoWidth, m_iVideoHeight, 1280, 720, m_iVideoFramerate/1000.0, 0, RENDER_FMT_NONE, 0, 0);
+              CApplicationMessenger::Get().SwitchToFullscreen();
+            }
+          }
+        }
+        else if (!strcmp(eventname, "eventFrameRateChanged") || !strcmp(eventname, "eventFrameRateAvail"))
+        {
+          gst_structure_get_int (msgstruct, "frame_rate", &m_iVideoFramerate);
+          if (strstr(eventname, "Changed"))
+          {
+            m_evVideoFramerateChanged = 1;
+            printf("%s:%s[%d] VideoFramerate Changed f=%i\n", __FILE__, __func__, __LINE__, m_iVideoFramerate);
+            
+            if (m_evVideoSizeChanged)
+            {
+              g_renderManager.Configure(m_iVideoWidth, m_iVideoHeight, 1280, 720, m_iVideoFramerate/1000.0, 0, RENDER_FMT_NONE, 0, 0);
+              CApplicationMessenger::Get().SwitchToFullscreen();
+            }
+          }
+        }
+        else if (!strcmp(eventname, "eventProgressiveChanged") || !strcmp(eventname, "eventProgressiveAvail"))
+        {
+          gst_structure_get_int (msgstruct, "progressive", &m_iVideoProgressive);
+          if (strstr(eventname, "Changed"))
+          {
+            m_evVideoProgressiveChanged = 1;
+            printf("%s:%s[%d] VideoProgressive Changed p=%i\n", __FILE__, __func__, __LINE__, m_iVideoProgressive);
+          }
+        }
+        else if (!strcmp(eventname, "redirect"))
+        {
+           const char *uri = gst_structure_get_string(msgstruct, "new-location");
+           gst_element_set_state (m_pGstPlaybin, GST_STATE_NULL);
+           g_object_set(G_OBJECT (m_pGstPlaybin), "uri", uri, NULL);
+           gst_element_set_state (m_pGstPlaybin, GST_STATE_PLAYING);
+        }
+      }
+      break;
+    }
+
+    default:
+      break;
+  }
+  printf("%s:%s[%d] <-\n", __FILE__, __func__, __LINE__);
+}
+
+void GSTPlayer::handleMessage(GstMessage *msg)
+{
+  //d2printf("%s:%s[%d] ->\n", __FILE__, __func__, __LINE__);
+  if (GST_MESSAGE_TYPE(msg) == GST_MESSAGE_STATE_CHANGED && GST_MESSAGE_SRC(msg) != GST_OBJECT(m_pGstPlaybin))
+  {
+    gst_message_unref(msg);
+    //d2printf("%s:%s[%d] <<-\n", __FILE__, __func__, __LINE__);
+    return;
+  }
+  gstBusCall(msg);
+  //d2printf("%s:%s[%d] <-\n", __FILE__, __func__, __LINE__);
+}
+
+GstBusSyncReply GSTPlayer::gstBusSyncHandler(GstBus *bus, GstMessage *message, gpointer user_data)
+{
+  //d2printf("%s:%s[%d]\n", __FILE__, __func__, __LINE__);
+  GSTPlayer *_this = (GSTPlayer*)user_data;
+  if (_this) _this->handleMessage(message);
+  
+  //d2printf("%s:%s[%d] <-\n", __FILE__, __func__, __LINE__);
+  return GST_BUS_DROP;
+}
+
+int GSTPlayer::GetAudioStreamCount()
+{
+  printf("%s:%s[%d] ->\n", __FILE__, __func__, __LINE__);
+  printf("%s:%s[%d] <-\n", __FILE__, __func__, __LINE__);
+  return m_AudioStreams.size();
+}
+
+int GSTPlayer::GetAudioStream()
+{
+  printf("%s:%s[%d] ->\n", __FILE__, __func__, __LINE__);
+  if (m_iCurrentAudioStream == -1)
+    g_object_get (G_OBJECT (m_pGstPlaybin), "current-audio", &m_iCurrentAudioStream, NULL);
+  printf("%s:%s[%d] <-\n", __FILE__, __func__, __LINE__);
+  return m_iCurrentAudioStream;
+}
+
+void GSTPlayer::SetAudioStream(int iStream)
+{
+  printf("%s:%s[%d] -> iStream=%d\n", __FILE__, __func__, __LINE__, iStream);
+  if (iStream >= m_AudioStreams.size()) {
+    printf("%s:%s[%d] <<-\n", __FILE__, __func__, __LINE__);
+    return;
+  }
+
+  int current_audio;
+  g_object_set (G_OBJECT (m_pGstPlaybin), "current-audio", iStream, NULL);
+  g_object_get (G_OBJECT (m_pGstPlaybin), "current-audio", &current_audio, NULL);
+  if ( current_audio == iStream )
+  {
+    m_iCurrentAudioStream = iStream;
+  }
+  printf("%s:%s[%d] <-\n", __FILE__, __func__, __LINE__);
+}
+
+void GSTPlayer::GetAudioStreamLanguage(int iStream, CStdString &strLanguage)
+{
+  printf("%s:%s[%d] ->\n", __FILE__, __func__, __LINE__);
+  strLanguage = "";
+  if (iStream >= m_AudioStreams.size())
+    return;
+
+  strLanguage = m_AudioStreams[iStream].m_sLanguageCode;
+  printf("%s:%s[%d] <- lng=%s\n", __FILE__, __func__, __LINE__, strLanguage.c_str());
+}
+
+void GSTPlayer::GetAudioStreamName(int iStream, CStdString& strStreamName)
+{
+  printf("%s:%s[%d] ->\n", __FILE__, __func__, __LINE__);
+  strStreamName = "Unknown";
+  if (iStream >= m_AudioStreams.size())
+    return;
+
+  strStreamName = m_AudioStreams[iStream].m_sCodec;
+  printf("%s:%s[%d] <- name=%s\n", __FILE__, __func__, __LINE__, strStreamName.c_str());
+}
+
diff -Nur xbmc-nightly.org/xbmc/cores/gstplayer/GSTPlayer.h xbmc-nightly/xbmc/cores/gstplayer/GSTPlayer.h
--- xbmc-nightly.org/xbmc/cores/gstplayer/GSTPlayer.h	1969-12-31 16:00:00.000000000 -0800
+++ xbmc-nightly/xbmc/cores/gstplayer/GSTPlayer.h	2014-02-14 18:27:05.139589690 -0800
@@ -0,0 +1,142 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2005-2008 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *  http://www.gnu.org/copyleft/gpl.html
+ *
+ */
+
+#include "cores/IPlayer.h"
+#include "threads/Thread.h"
+#include "threads/SharedSection.h"
+
+#include <gst/gst.h>
+#include <gst/pbutils/missing-plugins.h>
+
+#define STATUS_NO_FILE  0
+#define STATUS_QUEUING  1
+#define STATUS_QUEUED   2
+#define STATUS_PLAYING  3
+#define STATUS_ENDING   4
+#define STATUS_ENDED    5
+
+typedef enum {
+  GST_PLAY_FLAG_VIDEO         = (1 << 0),
+  GST_PLAY_FLAG_AUDIO         = (1 << 1),
+  GST_PLAY_FLAG_TEXT          = (1 << 2),
+  GST_PLAY_FLAG_VIS           = (1 << 3),
+  GST_PLAY_FLAG_SOFT_VOLUME   = (1 << 4),
+  GST_PLAY_FLAG_NATIVE_AUDIO  = (1 << 5),
+  GST_PLAY_FLAG_NATIVE_VIDEO  = (1 << 6),
+  GST_PLAY_FLAG_DOWNLOAD      = (1 << 7),
+  GST_PLAY_FLAG_BUFFERING     = (1 << 8)
+} GstPlayFlags;
+
+class GSTPlayer : public IPlayer, public CThread
+{
+public:
+  GSTPlayer(IPlayerCallback& callback);
+  virtual ~GSTPlayer();
+
+  virtual bool OpenFile(const CFileItem& file, const CPlayerOptions &options);
+  virtual bool QueueNextFile(const CFileItem &file);
+  virtual void OnNothingToQueueNotify();
+  virtual bool CloseFile();
+  virtual bool IsPlaying() const { return m_bIsPlaying; }
+  virtual void Pause();
+  virtual bool IsPaused() const { return m_bPaused; }
+  virtual bool HasVideo() const { return m_bHasVideo; }
+  virtual bool HasAudio() const { return m_bHasAudio; }
+
+  virtual bool CanSeek();
+  virtual void Seek(bool bPlus = true, bool bLargeStep = false);
+  virtual void SeekTime(__int64 iTime = 0);
+  
+  virtual void SetVolume(long nVolume);
+
+  virtual void GetAudioInfo( CStdString& strAudioInfo) {}
+  virtual void GetVideoInfo( CStdString& strVideoInfo) {}
+  virtual void GetGeneralInfo( CStdString& strVideoInfo) {}
+  virtual void Update(bool bPauseDrawing = false) {}
+  
+  virtual __int64 GetTotalTime();
+  virtual __int64 GetTime();
+  virtual float GetPercentage();
+
+  virtual int  GetAudioStreamCount();
+  virtual int  GetAudioStream();
+  virtual void GetAudioStreamName(int iStream, CStdString &strStreamName);
+  virtual void SetAudioStream(int iStream);
+  virtual void GetAudioStreamLanguage(int iStream, CStdString &strLanguage);
+
+  virtual float GetActualFPS();
+  virtual int   GetPictureWidth();
+  virtual int   GetPictureHeight();
+protected:
+  virtual void OnStartup() {}
+  virtual void Process();
+  virtual void OnExit();
+
+  struct AudioStream {
+    GstPad* m_Pad;
+//    audiotype_t m_AudioType;
+    CStdString m_sLanguageCode;
+    CStdString m_sCodec;
+  };
+
+  GstElement *m_pGstPlaybin;
+  
+  bool m_bPaused;
+  bool m_bIsPlaying;
+  bool m_bQueueFailed;
+  bool m_bStopPlaying;
+  int m_iSpeed;   // current playing speed
+  
+  bool m_bHasAudio;
+  bool m_bHasVideo;
+
+  std::vector<AudioStream> m_AudioStreams;
+  //int m_iAudioStreamCount;
+  int m_iCurrentAudioStream;
+
+  int m_iVideoAspect;
+  int m_iVideoWidth;
+  int m_iVideoHeight;
+  int m_iVideoFramerate;
+  int m_iVideoProgressive;
+
+  int m_evVideoSizeChanged;
+  int m_evVideoFramerateChanged;
+  int m_evVideoProgressiveChanged;
+
+  CEvent m_startEvent;
+
+private:
+  void gstBusCall(GstMessage *msg);
+  void handleMessage(GstMessage *msg);
+  static GstBusSyncReply gstBusSyncHandler(GstBus *bus, GstMessage *message, gpointer user_data);
+
+  __int64 m_timeOffset;
+  int64_t                 m_elapsed_ms;
+  int64_t                 m_duration_ms;
+
+  // our file
+  CFileItem*        m_currentFile;
+  CFileItem*        m_nextFile;
+};
+
diff -Nur xbmc-nightly.org/xbmc/cores/gstplayer/Makefile.in xbmc-nightly/xbmc/cores/gstplayer/Makefile.in
--- xbmc-nightly.org/xbmc/cores/gstplayer/Makefile.in	1969-12-31 16:00:00.000000000 -0800
+++ xbmc-nightly/xbmc/cores/gstplayer/Makefile.in	2014-02-14 18:27:05.139589690 -0800
@@ -0,0 +1,10 @@
+ARCH=@ARCH@
+
+.PHONY: compile
+
+SRCS=GSTPlayer.cpp \
+
+LIB=gstplayer.a
+
+include @abs_top_srcdir@/Makefile.include
+-include $(patsubst %.cpp,%.P,$(patsubst %.c,%.P,$(SRCS)))
diff -Nur xbmc-nightly.org/xbmc/cores/paplayer/ICodec.h xbmc-nightly/xbmc/cores/paplayer/ICodec.h
--- xbmc-nightly.org/xbmc/cores/paplayer/ICodec.h	2014-01-24 22:02:28.281044554 -0800
+++ xbmc-nightly/xbmc/cores/paplayer/ICodec.h	2014-02-14 18:27:05.139589690 -0800
@@ -25,6 +25,7 @@
 #include "music/tags/MusicInfoTag.h"
 
 #include "cores/AudioEngine/AEAudioFormat.h"
+#include "cores/AudioEngine/Utils/AEUtil.h"
 
 #define READ_EOF      -1
 #define READ_SUCCESS   0
@@ -94,8 +95,7 @@
 
   // GetChannelInfo()
   // Return the channel layout and count information in an CAEChannelInfo object
-  // Implemented in PAPlayer.cpp to avoid an include here
-  virtual CAEChannelInfo GetChannelInfo(); 
+  virtual CAEChannelInfo GetChannelInfo() {return CAEUtil::GuessChLayout(m_Channels);}
 
   int64_t m_TotalTime;  // time in ms
   int m_SampleRate;
diff -Nur xbmc-nightly.org/xbmc/cores/paplayer/Makefile.in xbmc-nightly/xbmc/cores/paplayer/Makefile.in
--- xbmc-nightly.org/xbmc/cores/paplayer/Makefile.in	2014-01-24 22:02:28.283044808 -0800
+++ xbmc-nightly/xbmc/cores/paplayer/Makefile.in	2014-02-14 18:27:05.139589690 -0800
@@ -7,24 +7,26 @@
 CXXFLAGS += -DHAS_ALSA
 endif
 
-SRCS  = ADPCMCodec.cpp
+SRCS = DVDPlayerCodec.cpp
+SRCS += WAVcodec.cpp
+SRCS += TimidityCodec.cpp
+SRCS += OggCallback.cpp
+ifeq (@USE_PAPLAYER@,1)
+SRCS  += ADPCMCodec.cpp
 SRCS += AudioDecoder.cpp
 SRCS += CDDAcodec.cpp
 SRCS += CodecFactory.cpp
-SRCS += DVDPlayerCodec.cpp
 SRCS += FLACcodec.cpp
 SRCS += ModplugCodec.cpp
 SRCS += MP3codec.cpp
 SRCS += NSFCodec.cpp
-SRCS += OggCallback.cpp
 SRCS += OGGcodec.cpp
 SRCS += PAPlayer.cpp
 SRCS += PCMCodec.cpp
 SRCS += SIDCodec.cpp
-SRCS += TimidityCodec.cpp
 SRCS += VGMCodec.cpp
-SRCS += WAVcodec.cpp
 SRCS += YMCodec.cpp
+endif
 
 ifeq (@USE_ASAP_CODEC@,1)
 SRCS += ASAPCodec.cpp
diff -Nur xbmc-nightly.org/xbmc/cores/playercorefactory/PlayerCoreConfig.h xbmc-nightly/xbmc/cores/playercorefactory/PlayerCoreConfig.h
--- xbmc-nightly.org/xbmc/cores/playercorefactory/PlayerCoreConfig.h	2014-01-24 22:02:28.289045573 -0800
+++ xbmc-nightly/xbmc/cores/playercorefactory/PlayerCoreConfig.h	2014-02-14 18:27:05.140589817 -0800
@@ -19,17 +19,25 @@
  *
  */
 
+#include "system.h"
 #include "utils/XBMCTinyXML.h"
 #include "cores/IPlayer.h"
 #include "PlayerCoreFactory.h"
+#ifdef HAS_DVDPLAYER
 #include "cores/dvdplayer/DVDPlayer.h"
+#endif
+#ifdef HAS_PAPLAYER
 #include "cores/paplayer/PAPlayer.h"
+#endif
 #if defined(HAS_AMLPLAYER)
 #include "cores/amlplayer/AMLPlayer.h"
 #endif
 #if defined(HAS_OMXPLAYER)
 #include "cores/omxplayer/OMXPlayer.h"
 #endif
+#ifdef HAS_GSTPLAYER
+#include "cores/gstplayer/GSTPlayer.h"
+#endif
 #include "cores/ExternalPlayer/ExternalPlayer.h"
 #include "utils/log.h"
 
@@ -75,6 +83,7 @@
     IPlayer* pPlayer;
     switch(m_eCore)
     {
+#ifdef HAS_DVDPLAYER
       case EPC_MPLAYER:
       // TODO: this hack needs removal until we have a better player selection
 #if defined(HAS_OMXPLAYER)
@@ -88,6 +97,9 @@
         break;
 #else
       case EPC_DVDPLAYER: pPlayer = new CDVDPlayer(callback); break;
+#endif
+#endif
+#ifdef HAS_PAPLAYER
       case EPC_PAPLAYER: pPlayer = new PAPlayer(callback); break;
 #endif
       case EPC_EXTPLAYER: pPlayer = new CExternalPlayer(callback); break;
@@ -97,6 +109,9 @@
 #if defined(HAS_OMXPLAYER)
       case EPC_OMXPLAYER: pPlayer = new COMXPlayer(callback); break;
 #endif
+#ifdef HAS_GSTPLAYER
+      case EPC_GSTPLAYER: pPlayer = new GSTPlayer(callback); break;
+#endif
       default: return NULL;
     }
 
diff -Nur xbmc-nightly.org/xbmc/cores/playercorefactory/PlayerCoreFactory.cpp xbmc-nightly/xbmc/cores/playercorefactory/PlayerCoreFactory.cpp
--- xbmc-nightly.org/xbmc/cores/playercorefactory/PlayerCoreFactory.cpp	2014-01-24 22:02:28.290045700 -0800
+++ xbmc-nightly/xbmc/cores/playercorefactory/PlayerCoreFactory.cpp	2014-02-14 18:27:05.140589817 -0800
@@ -18,12 +18,20 @@
  *
  */
 
+#include "system.h"
 #include "utils/BitstreamStats.h"
 #include "PlayerCoreFactory.h"
 #include "threads/SingleLock.h"
+#ifdef HAS_DVDPLAYER
 #include "cores/dvdplayer/DVDPlayer.h"
+#endif
+#ifdef HAS_PAPLAYER
 #include "cores/paplayer/PAPlayer.h"
 #include "cores/paplayer/DVDPlayerCodec.h"
+#endif
+#ifdef HAS_GSTPLAYER
+#include "cores/gstplayer/GSTPlayer.h"
+#endif
 #include "dialogs/GUIDialogContextMenu.h"
 #include "utils/HttpHeader.h"
 #include "settings/GUISettings.h"
@@ -144,6 +152,7 @@
 
   CLog::Log(LOGDEBUG, "CPlayerCoreFactory::GetPlayers: matched %"PRIuS" rules with players", vecCores.size());
 
+#ifdef HAS_PAPLAYER
   if( PAPlayer::HandlesType(url.GetFileType()) )
   {
     // We no longer force PAPlayer as our default audio player (used to be true):
@@ -181,6 +190,7 @@
       }
     }
   }
+#endif
 
   // Process defaults
 
@@ -267,6 +277,7 @@
       delete *it;
     s_vecCoreConfigs.clear();
     // Builtin players; hard-coded because re-ordering them would break scripts
+#ifdef HAS_DVDPLAYER
     CPlayerCoreConfig* dvdplayer = new CPlayerCoreConfig("DVDPlayer", EPC_DVDPLAYER, NULL);
     dvdplayer->m_bPlaysAudio = dvdplayer->m_bPlaysVideo = true;
     s_vecCoreConfigs.push_back(dvdplayer);
@@ -274,10 +285,13 @@
      // Don't remove this, its a placeholder for the old MPlayer core, it would break scripts
     CPlayerCoreConfig* mplayer = new CPlayerCoreConfig("oldmplayercore", EPC_DVDPLAYER, NULL);
     s_vecCoreConfigs.push_back(mplayer);
+#endif
 
+#ifdef HAS_PAPLAYER
     CPlayerCoreConfig* paplayer = new CPlayerCoreConfig("PAPlayer", EPC_PAPLAYER, NULL);
     paplayer->m_bPlaysAudio = true;
     s_vecCoreConfigs.push_back(paplayer);
+#endif
 
 #if defined(HAS_AMLPLAYER)
     CPlayerCoreConfig* amlplayer = new CPlayerCoreConfig("AMLPlayer", EPC_AMLPLAYER, NULL);
@@ -293,6 +307,13 @@
     s_vecCoreConfigs.push_back(omxplayer);
 #endif
 
+#ifdef HAS_GSTPLAYER
+    CPlayerCoreConfig* gstplayer = new CPlayerCoreConfig("GSTPlayer", EPC_GSTPLAYER, NULL);
+    gstplayer->m_bPlaysAudio = true;
+    gstplayer->m_bPlaysVideo = true;
+    s_vecCoreConfigs.push_back(gstplayer);
+#endif
+
     for(std::vector<CPlayerSelectionRule *>::iterator it = s_vecCoreSelectionRules.begin(); it != s_vecCoreSelectionRules.end(); it++)
       delete *it;
     s_vecCoreSelectionRules.clear();
@@ -316,8 +337,15 @@
       type.ToLower();
 
       EPLAYERCORES eCore = EPC_NONE;
+#ifdef HAS_DVDPLAYER
       if (type == "dvdplayer" || type == "mplayer") eCore = EPC_DVDPLAYER;
+#endif
+#ifdef HAS_PAPLAYER
       if (type == "paplayer" ) eCore = EPC_PAPLAYER;
+#endif
+#ifdef HAS_GSTPLAYER
+      if (type == "gstplayer" ) eCore = EPC_GSTPLAYER;
+#endif
       if (type == "externalplayer" ) eCore = EPC_EXTPLAYER;
 
       if (eCore != EPC_NONE)
diff -Nur xbmc-nightly.org/xbmc/cores/playercorefactory/PlayerCoreFactory.h xbmc-nightly/xbmc/cores/playercorefactory/PlayerCoreFactory.h
--- xbmc-nightly.org/xbmc/cores/playercorefactory/PlayerCoreFactory.h	2014-01-24 22:02:28.290045700 -0800
+++ xbmc-nightly/xbmc/cores/playercorefactory/PlayerCoreFactory.h	2014-02-14 18:27:05.141589944 -0800
@@ -33,30 +33,28 @@
 enum EPLAYERCORES
 {
   EPC_NONE,
+#ifdef HAS_DVDPLAYER
   EPC_DVDPLAYER,
   EPC_MPLAYER,
+#endif
+#ifdef HAS_PAPLAYER
   EPC_PAPLAYER,
+#endif
 #if defined(HAS_AMLPLAYER)
   EPC_AMLPLAYER,
 #endif
 #if defined(HAS_OMXPLAYER)
   EPC_OMXPLAYER,
 #endif
+#ifdef HAS_GSTPLAYER
+  EPC_GSTPLAYER,
+#endif
   EPC_EXTPLAYER
 };
 
 typedef unsigned int PLAYERCOREID;
 typedef std::vector<PLAYERCOREID> VECPLAYERCORES;
 const PLAYERCOREID PCID_NONE = EPC_NONE;
-const PLAYERCOREID PCID_DVDPLAYER = EPC_DVDPLAYER;
-const PLAYERCOREID PCID_MPLAYER = EPC_MPLAYER;
-const PLAYERCOREID PCID_PAPLAYER = EPC_PAPLAYER;
-#if defined(HAS_AMLPLAYER)
-const PLAYERCOREID PCID_AMLPLAYER = EPC_AMLPLAYER;
-#endif
-#if defined(HAS_OMXPLAYER)
-const PLAYERCOREID PCID_OMXPLAYER = EPC_OMXPLAYER;
-#endif
 
 class CPlayerCoreFactory
 {
diff -Nur xbmc-nightly.org/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp xbmc-nightly/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp
--- xbmc-nightly.org/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp	2014-01-24 22:02:28.205034895 -0800
+++ xbmc-nightly/xbmc/cores/VideoRenderers/LinuxRendererGLES.cpp	2014-02-14 18:27:05.142590071 -0800
@@ -23,7 +23,7 @@
   #include "config.h"
 #endif
 
-#if HAS_GLES == 2
+#if HAS_GLES == 2 || HAS_GLES == 1
 #include "system_gl.h"
 
 #include <locale.h>
@@ -32,22 +32,28 @@
 #include "utils/fastmemcpy.h"
 #include "utils/MathUtils.h"
 #include "utils/GLUtils.h"
+#include "utils/log.h"
 #include "settings/Settings.h"
 #include "settings/AdvancedSettings.h"
 #include "settings/GUISettings.h"
+#if HAS_GLES == 2 
 #include "guilib/FrameBufferObject.h"
 #include "VideoShaders/YUV2RGBShader.h"
 #include "VideoShaders/VideoFilterShader.h"
+#endif
 #include "windowing/WindowingFactory.h"
 #include "dialogs/GUIDialogKaiToast.h"
 #include "guilib/Texture.h"
+#if HAS_GLES == 2 
 #include "lib/DllSwScale.h"
 #include "../dvdplayer/DVDCodecs/Video/OpenMaxVideo.h"
+#endif
 #include "threads/SingleLock.h"
 #include "RenderCapture.h"
 #include "RenderFormats.h"
 #include "xbmc/Application.h"
 
+#if HAS_GLES == 2 
 #if defined(__ARM_NEON__)
 #include "yuv2rgb.neon.h"
 #include "utils/CPUInfo.h"
@@ -56,10 +62,12 @@
 #include "DVDCodecs/Video/DVDVideoCodecVideoToolBox.h"
 #include <CoreVideo/CoreVideo.h>
 #endif
+#endif
 #ifdef TARGET_DARWIN_IOS
 #include "osx/DarwinUtils.h"
 #endif
 
+#if HAS_GLES == 2 
 using namespace Shaders;
 
 CLinuxRendererGLES::YUVBUFFER::YUVBUFFER()
@@ -72,6 +80,7 @@
 CLinuxRendererGLES::YUVBUFFER::~YUVBUFFER()
 {
 }
+#endif
 
 CLinuxRendererGLES::CLinuxRendererGLES()
 {
@@ -79,29 +88,44 @@
   for (int i = 0; i < NUM_BUFFERS; i++)
   {
     m_eventTexturesDone[i] = new CEvent(false,true);
+#if HAS_GLES == 2 
 #if defined(HAVE_LIBOPENMAX)
     m_buffers[i].openMaxBuffer = 0;
 #endif
 #ifdef HAVE_VIDEOTOOLBOXDECODER
     m_buffers[i].cvBufferRef = NULL;
 #endif
+#endif
   }
 
+#if HAS_GLES == 1
+  m_renderMethod = RENDER_BYPASS;
+#else
   m_renderMethod = RENDER_GLSL;
-  m_oldRenderMethod = m_renderMethod;
+#endif
   m_renderQuality = RQ_SINGLEPASS;
   m_iFlags = 0;
   m_format = RENDER_FMT_NONE;
 
+#if HAS_GLES == 2 
   m_iYV12RenderBuffer = 0;
+#endif
   m_flipindex = 0;
   m_currentField = FIELD_FULL;
+#if HAS_GLES == 2 
   m_reloadShaders = 0;
   m_pYUVShader = NULL;
   m_pVideoFilterShader = NULL;
+#endif
   m_scalingMethod = VS_SCALINGMETHOD_LINEAR;
   m_scalingMethodGui = (ESCALINGMETHOD)-1;
 
+#if HAS_GLES == 1
+  // default texture handlers to ByPASS
+  m_textureUpload = &CLinuxRendererGLES::UploadBYPASSTexture;
+  m_textureCreate = &CLinuxRendererGLES::CreateBYPASSTexture;
+  m_textureDelete = &CLinuxRendererGLES::DeleteBYPASSTexture;
+#else
   // default texture handlers to YUV
   m_textureUpload = &CLinuxRendererGLES::UploadYV12Texture;
   m_textureCreate = &CLinuxRendererGLES::CreateYV12Texture;
@@ -112,6 +136,7 @@
 
   m_dllSwScale = new DllSwScale;
   m_sw_context = NULL;
+#endif
 }
 
 CLinuxRendererGLES::~CLinuxRendererGLES()
@@ -120,6 +145,7 @@
   for (int i = 0; i < NUM_BUFFERS; i++)
     delete m_eventTexturesDone[i];
 
+#if HAS_GLES == 2 
   if (m_rgbBuffer != NULL) {
     delete [] m_rgbBuffer;
     m_rgbBuffer = NULL;
@@ -133,12 +159,15 @@
   }
 
   delete m_dllSwScale;
+#endif
 }
 
 void CLinuxRendererGLES::ManageTextures()
 {
+#if HAS_GLES == 2 
   m_NumYV12Buffers = 2;
   //m_iYV12RenderBuffer = 0;
+#endif
   return;
 }
 
@@ -148,11 +177,13 @@
   {
     CLog::Log(LOGNOTICE,"Using GL_TEXTURE_2D");
 
+#if HAS_GLES == 2 
      // create the yuv textures
     LoadShaders();
 
     for (int i = 0 ; i < m_NumYV12Buffers ; i++)
       (this->*m_textureCreate)(i);
+#endif
 
     m_bValidated = true;
     return true;
@@ -184,8 +215,10 @@
   // frame is loaded after every call to Configure().
   m_bValidated = false;
 
+#if HAS_GLES == 2 
   for (int i = 0 ; i<m_NumYV12Buffers ; i++)
     m_buffers[i].image.flags = 0;
+#endif
 
   m_iLastRenderBuffer = -1;
 
@@ -202,13 +235,16 @@
   return true;
 }
 
+#if HAS_GLES == 2 
 int CLinuxRendererGLES::NextYV12Texture()
 {
   return (m_iYV12RenderBuffer + 1) % m_NumYV12Buffers;
 }
+#endif
 
 int CLinuxRendererGLES::GetImage(YV12Image *image, int source, bool readonly)
 {
+#if HAS_GLES == 2 
   if (!image) return -1;
   if (!m_bValidated) return -1;
 
@@ -259,12 +295,14 @@
   image->bpp      = 1;
 
   return source;
+#endif
 
   return -1;
 }
 
 void CLinuxRendererGLES::ReleaseImage(int source, bool preserve)
 {
+#if HAS_GLES == 2 
   YV12Image &im = m_buffers[source].image;
 
   if( im.flags & IMAGE_FLAG_WRITING )
@@ -276,10 +314,11 @@
 
   if( preserve )
     im.flags |= IMAGE_FLAG_RESERVED;
-
+#endif
   m_bImageReady = true;
 }
 
+#if HAS_GLES == 2 
 void CLinuxRendererGLES::CalculateTextureSourceRects(int source, int num_planes)
 {
   YUVBUFFER& buf    =  m_buffers[source];
@@ -338,7 +377,9 @@
     }
   }
 }
+#endif
 
+#if HAS_GLES == 2 
 void CLinuxRendererGLES::LoadPlane( YUVPLANE& plane, int type, unsigned flipindex
                                 , unsigned width, unsigned height
                                 , int stride, void* data )
@@ -379,9 +420,11 @@
 
   plane.flipindex = flipindex;
 }
+#endif
 
 void CLinuxRendererGLES::Reset()
 {
+#if HAS_GLES == 2 
   for(int i=0; i<m_NumYV12Buffers; i++)
   {
     /* reset all image flags, this will cleanup textures later */
@@ -389,6 +432,7 @@
     /* reset texture locks, a bit ugly, could result in tearing */
     m_eventTexturesDone[i]->Set();
   }
+#endif
 }
 
 void CLinuxRendererGLES::Update(bool bPauseDrawing)
@@ -435,6 +479,7 @@
     return;
   }
 
+#if HAS_GLES == 2 
   // this needs to be checked after texture validation
   if (!m_bImageReady) return;
 
@@ -497,16 +542,19 @@
   glEnable(GL_BLEND);
 
   g_graphicsContext.EndPaint();
+#endif
 }
 
 void CLinuxRendererGLES::FlipPage(int source)
 {
+#if HAS_GLES == 2 
   if( source >= 0 && source < m_NumYV12Buffers )
     m_iYV12RenderBuffer = source;
   else
     m_iYV12RenderBuffer = NextYV12Texture();
 
   m_buffers[m_iYV12RenderBuffer].flipindex = ++m_flipindex;
+#endif
 
   return;
 }
@@ -521,10 +569,12 @@
   if ( m_resolution == RES_WINDOW )
     m_resolution = RES_DESKTOP;
 
+#if HAS_GLES == 2 
   m_iYV12RenderBuffer = 0;
   m_NumYV12Buffers = 2;
 
   m_formats.push_back(RENDER_FMT_YUV420P);
+#endif
   m_formats.push_back(RENDER_FMT_BYPASS);
 #if defined(HAVE_LIBOPENMAX)
   m_formats.push_back(RENDER_FMT_OMXEGL);
@@ -536,12 +586,15 @@
   // setup the background colour
   m_clearColour = (float)(g_advancedSettings.m_videoBlackBarColour & 0xff) / 0xff;
 
+#if HAS_GLES == 2 
   if (!m_dllSwScale->Load())
     CLog::Log(LOGERROR,"CLinuxRendererGL::PreInit - failed to load rescale libraries!");
+#endif
 
   return true;
 }
 
+#if HAS_GLES == 2 
 void CLinuxRendererGLES::UpdateVideoFilter()
 {
   if (m_scalingMethodGui == g_settings.m_currentVideoSettings.m_ScalingMethod)
@@ -605,7 +658,9 @@
   SetTextureFilter(GL_LINEAR);
   m_renderQuality = RQ_SINGLEPASS;
 }
+#endif
 
+#if HAS_GLES == 2 
 void CLinuxRendererGLES::LoadShaders(int field)
 {
 #ifdef TARGET_DARWIN_IOS
@@ -720,11 +775,13 @@
     m_oldRenderMethod = m_renderMethod;
   }
 }
+#endif
 
 void CLinuxRendererGLES::UnInit()
 {
   CLog::Log(LOGDEBUG, "LinuxRendererGL: Cleaning up GL resources");
   CSingleLock lock(g_graphicsContext);
+#if HAS_GLES == 2 
 
   if (m_rgbBuffer != NULL)
   {
@@ -744,6 +801,7 @@
   }
   // cleanup framebuffer object if it was in use
   m_fbo.Cleanup();
+#endif
   m_bValidated = false;
   m_bImageReady = false;
   m_bConfigured = false;
@@ -754,6 +812,7 @@
 inline void CLinuxRendererGLES::ReorderDrawPoints()
 {
 
+#if HAS_GLES == 2 
   CBaseRenderer::ReorderDrawPoints();//call base impl. for rotating the points
 
   //corevideo is flipped in y
@@ -767,6 +826,7 @@
     m_rotatedDestCoords[1] = m_rotatedDestCoords[2];
     m_rotatedDestCoords[2] = tmp;
   }
+#endif 
 }
 
 void CLinuxRendererGLES::Render(DWORD flags, int index)
@@ -775,6 +835,7 @@
   if (m_renderMethod & RENDER_BYPASS)
     return;
 
+#if HAS_GLES == 2 
   // obtain current field, if interlaced
   if( flags & RENDER_FLAG_TOP)
     m_currentField = FIELD_TOP;
@@ -824,8 +885,10 @@
     RenderSoftware(index, m_currentField);
     VerifyGLState();
   }
+#endif
 }
 
+#if HAS_GLES == 2 
 void CLinuxRendererGLES::RenderSinglePass(int index, int field)
 {
   YV12Image &im     = m_buffers[index].image;
@@ -931,7 +994,9 @@
 
   VerifyGLState();
 }
+#endif
 
+#if HAS_GLES == 2 
 void CLinuxRendererGLES::RenderMultiPass(int index, int field)
 {
   // TODO: Multipass rendering does not currently work! FIX!
@@ -1121,7 +1186,9 @@
   glDisable(m_textureTarget);
   VerifyGLState();
 }
+#endif
 
+#if HAS_GLES == 2 
 void CLinuxRendererGLES::RenderSoftware(int index, int field)
 {
   YUVPLANES &planes = m_buffers[index].fields[field];
@@ -1183,7 +1250,9 @@
   glDisable(m_textureTarget);
   VerifyGLState();
 }
+#endif
 
+#if HAS_GLES == 2 
 void CLinuxRendererGLES::RenderOpenMax(int index, int field)
 {
 #if defined(HAVE_LIBOPENMAX)
@@ -1249,7 +1318,9 @@
   VerifyGLState();
 #endif
 }
+#endif
 
+#if HAS_GLES == 2 
 void CLinuxRendererGLES::RenderCoreVideoRef(int index, int field)
 {
 #ifdef HAVE_VIDEOTOOLBOXDECODER
@@ -1313,9 +1384,11 @@
   VerifyGLState();
 #endif
 }
+#endif
 
 bool CLinuxRendererGLES::RenderCapture(CRenderCapture* capture)
 {
+#if HAS_GLES == 2 
   if (!m_bValidated)
     return false;
 
@@ -1367,12 +1440,14 @@
   m_destRect = saveSize;
   restoreRotatedCoords();//restores the previous state of the rotated dest coords
 
+#endif
   return true;
 }
 
 //********************************************************************************************************
 // YV12 Texture creation, deletion, copying + clearing
 //********************************************************************************************************
+#if HAS_GLES == 2 
 void CLinuxRendererGLES::UploadYV12Texture(int source)
 {
   YUVBUFFER& buf    =  m_buffers[source];
@@ -1519,7 +1594,9 @@
 
   glDisable(m_textureTarget);
 }
+#endif
 
+#if HAS_GLES == 2 
 void CLinuxRendererGLES::DeleteYV12Texture(int index)
 {
   YV12Image &im     = m_buffers[index].image;
@@ -1552,7 +1629,9 @@
     }
   }
 }
+#endif
 
+#if HAS_GLES == 2 
 bool CLinuxRendererGLES::CreateYV12Texture(int index)
 {
   /* since we also want the field textures, pitch must be texture aligned */
@@ -1661,10 +1740,12 @@
   m_eventTexturesDone[index]->Set();
   return true;
 }
+#endif
 
 //********************************************************************************************************
 // CoreVideoRef Texture creation, deletion, copying + clearing
 //********************************************************************************************************
+#if HAS_GLES == 2
 void CLinuxRendererGLES::UploadCVRefTexture(int index)
 {
 #ifdef HAVE_VIDEOTOOLBOXDECODER
@@ -1721,6 +1802,8 @@
   m_eventTexturesDone[index]->Set();
 #endif
 }
+#endif
+#if HAS_GLES == 2
 void CLinuxRendererGLES::DeleteCVRefTexture(int index)
 {
 #ifdef HAVE_VIDEOTOOLBOXDECODER
@@ -1735,6 +1818,8 @@
   plane.id = 0;
 #endif
 }
+#endif
+#if HAS_GLES == 2
 bool CLinuxRendererGLES::CreateCVRefTexture(int index)
 {
 #ifdef HAVE_VIDEOTOOLBOXDECODER
@@ -1795,6 +1880,7 @@
 #endif
   return true;
 }
+#endif
 
 //********************************************************************************************************
 // BYPASS creation, deletion, copying + clearing
@@ -1812,6 +1898,7 @@
   return true;
 }
 
+#if HAS_GLES == 2 
 void CLinuxRendererGLES::SetTextureFilter(GLenum method)
 {
   for (int i = 0 ; i<m_NumYV12Buffers ; i++)
@@ -1840,9 +1927,11 @@
     }
   }
 }
+#endif
 
 bool CLinuxRendererGLES::Supports(ERENDERFEATURE feature)
 {
+#if HAS_GLES == 2 
   // Player controls render, let it dictate available render features
   if((m_renderMethod & RENDER_BYPASS))
   {
@@ -1876,18 +1965,21 @@
       feature == RENDERFEATURE_POSTPROCESS     ||
       feature == RENDERFEATURE_ROTATION)
     return true;
-
+#endif
 
   return false;
 }
 
+#if HAS_GLES == 2 
 bool CLinuxRendererGLES::SupportsMultiPassRendering()
 {
   return false;
 }
+#endif
 
 bool CLinuxRendererGLES::Supports(EDEINTERLACEMODE mode)
 {
+#if HAS_GLES == 2 
   // Player controls render, let it dictate available deinterlace modes
   if((m_renderMethod & RENDER_BYPASS))
   {
@@ -1907,12 +1999,14 @@
   if(mode == VS_DEINTERLACEMODE_AUTO
   || mode == VS_DEINTERLACEMODE_FORCE)
     return true;
+#endif
 
   return false;
 }
 
 bool CLinuxRendererGLES::Supports(EINTERLACEMETHOD method)
 {
+#if HAS_GLES == 2 
   // Player controls render, let it dictate available deinterlace methods
   if((m_renderMethod & RENDER_BYPASS))
   {
@@ -1937,12 +2031,14 @@
   if(method == VS_INTERLACEMETHOD_SW_BLEND)
 #endif
     return true;
+#endif
 
   return false;
 }
 
 bool CLinuxRendererGLES::Supports(ESCALINGMETHOD method)
 {
+#if HAS_GLES == 2 
   // Player controls render, let it dictate available scaling methods
   if((m_renderMethod & RENDER_BYPASS))
   {
@@ -1953,12 +2049,14 @@
   if(method == VS_SCALINGMETHOD_NEAREST
   || method == VS_SCALINGMETHOD_LINEAR)
     return true;
+#endif
 
   return false;
 }
 
 EINTERLACEMETHOD CLinuxRendererGLES::AutoInterlaceMethod()
 {
+#if HAS_GLES == 2 
   // Player controls render, let it pick the auto-deinterlace method
   if((m_renderMethod & RENDER_BYPASS))
   {
@@ -1979,8 +2077,10 @@
 #else
   return VS_INTERLACEMETHOD_SW_BLEND;
 #endif
+#endif
 }
 
+#if HAS_GLES == 2 
 #ifdef HAVE_LIBOPENMAX
 void CLinuxRendererGLES::AddProcessor(COpenMax* openMax, DVDVideoPicture *picture)
 {
@@ -1988,6 +2088,8 @@
   buf.openMaxBuffer = picture->openMaxBuffer;
 }
 #endif
+#endif
+#if HAS_GLES == 2 
 #ifdef HAVE_VIDEOTOOLBOXDECODER
 void CLinuxRendererGLES::AddProcessor(struct __CVBuffer *cvBufferRef)
 {
@@ -2002,3 +2104,4 @@
 
 #endif
 
+#endif
diff -Nur xbmc-nightly.org/xbmc/cores/VideoRenderers/LinuxRendererGLES.h xbmc-nightly/xbmc/cores/VideoRenderers/LinuxRendererGLES.h
--- xbmc-nightly.org/xbmc/cores/VideoRenderers/LinuxRendererGLES.h	2014-01-24 22:02:28.206035022 -0800
+++ xbmc-nightly/xbmc/cores/VideoRenderers/LinuxRendererGLES.h	2014-02-14 18:27:05.143590198 -0800
@@ -21,11 +21,13 @@
  *
  */
 
-#if HAS_GLES == 2
+#if HAS_GLES == 2 || HAS_GLES == 1
 
 #include "system_gl.h"
 
+#if HAS_GLES == 2
 #include "xbmc/guilib/FrameBufferObject.h"
+#endif
 #include "xbmc/guilib/Shader.h"
 #include "settings/VideoSettings.h"
 #include "RenderFlags.h"
@@ -36,9 +38,11 @@
 class CRenderCapture;
 
 class CBaseTexture;
+#if HAS_GLES == 2 
 namespace Shaders { class BaseYUV2RGBShader; }
 namespace Shaders { class BaseVideoFilterShader; }
 class COpenMaxVideo;
+#endif
 typedef std::vector<int>     Features;
 
 #define NUM_BUFFERS 3
@@ -65,6 +69,7 @@
   float bottom;
 };
 
+#if HAS_GLES == 2 
 struct YUVRANGE
 {
   int y_min, y_max;
@@ -78,14 +83,16 @@
   float g_up, g_vp;
   float b_up, b_vp;
 };
-
+#endif
 enum RenderMethod
 {
+#if HAS_GLES == 2 
   RENDER_GLSL   = 0x001,
   RENDER_SW     = 0x004,
   RENDER_POT    = 0x010,
   RENDER_OMXEGL = 0x040,
   RENDER_CVREF  = 0x080,
+#endif
   RENDER_BYPASS = 0x100
 };
 
@@ -105,6 +112,7 @@
 #define FIELD_TOP 1
 #define FIELD_BOT 2
 
+#if HAS_GLES == 2 
 extern YUVRANGE yuv_range_lim;
 extern YUVRANGE yuv_range_full;
 extern YUVCOEF yuv_coef_bt601;
@@ -114,6 +122,7 @@
 
 class DllSwScale;
 struct SwsContext;
+#endif
 
 class CEvent;
 
@@ -142,7 +151,9 @@
   virtual void RenderUpdate(bool clear, DWORD flags = 0, DWORD alpha = 255);
 
   // Feature support
+#if HAS_GLES == 2 
   virtual bool SupportsMultiPassRendering();
+#endif
   virtual bool Supports(ERENDERFEATURE feature);
   virtual bool Supports(EDEINTERLACEMODE mode);
   virtual bool Supports(EINTERLACEMETHOD method);
@@ -165,15 +176,17 @@
   virtual void ManageTextures();
   int  NextYV12Texture();
   virtual bool ValidateRenderTarget();
+#if HAS_GLES == 2 
   virtual void LoadShaders(int field=FIELD_FULL);
   void SetTextureFilter(GLenum method);
   void UpdateVideoFilter();
-
+#endif
   // textures
   void (CLinuxRendererGLES::*m_textureUpload)(int index);
   void (CLinuxRendererGLES::*m_textureDelete)(int index);
   bool (CLinuxRendererGLES::*m_textureCreate)(int index);
 
+#if HAS_GLES == 2 
   void UploadYV12Texture(int index);
   void DeleteYV12Texture(int index);
   bool CreateYV12Texture(int index);
@@ -181,6 +194,7 @@
   void UploadCVRefTexture(int index);
   void DeleteCVRefTexture(int index);
   bool CreateCVRefTexture(int index);
+#endif
 
   void UploadBYPASSTexture(int index);
   void DeleteBYPASSTexture(int index);
@@ -189,6 +203,7 @@
   void CalculateTextureSourceRects(int source, int num_planes);
 
   // renderers
+#if HAS_GLES == 2 
   void RenderMultiPass(int index, int field);     // multi pass glsl renderer
   void RenderSinglePass(int index, int field);    // single pass glsl renderer
   void RenderSoftware(int index, int field);      // single pass s/w yuv2rgb renderer
@@ -199,6 +214,7 @@
 
   int m_iYV12RenderBuffer;
   int m_NumYV12Buffers;
+#endif
   int m_iLastRenderBuffer;
 
   bool m_bConfigured;
@@ -217,6 +233,7 @@
   int m_currentField;
   int m_reloadShaders;
 
+#if HAS_GLES == 2 
   struct YUVPLANE
   {
     GLuint id;
@@ -264,6 +281,7 @@
 
   Shaders::BaseYUV2RGBShader     *m_pYUVShader;
   Shaders::BaseVideoFilterShader *m_pVideoFilterShader;
+#endif
   ESCALINGMETHOD m_scalingMethod;
   ESCALINGMETHOD m_scalingMethodGui;
 
@@ -276,10 +294,12 @@
   float m_clearColour;
 
   // software scale libraries (fallback if required gl version is not available)
+#if HAS_GLES == 2 
   DllSwScale  *m_dllSwScale;
   struct SwsContext *m_sw_context;
   BYTE	      *m_rgbBuffer;  // if software scale is used, this will hold the result image
   unsigned int m_rgbBufferSize;
+#endif
 
   CEvent* m_eventTexturesDone[NUM_BUFFERS];
 
diff -Nur xbmc-nightly.org/xbmc/cores/VideoRenderers/Makefile.in xbmc-nightly/xbmc/cores/VideoRenderers/Makefile.in
--- xbmc-nightly.org/xbmc/cores/VideoRenderers/Makefile.in	2014-01-24 22:02:28.206035022 -0800
+++ xbmc-nightly/xbmc/cores/VideoRenderers/Makefile.in	2014-02-14 18:27:05.143590198 -0800
@@ -18,6 +18,10 @@
 SRCS += OverlayRendererGL.cpp
 endif
 
+ifeq (@USE_OPENGLESV1@,1)
+SRCS += LinuxRendererGLES.cpp
+SRCS += OverlayRendererGL.cpp
+endif
 LIB = VideoRenderer.a
 
 include @abs_top_srcdir@/Makefile.include
diff -Nur xbmc-nightly.org/xbmc/cores/VideoRenderers/OverlayRenderer.cpp xbmc-nightly/xbmc/cores/VideoRenderers/OverlayRenderer.cpp
--- xbmc-nightly.org/xbmc/cores/VideoRenderers/OverlayRenderer.cpp	2014-01-24 22:02:28.206035022 -0800
+++ xbmc-nightly/xbmc/cores/VideoRenderers/OverlayRenderer.cpp	2014-02-14 18:27:05.144590325 -0800
@@ -299,7 +299,7 @@
       return o->m_overlay->Acquire();
   }
 
-#if defined(HAS_GL) || defined(HAS_GLES)
+#if defined(HAS_GL) || (defined(HAS_GLES) && HAS_GLES == 2)
   return new COverlayGlyphGL(images, width, height);
 #elif defined(HAS_DX)
   return new COverlayQuadsDX(images, width, height);
@@ -325,7 +325,7 @@
     return r;
   }
 
-#if defined(HAS_GL) || defined(HAS_GLES)
+#if defined(HAS_GL) || (defined(HAS_GLES) && HAS_GLES == 2)
   if     (o->IsOverlayType(DVDOVERLAY_TYPE_IMAGE))
     r = new COverlayTextureGL((CDVDOverlayImage*)o);
   else if(o->IsOverlayType(DVDOVERLAY_TYPE_SPU))
diff -Nur xbmc-nightly.org/xbmc/cores/VideoRenderers/OverlayRendererGL.cpp xbmc-nightly/xbmc/cores/VideoRenderers/OverlayRendererGL.cpp
--- xbmc-nightly.org/xbmc/cores/VideoRenderers/OverlayRendererGL.cpp	2014-01-24 22:02:28.207035149 -0800
+++ xbmc-nightly/xbmc/cores/VideoRenderers/OverlayRendererGL.cpp	2014-02-14 18:27:05.145590452 -0800
@@ -25,7 +25,7 @@
 #include "OverlayRendererGL.h"
 #ifdef HAS_GL
   #include "LinuxRendererGL.h"
-#elif HAS_GLES == 2
+#elif HAS_GLES == 2 || HAS_GLES == 1
   #include "LinuxRendererGLES.h"
   #include "guilib/MatrixGLES.h"
 #endif
@@ -40,9 +40,9 @@
 #include "utils/GLUtils.h"
 #include "RenderManager.h"
 
-#if defined(HAS_GL) || HAS_GLES == 2
+#if defined(HAS_GL) || HAS_GLES == 2 || HAS_GLES == 1
 
-#if HAS_GLES == 2
+#if HAS_GLES == 2 || HAS_GLES == 1
 // GLES2.0 cant do CLAMP, but can do CLAMP_TO_EDGE.
 #define GL_CLAMP	GL_CLAMP_TO_EDGE
 #endif
@@ -421,6 +421,7 @@
 
   glPopMatrix();
 #else
+#if defined(HAS_GL) || HAS_GLES == 2
   g_matrices.MatrixMode(MM_MODELVIEW);
   g_matrices.PushMatrix();
   g_matrices.Translatef(state.x, state.y, 0.0f);
@@ -468,6 +469,7 @@
 
   g_matrices.PopMatrix();
 #endif
+#endif
 
   glDisable(GL_BLEND);
   glDisable(GL_TEXTURE_2D);
@@ -536,6 +538,7 @@
   glVertex2f(rd.left , rd.bottom);
   glEnd();
 #else
+#if defined(HAS_GL) || HAS_GLES == 2
   g_Windowing.EnableGUIShader(SM_TEXTURE);
 
   GLfloat col[4][4];
@@ -580,6 +583,7 @@
 
   g_Windowing.DisableGUIShader();
 #endif
+#endif
 
   glDisable(GL_BLEND);
   glDisable(GL_TEXTURE_2D);
diff -Nur xbmc-nightly.org/xbmc/cores/VideoRenderers/OverlayRendererGL.cpp.orig xbmc-nightly/xbmc/cores/VideoRenderers/OverlayRendererGL.cpp.orig
--- xbmc-nightly.org/xbmc/cores/VideoRenderers/OverlayRendererGL.cpp.orig	1969-12-31 16:00:00.000000000 -0800
+++ xbmc-nightly/xbmc/cores/VideoRenderers/OverlayRendererGL.cpp.orig	2014-01-24 22:02:28.207035149 -0800
@@ -0,0 +1,590 @@
+/*
+ *      Copyright (C) 2005-2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *      Initial code sponsored by: Voddler Inc (voddler.com)
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#include "system.h"
+#include "OverlayRenderer.h"
+#include "OverlayRendererUtil.h"
+#include "OverlayRendererGL.h"
+#ifdef HAS_GL
+  #include "LinuxRendererGL.h"
+#elif HAS_GLES == 2
+  #include "LinuxRendererGLES.h"
+  #include "guilib/MatrixGLES.h"
+#endif
+#include "RenderManager.h"
+#include "cores/dvdplayer/DVDCodecs/Overlay/DVDOverlayImage.h"
+#include "cores/dvdplayer/DVDCodecs/Overlay/DVDOverlaySpu.h"
+#include "cores/dvdplayer/DVDCodecs/Overlay/DVDOverlaySSA.h"
+#include "windowing/WindowingFactory.h"
+#include "settings/Settings.h"
+#include "utils/MathUtils.h"
+#include "utils/log.h"
+#include "utils/GLUtils.h"
+#include "RenderManager.h"
+
+#if defined(HAS_GL) || HAS_GLES == 2
+
+#if HAS_GLES == 2
+// GLES2.0 cant do CLAMP, but can do CLAMP_TO_EDGE.
+#define GL_CLAMP	GL_CLAMP_TO_EDGE
+#endif
+
+#define USE_PREMULTIPLIED_ALPHA 1
+
+using namespace OVERLAY;
+
+static void LoadTexture(GLenum target
+                      , GLsizei width, GLsizei height, GLsizei stride
+                      , GLfloat* u, GLfloat* v
+                      , GLenum internalFormat, GLenum externalFormat, const GLvoid* pixels)
+{
+  int width2  = NP2(width);
+  int height2 = NP2(height);
+  char *pixelVector = NULL;
+  const GLvoid *pixelData = pixels;
+
+  int bytesPerPixel = glFormatElementByteCount(externalFormat);
+
+#ifdef HAS_GLES
+  /** OpenGL ES does not support strided texture input. Make a copy without stride **/
+  if (stride != width)
+  {
+    int bytesPerLine = bytesPerPixel * width;
+
+    pixelVector = (char *)malloc(bytesPerLine * height);
+
+    const char *src = (const char*)pixels;
+    char *dst = pixelVector;
+    for (int y = 0;y < height;++y)
+    {
+      memcpy(dst, src, bytesPerLine);
+      src += stride;
+      dst += bytesPerLine;
+    }
+
+    pixelData = pixelVector;
+    stride = width;
+  }
+#else
+  glPixelStorei(GL_UNPACK_ROW_LENGTH, stride / bytesPerPixel);
+#endif
+
+  glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
+
+  glTexImage2D   (target, 0, internalFormat
+                , width2, height2, 0
+                , externalFormat, GL_UNSIGNED_BYTE, NULL);
+
+  glTexSubImage2D(target, 0
+                , 0, 0, width, height
+                , externalFormat, GL_UNSIGNED_BYTE
+                , pixelData);
+
+  if(height < height2)
+    glTexSubImage2D( target, 0
+                   , 0, height, width, 1
+                   , externalFormat, GL_UNSIGNED_BYTE
+                   , (unsigned char*)pixelData + stride * (height-1));
+
+  if(width  < width2)
+    glTexSubImage2D( target, 0
+                   , width, 0, 1, height
+                   , externalFormat, GL_UNSIGNED_BYTE
+                   , (unsigned char*)pixelData + bytesPerPixel * (width-1));
+
+#ifndef HAS_GLES
+  glPixelStorei(GL_UNPACK_ROW_LENGTH, 0);
+#endif
+
+  free(pixelVector);
+  
+  *u = (GLfloat)width  / width2;
+  *v = (GLfloat)height / height2;
+}
+
+COverlayTextureGL::COverlayTextureGL(CDVDOverlayImage* o)
+{
+  m_texture = 0;
+
+  uint32_t* rgba;
+  int stride;
+  if(o->palette)
+  {
+    m_pma  = !!USE_PREMULTIPLIED_ALPHA;
+    rgba   = convert_rgba(o, m_pma);
+    stride = o->width * 4;
+  }
+  else
+  {
+    m_pma  = false;
+    rgba   = (uint32_t*)o->data;
+    stride = o->linesize;
+  }
+
+  if(!rgba)
+  {
+    CLog::Log(LOGERROR, "COverlayTextureGL::COverlayTextureGL - failed to convert overlay to rgb");
+    return;
+  }
+
+  glGenTextures(1, &m_texture);
+  glEnable(GL_TEXTURE_2D);
+  glBindTexture(GL_TEXTURE_2D, m_texture);
+
+  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
+  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
+  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+
+  LoadTexture(GL_TEXTURE_2D
+            , o->width
+            , o->height
+            , stride
+            , &m_u, &m_v
+            , GL_RGBA
+#ifdef HAS_GLES
+            , GL_RGBA
+#else
+            , GL_BGRA
+#endif
+            , rgba);
+  if((BYTE*)rgba != o->data)
+    free(rgba);
+
+  glBindTexture(GL_TEXTURE_2D, 0);
+  glDisable(GL_TEXTURE_2D);
+
+  if(o->source_width && o->source_height)
+  {
+    float center_x = (float)(0.5f * o->width  + o->x) / o->source_width;
+    float center_y = (float)(0.5f * o->height + o->y) / o->source_height;
+
+    m_width  = (float)o->width  / o->source_width;
+    m_height = (float)o->height / o->source_height;
+    m_pos    = POSITION_RELATIVE;
+
+#if 0
+    if(center_x > 0.4 && center_x < 0.6
+    && center_y > 0.8 && center_y < 1.0)
+    {
+     /* render bottom aligned to subtitle line */
+      m_align  = ALIGN_SUBTITLE;
+      m_x      = 0.0f;
+      m_y      = - 0.5 * m_height;
+    }
+    else
+#endif
+    {
+      /* render aligned to screen to avoid cropping problems */
+      m_align  = ALIGN_SCREEN;
+      m_x      = center_x;
+      m_y      = center_y;
+    }
+  }
+  else
+  {
+    m_align  = ALIGN_VIDEO;
+    m_pos    = POSITION_ABSOLUTE;
+    m_x      = (float)o->x;
+    m_y      = (float)o->y;
+    m_width  = (float)o->width;
+    m_height = (float)o->height;
+  }
+}
+
+COverlayTextureGL::COverlayTextureGL(CDVDOverlaySpu* o)
+{
+  m_texture = 0;
+
+  int min_x, max_x, min_y, max_y;
+  uint32_t* rgba = convert_rgba(o, USE_PREMULTIPLIED_ALPHA
+                              , min_x, max_x, min_y, max_y);
+
+  if(!rgba)
+  {
+    CLog::Log(LOGERROR, "COverlayTextureGL::COverlayTextureGL - failed to convert overlay to rgb");
+    return;
+  }
+
+  glGenTextures(1, &m_texture);
+  glEnable(GL_TEXTURE_2D);
+  glBindTexture(GL_TEXTURE_2D, m_texture);
+
+  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
+  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
+  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+
+  LoadTexture(GL_TEXTURE_2D
+            , max_x - min_x
+            , max_y - min_y
+            , o->width * 4
+            , &m_u, &m_v
+            , GL_RGBA
+#ifdef HAS_GLES
+            , GL_RGBA
+#else
+            , GL_BGRA
+#endif
+            , rgba + min_x + min_y * o->width);
+
+  free(rgba);
+
+  glBindTexture(GL_TEXTURE_2D, 0);
+  glDisable(GL_TEXTURE_2D);
+
+  m_align  = ALIGN_VIDEO;
+  m_pos    = POSITION_ABSOLUTE;
+  m_x      = (float)(min_x + o->x);
+  m_y      = (float)(min_y + o->y);
+  m_width  = (float)(max_x - min_x);
+  m_height = (float)(max_y - min_y);
+  m_pma    = !!USE_PREMULTIPLIED_ALPHA;
+}
+
+COverlayGlyphGL::COverlayGlyphGL(ASS_Image* images, int width, int height)
+{
+  m_vertex = NULL;
+  m_width  = 1.0;
+  m_height = 1.0;
+  m_align  = ALIGN_VIDEO;
+  m_pos    = POSITION_RELATIVE;
+  m_x      = 0.0f;
+  m_y      = 0.0f;
+  m_texture = 0;
+
+  SQuads quads;
+  if(!convert_quad(images, quads))
+    return;
+
+  glGenTextures(1, &m_texture);
+  glEnable(GL_TEXTURE_2D);
+  glBindTexture(GL_TEXTURE_2D, m_texture);
+
+  LoadTexture(GL_TEXTURE_2D
+            , quads.size_x
+            , quads.size_y
+            , quads.size_x
+            , &m_u, &m_v
+            , GL_ALPHA
+            , GL_ALPHA
+            , quads.data);
+
+
+  float scale_u = m_u / quads.size_x;
+  float scale_v = m_v / quads.size_y;
+
+  float scale_x = 1.0f / width;
+  float scale_y = 1.0f / height;
+
+  m_count  = quads.count;
+  m_vertex = (VERTEX*)calloc(m_count * 4, sizeof(VERTEX));
+
+  VERTEX* vt = m_vertex;
+  SQuad*  vs = quads.quad;
+
+  for(int i=0; i < quads.count; i++)
+  {
+    for(int s = 0; s < 4; s++)
+    {
+      vt[s].a = vs->a;
+      vt[s].r = vs->r;
+      vt[s].g = vs->g;
+      vt[s].b = vs->b;
+
+      vt[s].x = scale_x;
+      vt[s].y = scale_y;
+      vt[s].z = 0.0f;
+      vt[s].u = scale_u;
+      vt[s].v = scale_v;
+    }
+#ifdef HAS_GL
+    vt[0].x *= vs->x;
+    vt[0].u *= vs->u;
+    vt[0].y *= vs->y;
+    vt[0].v *= vs->v;
+
+    vt[1].x *= vs->x + vs->w;
+    vt[1].u *= vs->u + vs->w;
+    vt[1].y *= vs->y;
+    vt[1].v *= vs->v;
+
+    vt[2].x *= vs->x + vs->w;
+    vt[2].u *= vs->u + vs->w;
+    vt[2].y *= vs->y + vs->h;
+    vt[2].v *= vs->v + vs->h;
+
+    vt[3].x *= vs->x;
+    vt[3].u *= vs->u;
+    vt[3].y *= vs->y + vs->h;
+    vt[3].v *= vs->v + vs->h;
+#else
+    // GLES uses triangle strips, not quads, so have to rearrange the vertex order
+    vt[0].x *= vs->x;
+    vt[0].u *= vs->u;
+    vt[0].y *= vs->y;
+    vt[0].v *= vs->v;
+
+    vt[1].x *= vs->x;
+    vt[1].u *= vs->u;
+    vt[1].y *= vs->y + vs->h;
+    vt[1].v *= vs->v + vs->h;
+
+    vt[2].x *= vs->x + vs->w;
+    vt[2].u *= vs->u + vs->w;
+    vt[2].y *= vs->y;
+    vt[2].v *= vs->v;
+
+    vt[3].x *= vs->x + vs->w;
+    vt[3].u *= vs->u + vs->w;
+    vt[3].y *= vs->y + vs->h;
+    vt[3].v *= vs->v + vs->h;
+#endif
+    vs += 1;
+    vt += 4;
+  }
+
+  glBindTexture(GL_TEXTURE_2D, 0);
+  glDisable(GL_TEXTURE_2D);
+}
+
+COverlayGlyphGL::~COverlayGlyphGL()
+{
+  glDeleteTextures(1, &m_texture);
+  free(m_vertex);
+}
+
+void COverlayGlyphGL::Render(SRenderState& state)
+{
+  if ((m_texture == 0) || (m_count == 0))
+    return;
+
+  glEnable(GL_TEXTURE_2D);
+  glEnable(GL_BLEND);
+
+  glBindTexture(GL_TEXTURE_2D, m_texture);
+  glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);
+
+  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+
+#ifdef HAS_GL
+  glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
+  glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_COMBINE);
+  glTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_RGB, GL_REPLACE);
+  glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_RGB, GL_PRIMARY_COLOR);
+  glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND0_RGB, GL_SRC_COLOR);
+
+  glTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_ALPHA, GL_MODULATE);
+  glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_ALPHA, GL_TEXTURE0);
+  glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE1_ALPHA, GL_PRIMARY_COLOR);
+  glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND0_ALPHA, GL_SRC_ALPHA);
+  glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND1_ALPHA, GL_SRC_ALPHA);
+
+  glMatrixMode(GL_MODELVIEW);
+  glPushMatrix();
+  glTranslatef(state.x    , state.y     , 0.0f);
+  glScalef    (state.width, state.height, 1.0f);
+
+  VerifyGLState();
+
+  glPushClientAttrib(GL_CLIENT_VERTEX_ARRAY_BIT);
+
+  glColorPointer   (4, GL_UNSIGNED_BYTE, sizeof(VERTEX), (char*)m_vertex + offsetof(VERTEX, r));
+  glVertexPointer  (3, GL_FLOAT        , sizeof(VERTEX), (char*)m_vertex + offsetof(VERTEX, x));
+  glTexCoordPointer(2, GL_FLOAT        , sizeof(VERTEX), (char*)m_vertex + offsetof(VERTEX, u));
+  glEnableClientState(GL_COLOR_ARRAY);
+  glEnableClientState(GL_VERTEX_ARRAY);
+  glEnableClientState(GL_TEXTURE_COORD_ARRAY);
+  glDrawArrays(GL_QUADS, 0, m_count * 4);
+  glPopClientAttrib();
+
+  glPopMatrix();
+#else
+  g_matrices.MatrixMode(MM_MODELVIEW);
+  g_matrices.PushMatrix();
+  g_matrices.Translatef(state.x, state.y, 0.0f);
+  g_matrices.Scalef(state.width, state.height, 1.0f);
+  VerifyGLState();
+
+  g_Windowing.EnableGUIShader(SM_FONTS);
+
+  GLint posLoc  = g_Windowing.GUIShaderGetPos();
+  GLint colLoc  = g_Windowing.GUIShaderGetCol();
+  GLint tex0Loc = g_Windowing.GUIShaderGetCoord0();
+
+  // stack object until VBOs will be used
+  std::vector<VERTEX> vecVertices( 6 * m_count);
+  VERTEX *vertices = &vecVertices[0];
+
+  for (int i=0; i<m_count*4; i+=4)
+  {
+    *vertices++ = m_vertex[i];
+    *vertices++ = m_vertex[i+1];
+    *vertices++ = m_vertex[i+2];
+
+    *vertices++ = m_vertex[i+1];
+    *vertices++ = m_vertex[i+3];
+    *vertices++ = m_vertex[i+2];
+  }
+
+  vertices = &vecVertices[0];
+
+  glVertexAttribPointer(posLoc,  3, GL_FLOAT,         GL_FALSE, sizeof(VERTEX), (char*)vertices + offsetof(VERTEX, x));
+  glVertexAttribPointer(colLoc,  4, GL_UNSIGNED_BYTE, GL_TRUE,  sizeof(VERTEX), (char*)vertices + offsetof(VERTEX, r));
+  glVertexAttribPointer(tex0Loc, 2, GL_FLOAT,         GL_FALSE, sizeof(VERTEX), (char*)vertices + offsetof(VERTEX, u));
+
+  glEnableVertexAttribArray(posLoc);
+  glEnableVertexAttribArray(colLoc);
+  glEnableVertexAttribArray(tex0Loc);
+
+  glDrawArrays(GL_TRIANGLES, 0, vecVertices.size());
+
+  glDisableVertexAttribArray(posLoc);
+  glDisableVertexAttribArray(colLoc);
+  glDisableVertexAttribArray(tex0Loc);
+
+  g_Windowing.DisableGUIShader();
+
+  g_matrices.PopMatrix();
+#endif
+
+  glDisable(GL_BLEND);
+  glDisable(GL_TEXTURE_2D);
+
+  glBindTexture(GL_TEXTURE_2D, 0);
+}
+
+
+COverlayTextureGL::~COverlayTextureGL()
+{
+  glDeleteTextures(1, &m_texture);
+}
+
+void COverlayTextureGL::Render(SRenderState& state)
+{
+  glEnable(GL_TEXTURE_2D);
+  glEnable(GL_BLEND);
+
+  glBindTexture(GL_TEXTURE_2D, m_texture);
+  if(m_pma)
+    glBlendFunc(GL_ONE, GL_ONE_MINUS_SRC_ALPHA);
+  else
+    glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);
+
+  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+
+#if defined(HAS_GL)
+  glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
+  glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
+
+  glColor4f(1.0f, 1.0f, 1.0f, 1.0f);
+  VerifyGLState();
+#endif
+
+  DRAWRECT rd;
+  if(m_pos == POSITION_RELATIVE)
+  {
+    rd.top     = state.y - state.height * 0.5;
+    rd.bottom  = state.y + state.height * 0.5;
+    rd.left    = state.x - state.width  * 0.5;
+    rd.right   = state.x + state.width  * 0.5;
+  }
+  else
+  {
+    rd.top     = state.y;
+    rd.bottom  = state.y + state.height;
+    rd.left    = state.x;
+    rd.right   = state.x + state.width;
+  }
+
+#if defined(HAS_GL)
+  glBegin(GL_QUADS);
+  glTexCoord2f(0.0f, 0.0f);
+  glVertex2f(rd.left , rd.top);
+
+  glTexCoord2f(m_u , 0.0f);
+  glVertex2f(rd.right, rd.top);
+
+  glTexCoord2f(m_u , m_v);
+  glVertex2f(rd.right, rd.bottom);
+
+  glTexCoord2f(0.0f, m_v);
+  glVertex2f(rd.left , rd.bottom);
+  glEnd();
+#else
+  g_Windowing.EnableGUIShader(SM_TEXTURE);
+
+  GLfloat col[4][4];
+  GLfloat ver[4][2];
+  GLfloat tex[4][2];
+  GLubyte idx[4] = {0, 1, 3, 2};        //determines order of triangle strip
+
+  GLint posLoc  = g_Windowing.GUIShaderGetPos();
+  GLint colLoc  = g_Windowing.GUIShaderGetCol();
+  GLint tex0Loc = g_Windowing.GUIShaderGetCoord0();
+
+  glVertexAttribPointer(posLoc,  2, GL_FLOAT, 0, 0, ver);
+  glVertexAttribPointer(colLoc,  4, GL_FLOAT, 0, 0, col);
+  glVertexAttribPointer(tex0Loc, 2, GL_FLOAT, 0, 0, tex);
+
+  glEnableVertexAttribArray(posLoc);
+  glEnableVertexAttribArray(colLoc);
+  glEnableVertexAttribArray(tex0Loc);
+
+  for (int i=0; i<4; i++)
+  {
+    // Setup Colours
+    col[i][0] = col[i][1] = col[i][2] = col[i][3] = 1.0f;
+  }
+
+  // Setup vertex position values
+  ver[0][0] = ver[3][0] = rd.left;
+  ver[0][1] = ver[1][1] = rd.top;
+  ver[1][0] = ver[2][0] = rd.right;
+  ver[2][1] = ver[3][1] = rd.bottom;
+
+  // Setup texture coordinates
+  tex[0][0] = tex[0][1] = tex[1][1] = tex[3][0] = 0.0f;
+  tex[1][0] = tex[2][0] = m_u;
+  tex[2][1] = tex[3][1] = m_v;
+
+  glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_BYTE, idx);
+
+  glDisableVertexAttribArray(posLoc);
+  glDisableVertexAttribArray(colLoc);
+  glDisableVertexAttribArray(tex0Loc);
+
+  g_Windowing.DisableGUIShader();
+#endif
+
+  glDisable(GL_BLEND);
+  glDisable(GL_TEXTURE_2D);
+
+  glBindTexture(GL_TEXTURE_2D, 0);
+}
+
+#endif // HAS_GL
diff -Nur xbmc-nightly.org/xbmc/cores/VideoRenderers/OverlayRendererGL.h xbmc-nightly/xbmc/cores/VideoRenderers/OverlayRendererGL.h
--- xbmc-nightly.org/xbmc/cores/VideoRenderers/OverlayRendererGL.h	2014-01-24 22:02:28.207035149 -0800
+++ xbmc-nightly/xbmc/cores/VideoRenderers/OverlayRendererGL.h	2014-02-14 18:27:05.145590452 -0800
@@ -30,7 +30,7 @@
 class CDVDOverlaySSA;
 typedef struct ass_image ASS_Image;
 
-#if defined(HAS_GL) || HAS_GLES == 2
+#if defined(HAS_GL) || HAS_GLES == 2|| HAS_GLES == 1
 
 namespace OVERLAY {
 
diff -Nur xbmc-nightly.org/xbmc/cores/VideoRenderers/RenderManager.cpp xbmc-nightly/xbmc/cores/VideoRenderers/RenderManager.cpp
--- xbmc-nightly.org/xbmc/cores/VideoRenderers/RenderManager.cpp	2014-01-24 22:02:28.209035403 -0800
+++ xbmc-nightly/xbmc/cores/VideoRenderers/RenderManager.cpp	2014-02-14 18:27:05.147590707 -0800
@@ -37,7 +37,7 @@
 
 #if defined(HAS_GL)
   #include "LinuxRendererGL.h"
-#elif HAS_GLES == 2
+#elif HAS_GLES == 2 || HAS_GLES == 1
   #include "LinuxRendererGLES.h"
 #elif defined(HAS_DX)
   #include "WinRenderer.h"
@@ -327,7 +327,7 @@
   {
 #if defined(HAS_GL)
     m_pRenderer = new CLinuxRendererGL();
-#elif HAS_GLES == 2
+#elif HAS_GLES == 2 || HAS_GLES == 1
     m_pRenderer = new CLinuxRendererGLES();
 #elif defined(HAS_DX)
     m_pRenderer = new CWinRenderer();
diff -Nur xbmc-nightly.org/xbmc/cores/VideoRenderers/RenderManager.h xbmc-nightly/xbmc/cores/VideoRenderers/RenderManager.h
--- xbmc-nightly.org/xbmc/cores/VideoRenderers/RenderManager.h	2014-01-24 22:02:28.210035530 -0800
+++ xbmc-nightly/xbmc/cores/VideoRenderers/RenderManager.h	2014-02-14 18:27:05.147590707 -0800
@@ -112,7 +112,7 @@
 
 #ifdef HAS_GL
   CLinuxRendererGL    *m_pRenderer;
-#elif HAS_GLES == 2
+#elif HAS_GLES == 2 || HAS_GLES == 1
   CLinuxRendererGLES  *m_pRenderer;
 #elif defined(HAS_DX)
   CWinRenderer        *m_pRenderer;
diff -Nur xbmc-nightly.org/xbmc/guilib/GUIFontTTFGL.cpp xbmc-nightly/xbmc/guilib/GUIFontTTFGL.cpp
--- xbmc-nightly.org/xbmc/guilib/GUIFontTTFGL.cpp	2014-01-24 22:02:28.405060316 -0800
+++ xbmc-nightly/xbmc/guilib/GUIFontTTFGL.cpp	2014-02-14 18:27:05.148590834 -0800
@@ -28,7 +28,7 @@
 #include "gui3d.h"
 #include "utils/log.h"
 #include "utils/GLUtils.h"
-#if HAS_GLES == 2
+#if HAS_GLES == 2 || HAS_GLES == 1
 #include "windowing/WindowingFactory.h"
 #endif
 
@@ -42,6 +42,9 @@
 
 #if defined(HAS_GL) || defined(HAS_GLES)
 
+#if HAS_GLES == 1 && defined(__sh__)
+  #define TTF_ARGB
+#endif
 
 CGUIFontTTFGL::CGUIFontTTFGL(const CStdString& strFileName)
 : CGUIFontTTFBase(strFileName)
@@ -63,7 +66,7 @@
 
       // Bind the texture object
       glBindTexture(GL_TEXTURE_2D, m_nTexture);
-#ifdef HAS_GL
+#if defined(HAS_GL) || HAS_GLES == 1
       glEnable(GL_TEXTURE_2D);
 #endif
       // Set the texture's stretching properties
@@ -71,17 +74,26 @@
       glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
 
       // Set the texture image -- THIS WORKS, so the pixels must be wrong.
+#ifdef TTF_ARGB
+      glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, m_texture->GetWidth(), m_texture->GetHeight(), 0,
+                   GL_RGBA, GL_UNSIGNED_BYTE, m_texture->GetPixels());
+#else
       glTexImage2D(GL_TEXTURE_2D, 0, GL_ALPHA, m_texture->GetWidth(), m_texture->GetHeight(), 0,
                    GL_ALPHA, GL_UNSIGNED_BYTE, m_texture->GetPixels());
+#endif
 
       VerifyGLState();
       m_bTextureLoaded = true;
     }
 
     // Turn Blending On
+#if defined(__sh__)
+    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+#else
     glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE_MINUS_DST_ALPHA, GL_ONE);
+#endif
     glEnable(GL_BLEND);
-#ifdef HAS_GL
+#if defined(HAS_GL) || HAS_GLES == 1
     glEnable(GL_TEXTURE_2D);
 #endif
     glBindTexture(GL_TEXTURE_2D, m_nTexture);
@@ -97,6 +109,8 @@
     glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE1_ALPHA, GL_PRIMARY_COLOR);
     glTexEnvi(GL_TEXTURE_ENV, GL_OPERAND1_ALPHA, GL_SRC_ALPHA);
     glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
+#endif
+#if defined(HAS_GL) || HAS_GLES == 1
     VerifyGLState();
 #else
     g_Windowing.EnableGUIShader(SM_FONTS);
@@ -116,17 +130,24 @@
   if (--m_nestedBeginCount > 0)
     return;
 
+#if defined(HAS_GL) || HAS_GLES == 1
 #ifdef HAS_GL
   glPushClientAttrib(GL_CLIENT_VERTEX_ARRAY_BIT);
-
+#endif
   glColorPointer   (4, GL_UNSIGNED_BYTE, sizeof(SVertex), (char*)m_vertex + offsetof(SVertex, r));
   glVertexPointer  (3, GL_FLOAT        , sizeof(SVertex), (char*)m_vertex + offsetof(SVertex, x));
   glTexCoordPointer(2, GL_FLOAT        , sizeof(SVertex), (char*)m_vertex + offsetof(SVertex, u));
   glEnableClientState(GL_COLOR_ARRAY);
   glEnableClientState(GL_VERTEX_ARRAY);
   glEnableClientState(GL_TEXTURE_COORD_ARRAY);
+#ifdef GL_QUADS
   glDrawArrays(GL_QUADS, 0, m_vertex_count);
+#else
+   TODO: Convert quads to vertexes for real es1.1, without quads, support
+#endif
+#ifdef HAS_GL
   glPopClientAttrib();
+#endif
 #else
   // GLES 2.0 version. Cannot draw quads. Convert to triangles.
   GLint posLoc  = g_Windowing.GUIShaderGetPos();
@@ -173,7 +194,11 @@
 {
   newHeight = CBaseTexture::PadPow2(newHeight);
 
+#ifdef TTF_ARGB
+  CBaseTexture* newTexture = new CTexture(m_textureWidth, newHeight, XB_FMT_A8R8G8B8);
+#else
   CBaseTexture* newTexture = new CTexture(m_textureWidth, newHeight, XB_FMT_A8);
+#endif
 
   if (!newTexture || newTexture->GetPixels() == NULL)
   {
@@ -206,11 +231,21 @@
   FT_Bitmap bitmap = bitGlyph->bitmap;
 
   unsigned char* source = (unsigned char*) bitmap.buffer;
+#ifdef TTF_ARGB
+  unsigned char* target = (unsigned char*) m_texture->GetPixels() + y1 * m_texture->GetPitch() + x1*4/*ARGB*/;
+#else
   unsigned char* target = (unsigned char*) m_texture->GetPixels() + y1 * m_texture->GetPitch() + x1;
+#endif
 
   for (unsigned int y = y1; y < y2; y++)
   {
+#ifdef TTF_ARGB
+    for (unsigned int i = 0, j = 0; i < x2-x1; i++, j+=4) {
+      memset(target + j, source[i], 4);
+    }
+#else
     memcpy(target, source, x2-x1);
+#endif
     source += bitmap.width;
     target += m_texture->GetPitch();
   }
diff -Nur xbmc-nightly.org/xbmc/guilib/GUITextureGLES.cpp xbmc-nightly/xbmc/guilib/GUITextureGLES.cpp
--- xbmc-nightly.org/xbmc/guilib/GUITextureGLES.cpp	2014-01-24 22:02:28.425062858 -0800
+++ xbmc-nightly/xbmc/guilib/GUITextureGLES.cpp	2014-02-14 18:27:05.148590834 -0800
@@ -57,6 +57,7 @@
 
   bool hasAlpha = m_texture.m_textures[m_currentFrame]->HasAlpha() || m_col[0][3] < 255;
 
+#if HAS_GLES == 2
   if (m_diffuse.size())
   {
     if (m_col[0][0] == 255 && m_col[0][1] == 255 && m_col[0][2] == 255 && m_col[0][3] == 255 )
@@ -87,7 +88,17 @@
       g_Windowing.EnableGUIShader(SM_TEXTURE);
     }
   }
+#endif
 
+#if HAS_GLES == 1
+  glVertexPointer(3, GL_FLOAT, 0, m_vert);
+  glColorPointer(4, GL_UNSIGNED_BYTE, 0, m_col);
+  glTexCoordPointer(2, GL_FLOAT , 0, m_tex0);
+  
+  glEnableClientState(GL_VERTEX_ARRAY);
+  glEnableClientState(GL_COLOR_ARRAY);
+  glEnableClientState(GL_TEXTURE_COORD_ARRAY);
+#else //HAS_GLES == 2
   GLint posLoc  = g_Windowing.GUIShaderGetPos();
   GLint colLoc  = g_Windowing.GUIShaderGetCol();
   GLint tex0Loc = g_Windowing.GUIShaderGetCoord0();
@@ -101,10 +112,15 @@
   if(colLoc >= 0)
     glEnableVertexAttribArray(colLoc);
   glEnableVertexAttribArray(tex0Loc);
+#endif
 
   if ( hasAlpha )
   {
+#if defined(__sh__)
+    glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);
+#else
     glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE_MINUS_DST_ALPHA, GL_ONE);
+#endif
     glEnable( GL_BLEND );
   }
   else
@@ -115,6 +131,11 @@
 
 void CGUITextureGLES::End()
 {
+#if HAS_GLES == 1
+  glDisableClientState(GL_VERTEX_ARRAY);
+  glDisableClientState(GL_COLOR_ARRAY);
+  glDisableClientState(GL_TEXTURE_COORD_ARRAY);
+#else //HAS_GLES == 2
   if (m_diffuse.size())
   {
     glDisableVertexAttribArray(g_Windowing.GUIShaderGetCoord1());
@@ -126,13 +147,72 @@
   if(colLoc >= 0)
     glDisableVertexAttribArray(g_Windowing.GUIShaderGetCol());
   glDisableVertexAttribArray(g_Windowing.GUIShaderGetCoord0());
-
+#endif
   glEnable(GL_BLEND);
+#if HAS_GLES == 2
   g_Windowing.DisableGUIShader();
+#endif
 }
 
 void CGUITextureGLES::Draw(float *x, float *y, float *z, const CRect &texture, const CRect &diffuse, int orientation)
 {
+#if HAS_GLES == 1
+
+  // Setup vertex position values
+  m_vert[0][0] = x[3];
+  m_vert[0][1] = y[0];
+  m_vert[0][2] = z[0];
+  
+  m_vert[1][0] = x[0];
+  m_vert[1][1] = y[2];
+  m_vert[1][2] = z[1];
+  
+  m_vert[2][0] = x[1];
+  m_vert[2][1] = y[1];
+  m_vert[2][2] = z[2];
+  
+  m_vert[3][0] = x[2];
+  m_vert[3][1] = y[3];
+  m_vert[3][2] = z[3];
+
+  // Setup texture coordinates
+  //TopLeft
+  m_tex0[0][0] = texture.x1;
+  m_tex0[0][1] = texture.y1;
+  //BottomLeft
+  if (orientation & 4)
+  {
+    m_tex0[1][0] = texture.x2;
+    m_tex0[1][1] = texture.y1;
+  }
+  else
+  {
+    m_tex0[1][0] = texture.x1;
+    m_tex0[1][1] = texture.y2;
+  }
+  //TopRight
+  if (orientation & 4)
+  {
+    m_tex0[2][0] = texture.x1;
+    m_tex0[2][1] = texture.y2;
+  }
+  else
+  {
+    m_tex0[2][0] = texture.x2;
+    m_tex0[2][1] = texture.y1;
+  }
+  //BottomRight
+  m_tex0[3][0] = texture.x2;
+  m_tex0[3][1] = texture.y2;
+
+#ifdef GL_QUADS
+  glEnable(GL_TEXTURE_2D);
+  glDrawArrays(GL_QUADS, 0, 4);
+#else
+   TODO: Convert quads to vertexes for real es1.1, without quads, support
+#endif
+
+#else //HAS_GLES == 2
   GLubyte idx[4] = {0, 1, 3, 2};        //determines order of triangle strip
 
   // Setup vertex position values
@@ -206,10 +286,12 @@
   }
 
   glDrawElements(GL_TRIANGLE_STRIP, 4, GL_UNSIGNED_BYTE, idx);
+#endif
 }
 
 void CGUITextureGLES::DrawQuad(const CRect &rect, color_t color, CBaseTexture *texture, const CRect *texCoords)
 {
+#if HAS_GLES == 2 //TODO GLES == 1
   if (texture)
   {
     texture->LoadToGPU();
@@ -288,6 +370,7 @@
     glDisableVertexAttribArray(tex0Loc);
 
   g_Windowing.DisableGUIShader();
+#endif
 }
 
 #endif
diff -Nur xbmc-nightly.org/xbmc/guilib/Makefile.in xbmc-nightly/xbmc/guilib/Makefile.in
--- xbmc-nightly.org/xbmc/guilib/Makefile.in	2014-01-24 22:02:28.435064130 -0800
+++ xbmc-nightly/xbmc/guilib/Makefile.in	2014-02-14 18:27:05.149590961 -0800
@@ -3,7 +3,6 @@
 SRCS += DirectXGraphics.cpp
 SRCS += DirtyRegionSolvers.cpp
 SRCS += DirtyRegionTracker.cpp
-SRCS += FrameBufferObject.cpp
 SRCS += GraphicContext.cpp
 SRCS += GUIAction.cpp
 SRCS += GUIAudioManager.cpp
@@ -76,12 +75,16 @@
 SRCS += XBTFReader.cpp
 
 ifeq (@USE_OPENGL@,1)
+
+SRCS += FrameBufferObject.cpp
 SRCS += TextureGL.cpp
 SRCS += GUIFontTTFGL.cpp
 SRCS += GUITextureGL.cpp
 endif
 
 ifeq (@USE_OPENGLES@,1)
+
+SRCS += FrameBufferObject.cpp
 SRCS += TextureGL.cpp
 SRCS += GUIFontTTFGL.cpp
 SRCS += GUITextureGLES.cpp
@@ -89,6 +92,14 @@
 SRCS += GUIShader.cpp
 endif
 
+ifeq (@USE_OPENGLESV1@,1)
+
+SRCS += TextureGL.cpp
+SRCS += GUIFontTTFGL.cpp
+SRCS += GUITextureGLES.cpp
+SRCS += MatrixGLES.cpp
+endif
+
 LIB = guilib.a
 
 include @abs_top_srcdir@/Makefile.include
diff -Nur xbmc-nightly.org/xbmc/guilib/MatrixGLES.cpp xbmc-nightly/xbmc/guilib/MatrixGLES.cpp
--- xbmc-nightly.org/xbmc/guilib/MatrixGLES.cpp	2014-01-24 22:02:28.435064130 -0800
+++ xbmc-nightly/xbmc/guilib/MatrixGLES.cpp	2014-02-14 18:27:05.149590961 -0800
@@ -21,7 +21,7 @@
 
 #include "system.h"
 
-#if HAS_GLES == 2
+#if HAS_GLES == 2 || HAS_GLES == 1
 #include "system_gl.h"
 
 #include <cmath>
diff -Nur xbmc-nightly.org/xbmc/guilib/TextureGL.cpp xbmc-nightly/xbmc/guilib/TextureGL.cpp
--- xbmc-nightly.org/xbmc/guilib/TextureGL.cpp	2014-01-24 22:02:28.440064765 -0800
+++ xbmc-nightly/xbmc/guilib/TextureGL.cpp	2014-02-14 18:27:05.150591088 -0800
@@ -193,6 +193,9 @@
 #else // GLES
   glActiveTexture((unit == 1) ? GL_TEXTURE1 : GL_TEXTURE0);
   glBindTexture(GL_TEXTURE_2D, m_texture);
+#if HAS_GLES == 1
+  glEnable(GL_TEXTURE_2D);
+#endif
 #endif
 }
 
diff -Nur xbmc-nightly.org/xbmc/input/linux/LinuxInputDevices.cpp xbmc-nightly/xbmc/input/linux/LinuxInputDevices.cpp
--- xbmc-nightly.org/xbmc/input/linux/LinuxInputDevices.cpp	2014-01-24 22:02:28.450066038 -0800
+++ xbmc-nightly/xbmc/input/linux/LinuxInputDevices.cpp	2014-02-14 18:27:05.150591088 -0800
@@ -184,7 +184,7 @@
     XBMCK_HELP,
 
     /* DIKS_MENU, DIKS_CALCULATOR, DIKS_SETUP, */
-    XBMCK_UNKNOWN, XBMCK_UNKNOWN, XBMCK_UNKNOWN,
+    XBMCK_c, XBMCK_UNKNOWN, XBMCK_UNKNOWN,
 
     /*KEY_SLEEP, KEY_WAKEUP, KEY_FILE, KEY_SENDFILE, KEY_DELETEFILE,
      KEY_XFER,*/
@@ -279,25 +279,30 @@
     /* KEY_CANCEL         */XBMCK_UNKNOWN,
     /* KEY_BRIGHTNESSDOWN */XBMCK_UNKNOWN,
     /* KEY_BRIGHTNESSUP   */XBMCK_UNKNOWN,
-    /* KEY_MEDIA          */XBMCK_UNKNOWN, };
-
-/*
-  In the future we may want it...
+    /* KEY_MEDIA          */XBMCK_LAUNCH_MEDIA_CENTER, };
 
 static const
-int ext_keycodes[] = { DIKS_OK, DIKS_SELECT, DIKS_GOTO, DIKS_CLEAR,
-    DIKS_POWER2, DIKS_OPTION, DIKS_INFO, DIKS_TIME, DIKS_VENDOR, DIKS_ARCHIVE,
-    DIKS_PROGRAM, DIKS_CHANNEL, DIKS_FAVORITES, DIKS_EPG, DIKS_PVR, DIKS_MHP,
-    DIKS_LANGUAGE, DIKS_TITLE, DIKS_SUBTITLE, DIKS_ANGLE, DIKS_ZOOM, DIKS_MODE,
-    DIKS_KEYBOARD, DIKS_SCREEN, DIKS_PC, DIKS_TV, DIKS_TV2, DIKS_VCR,
-    DIKS_VCR2, DIKS_SAT, DIKS_SAT2, DIKS_CD, DIKS_TAPE, DIKS_RADIO, DIKS_TUNER,
-    DIKS_PLAYER, DIKS_TEXT, DIKS_DVD, DIKS_AUX, DIKS_MP3, DIKS_AUDIO,
-    DIKS_VIDEO, DIKS_DIRECTORY, DIKS_LIST, DIKS_MEMO, DIKS_CALENDAR, DIKS_RED,
-    DIKS_GREEN, DIKS_YELLOW, DIKS_BLUE, DIKS_CHANNEL_UP, DIKS_CHANNEL_DOWN,
-    DIKS_FIRST, DIKS_LAST, DIKS_AB, DIKS_NEXT, DIKS_RESTART, DIKS_SLOW,
-    DIKS_SHUFFLE, DIKS_FASTFORWARD, DIKS_PREVIOUS, DIKS_NEXT, DIKS_DIGITS,
-    DIKS_TEEN, DIKS_TWEN, DIKS_BREAK };
-*/
+XBMCKey ext_keycodes[] = { XBMCK_RETURN, 
+    XBMCK_UNKNOWN, XBMCK_UNKNOWN, XBMCK_UNKNOWN, XBMCK_UNKNOWN, XBMCK_UNKNOWN, 
+    XBMCK_HELP, 
+    XBMCK_UNKNOWN, XBMCK_UNKNOWN, 
+    XBMCK_LAUNCH_FILE_BROWSER,
+    XBMCK_UNKNOWN, XBMCK_UNKNOWN, XBMCK_UNKNOWN, 
+    XBMCK_LAUNCH_MAIL, 
+    XBMCK_UNKNOWN, XBMCK_UNKNOWN, 
+    XBMCK_UNKNOWN, XBMCK_UNKNOWN, XBMCK_UNKNOWN, XBMCK_UNKNOWN, XBMCK_UNKNOWN, XBMCK_UNKNOWN, 
+    XBMCK_UNKNOWN, XBMCK_UNKNOWN, XBMCK_UNKNOWN, XBMCK_UNKNOWN, XBMCK_UNKNOWN, XBMCK_UNKNOWN, 
+    XBMCK_UNKNOWN, XBMCK_UNKNOWN, XBMCK_UNKNOWN, XBMCK_UNKNOWN, XBMCK_UNKNOWN, XBMCK_UNKNOWN, XBMCK_UNKNOWN, 
+    XBMCK_UNKNOWN, 
+    XBMCK_LAUNCH_APP1, 
+    XBMCK_UNKNOWN, XBMCK_UNKNOWN, XBMCK_UNKNOWN, XBMCK_UNKNOWN, 
+    XBMCK_UNKNOWN, XBMCK_UNKNOWN, XBMCK_UNKNOWN, XBMCK_UNKNOWN, XBMCK_UNKNOWN, 
+    XBMCK_F5,
+    XBMCK_F6, XBMCK_F7, XBMCK_F8, 
+    XBMCK_UNKNOWN, XBMCK_UNKNOWN, 
+    XBMCK_UNKNOWN, XBMCK_UNKNOWN, XBMCK_UNKNOWN, XBMCK_UNKNOWN, XBMCK_UNKNOWN, XBMCK_UNKNOWN, 
+    XBMCK_UNKNOWN, XBMCK_UNKNOWN, XBMCK_UNKNOWN, XBMCK_UNKNOWN, XBMCK_UNKNOWN, 
+    XBMCK_UNKNOWN, XBMCK_UNKNOWN, XBMCK_UNKNOWN,  };
 
 typedef enum
 {
@@ -352,18 +357,11 @@
  */
 XBMCKey CLinuxInputDevice::TranslateKey(unsigned short code)
 {
-  if (code < D_ARRAY_SIZE(basic_keycodes))
-    return basic_keycodes[code];
-
-/*
-  In the future we may want it...
-
   if (code >= KEY_OK)
     if (code - KEY_OK < D_ARRAY_SIZE(ext_keycodes))
       return ext_keycodes[code - KEY_OK];
-*/
 
-  return XBMCK_UNKNOWN;
+  return basic_keycodes[code];
 }
 
 int CLinuxInputDevice::KeyboardGetSymbol(unsigned short value)
diff -Nur xbmc-nightly.org/xbmc/input/linux/LIRC.cpp xbmc-nightly/xbmc/input/linux/LIRC.cpp
--- xbmc-nightly.org/xbmc/input/linux/LIRC.cpp	2014-01-24 22:02:28.450066038 -0800
+++ xbmc-nightly/xbmc/input/linux/LIRC.cpp	2014-02-14 17:58:07.000000000 -0800
@@ -139,9 +139,11 @@
   CLog::Log(LOGINFO, "LIRC %s: using: %s", __FUNCTION__, addr.sun_path);
 
   // Open the socket from which we will receive the remote commands
-  if ((m_fd = socket(AF_UNIX, SOCK_STREAM, 0)) != -1)
+  m_fd = socket(AF_UNIX, SOCK_STREAM, 0);
+  if (m_fd != -1)    
   {
     // Connect to the socket
+    CLog::Log(LOGINFO, "LIRC %s: socket connected", __FUNCTION__);
     if (connect(m_fd, (struct sockaddr *)&addr, sizeof(addr)) != -1)
     {
       int opts;
diff -Nur xbmc-nightly.org/xbmc/interfaces/legacy/ModuleXbmc.cpp xbmc-nightly/xbmc/interfaces/legacy/ModuleXbmc.cpp
--- xbmc-nightly.org/xbmc/interfaces/legacy/ModuleXbmc.cpp	2014-01-24 22:02:28.481069978 -0800
+++ xbmc-nightly/xbmc/interfaces/legacy/ModuleXbmc.cpp	2014-02-14 18:27:05.151591215 -0800
@@ -457,9 +457,13 @@
     int getPLAYLIST_MUSIC() { return PLAYLIST_MUSIC; }
     int getPLAYLIST_VIDEO() { return PLAYLIST_VIDEO; }
     int getPLAYER_CORE_AUTO() { return EPC_NONE; }
+#ifdef HAS_DVDPLAYER
     int getPLAYER_CORE_DVDPLAYER() { return EPC_DVDPLAYER; }
     int getPLAYER_CORE_MPLAYER() { return EPC_MPLAYER; }
+#endif
+#ifdef HAS_PAPLAYER
     int getPLAYER_CORE_PAPLAYER() { return EPC_PAPLAYER; }
+#endif
     int getTRAY_OPEN() { return TRAY_OPEN; }
     int getDRIVE_NOT_READY() { return DRIVE_NOT_READY; }
     int getTRAY_CLOSED_NO_MEDIA() { return TRAY_CLOSED_NO_MEDIA; }
diff -Nur xbmc-nightly.org/xbmc/interfaces/legacy/ModuleXbmc.h xbmc-nightly/xbmc/interfaces/legacy/ModuleXbmc.h
--- xbmc-nightly.org/xbmc/interfaces/legacy/ModuleXbmc.h	2014-01-24 22:02:28.481069978 -0800
+++ xbmc-nightly/xbmc/interfaces/legacy/ModuleXbmc.h	2014-02-14 18:27:05.152591342 -0800
@@ -406,9 +406,13 @@
     SWIG_CONSTANT_FROM_GETTER(int,PLAYLIST_MUSIC);
     SWIG_CONSTANT_FROM_GETTER(int,PLAYLIST_VIDEO);
     SWIG_CONSTANT_FROM_GETTER(int,PLAYER_CORE_AUTO);
+#ifdef HAS_DVDPLAYER
     SWIG_CONSTANT_FROM_GETTER(int,PLAYER_CORE_DVDPLAYER);
     SWIG_CONSTANT_FROM_GETTER(int,PLAYER_CORE_MPLAYER);
+#endif
+#ifdef HAS_PAPLAYER
     SWIG_CONSTANT_FROM_GETTER(int,PLAYER_CORE_PAPLAYER);
+#endif
     SWIG_CONSTANT_FROM_GETTER(int,TRAY_OPEN);
     SWIG_CONSTANT_FROM_GETTER(int,DRIVE_NOT_READY);
     SWIG_CONSTANT_FROM_GETTER(int,TRAY_CLOSED_NO_MEDIA);
diff -Nur xbmc-nightly.org/xbmc/interfaces/legacy/Player.cpp xbmc-nightly/xbmc/interfaces/legacy/Player.cpp
--- xbmc-nightly.org/xbmc/interfaces/legacy/Player.cpp	2014-01-24 22:02:28.484070359 -0800
+++ xbmc-nightly/xbmc/interfaces/legacy/Player.cpp	2014-02-14 18:27:05.152591342 -0800
@@ -39,9 +39,15 @@
     {
       iPlayList = PLAYLIST_MUSIC;
 
-      if (_playerCore == EPC_DVDPLAYER ||
+      if (
+#ifdef HAS_DVDPLAYER
+          _playerCore == EPC_DVDPLAYER ||
           _playerCore == EPC_MPLAYER ||
-          _playerCore == EPC_PAPLAYER)
+#endif
+#ifdef HAS_PAPLAYER
+          _playerCore == EPC_PAPLAYER || 
+#endif
+      0)
         playerCore = (EPLAYERCORES)_playerCore;
       else
         playerCore = EPC_NONE;
diff -Nur xbmc-nightly.org/xbmc/linux/PlatformDefs.h xbmc-nightly/xbmc/linux/PlatformDefs.h
--- xbmc-nightly.org/xbmc/linux/PlatformDefs.h	2014-01-24 22:02:29.031139888 -0800
+++ xbmc-nightly/xbmc/linux/PlatformDefs.h	2014-02-14 18:27:05.152591342 -0800
@@ -162,7 +162,7 @@
 #define __int64   long long
 #define __uint64  unsigned long long
 
-#if defined(__x86_64__) || defined(__powerpc__) || defined(__ppc__) || defined (__arm__) // should this be powerpc64 only?
+#if defined(__x86_64__) || defined(__powerpc__) || defined(__ppc__) || defined (__arm__) || defined (__sh__) // should this be powerpc64 only?
 #define __stdcall
 #else /* !__x86_64__ */
 #define __stdcall   __attribute__((__stdcall__))
diff -Nur xbmc-nightly.org/xbmc/pictures/SlideShowPicture.cpp xbmc-nightly/xbmc/pictures/SlideShowPicture.cpp
--- xbmc-nightly.org/xbmc/pictures/SlideShowPicture.cpp	2014-01-24 22:02:29.118150948 -0800
+++ xbmc-nightly/xbmc/pictures/SlideShowPicture.cpp	2014-02-14 18:27:05.155591724 -0800
@@ -825,7 +825,7 @@
 
   glEnd();
   g_graphicsContext.EndPaint();
-#elif defined(HAS_GLES)
+#elif defined(HAS_GLES) && HAS_GLES == 2
   g_graphicsContext.BeginPaint();
   if (pTexture)
   {
@@ -896,6 +896,7 @@
   g_Windowing.DisableGUIShader();
 
   g_graphicsContext.EndPaint();
+#elif defined(HAS_GLES) && HAS_GLES == 1
 #else
 // SDL render
   g_Windowing.BlitToScreen(m_pImage, NULL, NULL);
diff -Nur xbmc-nightly.org/xbmc/rendering/gles/RenderSystemGLES.cpp xbmc-nightly/xbmc/rendering/gles/RenderSystemGLES.cpp
--- xbmc-nightly.org/xbmc/rendering/gles/RenderSystemGLES.cpp	2014-01-24 22:02:29.152155269 -0800
+++ xbmc-nightly/xbmc/rendering/gles/RenderSystemGLES.cpp	2014-02-14 18:27:05.155591724 -0800
@@ -21,7 +21,7 @@
 
 #include "system.h"
 
-#if HAS_GLES == 2
+#if HAS_GLES == 2 || HAS_GLES == 1
 
 #include "guilib/GraphicContext.h"
 #include "settings/AdvancedSettings.h"
@@ -33,6 +33,7 @@
 #include "utils/SystemInfo.h"
 #include "utils/MathUtils.h"
 
+#if HAS_GLES == 2
 static const char* ShaderNames[SM_ESHADERCOUNT] =
     {"guishader_frag_default.glsl",
      "guishader_frag_texture.glsl",
@@ -43,11 +44,14 @@
      "guishader_frag_rgba.glsl",
      "guishader_frag_rgba_blendcolor.glsl"
     };
+#endif
 
 CRenderSystemGLES::CRenderSystemGLES()
  : CRenderSystemBase()
+#if HAS_GLES == 2
  , m_pGUIshader(0)
  , m_method(SM_DEFAULT)
+#endif
 {
   m_enumRenderingSystem = RENDERING_SYSTEM_OPENGLES;
 }
@@ -116,9 +120,9 @@
 
 
   m_bRenderCreated = true;
-  
+#if HAS_GLES == 2
   InitialiseGUIShader();
-
+#endif
   return true;
 }
 
@@ -152,6 +156,7 @@
 
 bool CRenderSystemGLES::DestroyRenderSystem()
 {
+#if HAS_GLES == 2
   CLog::Log(LOGDEBUG, "GUI Shader - Destroying Shader : %p", m_pGUIshader);
 
   if (m_pGUIshader)
@@ -168,7 +173,7 @@
     delete[] m_pGUIshader;
     m_pGUIshader = NULL;
   }
-
+#endif
   m_bRenderCreated = false;
 
   return true;
@@ -199,6 +204,10 @@
   float g = GET_G(color) / 255.0f;
   float b = GET_B(color) / 255.0f;
   float a = GET_A(color) / 255.0f;
+#if HAS_GLES == 1
+  //TODO: Ugly Hack, somehow the alpha value goes missing, check this
+  a = 0.0f;
+#endif
 
   glClearColor(r, g, b, a);
 
@@ -424,6 +433,7 @@
 {
   static float theta = 0.0;
 
+#if HAS_GLES == 2
   //RESOLUTION_INFO resInfo = g_settings.m_ResInfo[g_guiSettings.m_LookAndFeelResolution];
   //glViewport(0, 0, resInfo.iWidth, resInfo.iHeight);
 
@@ -466,6 +476,7 @@
 
   theta += 1.0f;
 
+#endif
   return true;
 }
 
@@ -544,7 +555,7 @@
 {
   SetScissors(CRect(0, 0, (float)m_width, (float)m_height));
 }
-
+#if HAS_GLES == 2
 void CRenderSystemGLES::InitialiseGUIShader()
 {
   if (!m_pGUIshader)
@@ -626,5 +637,5 @@
 
   return -1;
 }
-
+#endif
 #endif
diff -Nur xbmc-nightly.org/xbmc/rendering/gles/RenderSystemGLES.cpp.orig xbmc-nightly/xbmc/rendering/gles/RenderSystemGLES.cpp.orig
--- xbmc-nightly.org/xbmc/rendering/gles/RenderSystemGLES.cpp.orig	1969-12-31 16:00:00.000000000 -0800
+++ xbmc-nightly/xbmc/rendering/gles/RenderSystemGLES.cpp.orig	2014-01-24 22:02:29.152155269 -0800
@@ -0,0 +1,630 @@
+/*
+*      Copyright (C) 2005-2012 Team XBMC
+*      http://www.xbmc.org
+*
+*  This Program is free software; you can redistribute it and/or modify
+*  it under the terms of the GNU General Public License as published by
+*  the Free Software Foundation; either version 2, or (at your option)
+*  any later version.
+*
+*  This Program is distributed in the hope that it will be useful,
+*  but WITHOUT ANY WARRANTY; without even the implied warranty of
+*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+*  GNU General Public License for more details.
+*
+*  You should have received a copy of the GNU General Public License
+*  along with XBMC; see the file COPYING.  If not, see
+*  <http://www.gnu.org/licenses/>.
+*
+*/
+
+
+#include "system.h"
+
+#if HAS_GLES == 2
+
+#include "guilib/GraphicContext.h"
+#include "settings/AdvancedSettings.h"
+#include "RenderSystemGLES.h"
+#include "guilib/MatrixGLES.h"
+#include "utils/log.h"
+#include "utils/GLUtils.h"
+#include "utils/TimeUtils.h"
+#include "utils/SystemInfo.h"
+#include "utils/MathUtils.h"
+
+static const char* ShaderNames[SM_ESHADERCOUNT] =
+    {"guishader_frag_default.glsl",
+     "guishader_frag_texture.glsl",
+     "guishader_frag_multi.glsl",
+     "guishader_frag_fonts.glsl",
+     "guishader_frag_texture_noblend.glsl",
+     "guishader_frag_multi_blendcolor.glsl",
+     "guishader_frag_rgba.glsl",
+     "guishader_frag_rgba_blendcolor.glsl"
+    };
+
+CRenderSystemGLES::CRenderSystemGLES()
+ : CRenderSystemBase()
+ , m_pGUIshader(0)
+ , m_method(SM_DEFAULT)
+{
+  m_enumRenderingSystem = RENDERING_SYSTEM_OPENGLES;
+}
+
+CRenderSystemGLES::~CRenderSystemGLES()
+{
+}
+
+bool CRenderSystemGLES::InitRenderSystem()
+{
+  GLint maxTextureSize;
+
+  glGetIntegerv(GL_MAX_TEXTURE_SIZE, &maxTextureSize);
+
+  m_maxTextureSize = maxTextureSize;
+  m_bVSync = false;
+  m_iVSyncMode = 0;
+  m_iSwapStamp = 0;
+  m_iSwapTime = 0;
+  m_iSwapRate = 0;
+  m_bVsyncInit = false;
+  m_renderCaps = 0;
+  // Get the GLES version number
+  m_RenderVersionMajor = 0;
+  m_RenderVersionMinor = 0;
+
+  const char* ver = (const char*)glGetString(GL_VERSION);
+  if (ver != 0)
+  {
+    sscanf(ver, "%d.%d", &m_RenderVersionMajor, &m_RenderVersionMinor);
+    if (!m_RenderVersionMajor)
+      sscanf(ver, "%*s %*s %d.%d", &m_RenderVersionMajor, &m_RenderVersionMinor);
+    m_RenderVersion = ver;
+  }
+  
+  // Get our driver vendor and renderer
+  m_RenderVendor = (const char*) glGetString(GL_VENDOR);
+  m_RenderRenderer = (const char*) glGetString(GL_RENDERER);
+
+  m_RenderExtensions  = " ";
+  m_RenderExtensions += (const char*) glGetString(GL_EXTENSIONS);
+  m_RenderExtensions += " ";
+
+  LogGraphicsInfo();
+  
+  if (IsExtSupported("GL_TEXTURE_NPOT"))
+  {
+    m_renderCaps |= RENDER_CAPS_NPOT;
+  }
+
+  if (IsExtSupported("GL_EXT_texture_format_BGRA8888"))
+  {
+    m_renderCaps |= RENDER_CAPS_BGRA;
+  }
+
+  if (IsExtSupported("GL_IMG_texture_format_BGRA8888"))
+  {
+    m_renderCaps |= RENDER_CAPS_BGRA;
+  }
+
+  if (IsExtSupported("GL_APPLE_texture_format_BGRA8888"))
+  {
+    m_renderCaps |= RENDER_CAPS_BGRA_APPLE;
+  }
+
+
+
+  m_bRenderCreated = true;
+  
+  InitialiseGUIShader();
+
+  return true;
+}
+
+bool CRenderSystemGLES::ResetRenderSystem(int width, int height, bool fullScreen, float refreshRate)
+{
+  m_width = width;
+  m_height = height;
+  
+  glClearColor( 0.0f, 0.0f, 0.0f, 0.0f );
+  CalculateMaxTexturesize();
+
+  CRect rect( 0, 0, width, height );
+  SetViewPort( rect );
+
+  glEnable(GL_SCISSOR_TEST); 
+
+  g_matrices.MatrixMode(MM_PROJECTION);
+  g_matrices.LoadIdentity();
+
+  g_matrices.Ortho(0.0f, width-1, height-1, 0.0f, -1.0f, 1.0f);
+
+  g_matrices.MatrixMode(MM_MODELVIEW);
+  g_matrices.LoadIdentity();
+  
+  glBlendFunc(GL_SRC_ALPHA, GL_ONE);
+  glEnable(GL_BLEND);          // Turn Blending On
+  glDisable(GL_DEPTH_TEST);  
+    
+  return true;
+}
+
+bool CRenderSystemGLES::DestroyRenderSystem()
+{
+  CLog::Log(LOGDEBUG, "GUI Shader - Destroying Shader : %p", m_pGUIshader);
+
+  if (m_pGUIshader)
+  {
+    for (int i = 0; i < SM_ESHADERCOUNT; i++)
+    {
+      if (m_pGUIshader[i])
+      {
+        m_pGUIshader[i]->Free();
+        delete m_pGUIshader[i];
+        m_pGUIshader[i] = NULL;
+      }
+    }
+    delete[] m_pGUIshader;
+    m_pGUIshader = NULL;
+  }
+
+  m_bRenderCreated = false;
+
+  return true;
+}
+
+bool CRenderSystemGLES::BeginRender()
+{
+  if (!m_bRenderCreated)
+    return false;
+
+  return true;
+}
+
+bool CRenderSystemGLES::EndRender()
+{
+  if (!m_bRenderCreated)
+    return false;
+
+  return true;
+}
+
+bool CRenderSystemGLES::ClearBuffers(color_t color)
+{
+  if (!m_bRenderCreated)
+    return false;
+
+  float r = GET_R(color) / 255.0f;
+  float g = GET_G(color) / 255.0f;
+  float b = GET_B(color) / 255.0f;
+  float a = GET_A(color) / 255.0f;
+
+  glClearColor(r, g, b, a);
+
+  GLbitfield flags = GL_COLOR_BUFFER_BIT;
+  glClear(flags);
+
+  return true;
+}
+
+bool CRenderSystemGLES::IsExtSupported(const char* extension)
+{
+  if (strcmp( extension, "GL_EXT_framebuffer_object" ) == 0)
+  {
+    // GLES has FBO as a core element, not an extension!
+    return true;
+  }
+  else if (strcmp( extension, "GL_TEXTURE_NPOT" ) == 0)
+  {
+    // GLES supports non-power-of-two textures as standard.
+	return true;
+	/* Note: The wrap mode can only be GL_CLAMP_TO_EDGE and the minification filter can only be
+	 * GL_NEAREST or GL_LINEAR (in other words, not mipmapped). The extension GL_OES_texture_npot
+	 * relaxes these restrictions and allows wrap modes of GL_REPEAT and GL_MIRRORED_REPEAT and
+	 * also	allows npot textures to be mipmapped with the full set of minification filters
+	 */
+  }
+  else
+  {
+    CStdString name;
+    name  = " ";
+    name += extension;
+    name += " ";
+
+    bool supported = m_RenderExtensions.find(name) != std::string::npos;
+    CLog::Log(LOGDEBUG, "GLES: Extension Support Test - %s %s", extension, supported ? "YES" : "NO");
+    return supported;
+  }
+}
+
+static int64_t abs64(int64_t a)
+{
+  if(a < 0)
+    return -a;
+  return a;
+}
+
+bool CRenderSystemGLES::PresentRender(const CDirtyRegionList &dirty)
+{
+  if (!m_bRenderCreated)
+    return false;
+
+  if (m_iVSyncMode != 0 && m_iSwapRate != 0) 
+  {
+    int64_t curr, diff, freq;
+    curr = CurrentHostCounter();
+    freq = CurrentHostFrequency();
+
+    if(m_iSwapStamp == 0)
+      m_iSwapStamp = curr;
+
+    /* calculate our next swap timestamp */
+    diff = curr - m_iSwapStamp;
+    diff = m_iSwapRate - diff % m_iSwapRate;
+    m_iSwapStamp = curr + diff;
+
+    /* sleep as close as we can before, assume 1ms precision of sleep *
+     * this should always awake so that we are guaranteed the given   *
+     * m_iSwapTime to do our swap                                     */
+    diff = (diff - m_iSwapTime) * 1000 / freq;
+    if (diff > 0)
+      Sleep((DWORD)diff);
+  }
+  
+  bool result = PresentRenderImpl(dirty);
+  
+  if (m_iVSyncMode && m_iSwapRate != 0)
+  {
+    int64_t curr, diff;
+    curr = CurrentHostCounter();
+
+    diff = curr - m_iSwapStamp;
+    m_iSwapStamp = curr;
+
+    if (abs64(diff - m_iSwapRate) < abs64(diff))
+      CLog::Log(LOGDEBUG, "%s - missed requested swap",__FUNCTION__);
+  }
+  
+  return result;
+}
+
+void CRenderSystemGLES::SetVSync(bool enable)
+{
+  if (m_bVSync==enable && m_bVsyncInit == true)
+    return;
+
+  if (!m_bRenderCreated)
+    return;
+  
+  if (enable)
+    CLog::Log(LOGINFO, "GLES: Enabling VSYNC");
+  else
+    CLog::Log(LOGINFO, "GLES: Disabling VSYNC");
+
+  m_iVSyncMode   = 0;
+  m_iVSyncErrors = 0;
+  m_iSwapRate    = 0;
+  m_bVSync       = enable;
+  m_bVsyncInit   = true;
+
+  SetVSyncImpl(enable);
+  
+  if (!enable)
+    return;
+
+  if (g_advancedSettings.m_ForcedSwapTime != 0.0)
+  {
+    /* some hardware busy wait on swap/glfinish, so we must manually sleep to avoid 100% cpu */
+    double rate = g_graphicsContext.GetFPS();
+    if (rate <= 0.0 || rate > 1000.0)
+    {
+      CLog::Log(LOGWARNING, "Unable to determine a valid horizontal refresh rate, vsync workaround disabled %.2g", rate);
+      m_iSwapRate = 0;
+    }
+    else
+    {
+      int64_t freq;
+      freq = CurrentHostFrequency();
+      m_iSwapRate   = (int64_t)((double)freq / rate);
+      m_iSwapTime   = (int64_t)(0.001 * g_advancedSettings.m_ForcedSwapTime * freq);
+      m_iSwapStamp  = 0;
+      CLog::Log(LOGINFO, "GLES: Using artificial vsync sleep with rate %f", rate);
+      if(!m_iVSyncMode)
+        m_iVSyncMode = 1;
+    }
+  }
+    
+  if (!m_iVSyncMode)
+    CLog::Log(LOGERROR, "GLES: Vertical Blank Syncing unsupported");
+  else
+    CLog::Log(LOGINFO, "GLES: Selected vsync mode %d", m_iVSyncMode);
+}
+
+void CRenderSystemGLES::CaptureStateBlock()
+{
+  if (!m_bRenderCreated)
+    return;
+
+  g_matrices.MatrixMode(MM_PROJECTION);
+  g_matrices.PushMatrix();
+  g_matrices.MatrixMode(MM_TEXTURE);
+  g_matrices.PushMatrix();
+  g_matrices.MatrixMode(MM_MODELVIEW);
+  g_matrices.PushMatrix();
+  glDisable(GL_SCISSOR_TEST); // fixes FBO corruption on Macs
+  glActiveTexture(GL_TEXTURE0);
+//TODO - NOTE: Only for Screensavers & Visualisations
+//  glColor3f(1.0, 1.0, 1.0);
+}
+
+void CRenderSystemGLES::ApplyStateBlock()
+{
+  if (!m_bRenderCreated)
+    return;
+
+  g_matrices.MatrixMode(MM_PROJECTION);
+  g_matrices.PopMatrix();
+  g_matrices.MatrixMode(MM_TEXTURE);
+  g_matrices.PopMatrix();
+  g_matrices.MatrixMode(MM_MODELVIEW);
+  g_matrices.PopMatrix();
+  glActiveTexture(GL_TEXTURE0);
+  glEnable(GL_BLEND);
+  glEnable(GL_SCISSOR_TEST);  
+  glClear(GL_DEPTH_BUFFER_BIT);
+}
+
+void CRenderSystemGLES::SetCameraPosition(const CPoint &camera, int screenWidth, int screenHeight)
+{ 
+  if (!m_bRenderCreated)
+    return;
+  
+  g_graphicsContext.BeginPaint();
+  
+  CPoint offset = camera - CPoint(screenWidth*0.5f, screenHeight*0.5f);
+  
+  GLint viewport[4];
+  glGetIntegerv(GL_VIEWPORT, viewport);
+
+  float w = (float)viewport[2]*0.5f;
+  float h = (float)viewport[3]*0.5f;
+
+  g_matrices.MatrixMode(MM_MODELVIEW);
+  g_matrices.LoadIdentity();
+  g_matrices.Translatef(-(viewport[0] + w + offset.x), +(viewport[1] + h + offset.y), 0);
+  g_matrices.LookAt(0.0, 0.0, -2.0*h, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0);
+  g_matrices.MatrixMode(MM_PROJECTION);
+  g_matrices.LoadIdentity();
+  g_matrices.Frustum( (-w - offset.x)*0.5f, (w - offset.x)*0.5f, (-h + offset.y)*0.5f, (h + offset.y)*0.5f, h, 100*h);
+  g_matrices.MatrixMode(MM_MODELVIEW);
+
+  glGetIntegerv(GL_VIEWPORT, m_viewPort);
+  GLfloat* matx;
+  matx = g_matrices.GetMatrix(MM_MODELVIEW);
+  memcpy(m_view, matx, 16 * sizeof(GLfloat));
+  matx = g_matrices.GetMatrix(MM_PROJECTION);
+  memcpy(m_projection, matx, 16 * sizeof(GLfloat));
+
+  g_graphicsContext.EndPaint();
+}
+
+void CRenderSystemGLES::Project(float &x, float &y, float &z)
+{
+  GLfloat coordX, coordY, coordZ;
+  if (g_matrices.Project(x, y, z, m_view, m_projection, m_viewPort, &coordX, &coordY, &coordZ))
+  {
+    x = coordX;
+    y = (float)(m_viewPort[3] - coordY);
+    z = 0;
+  }
+}
+
+bool CRenderSystemGLES::TestRender()
+{
+  static float theta = 0.0;
+
+  //RESOLUTION_INFO resInfo = g_settings.m_ResInfo[g_guiSettings.m_LookAndFeelResolution];
+  //glViewport(0, 0, resInfo.iWidth, resInfo.iHeight);
+
+  g_matrices.PushMatrix();
+  g_matrices.Rotatef( theta, 0.0f, 0.0f, 1.0f );
+
+  EnableGUIShader(SM_DEFAULT);
+
+  GLfloat col[3][4];
+  GLfloat ver[3][2];
+  GLint   posLoc = GUIShaderGetPos();
+  GLint   colLoc = GUIShaderGetCol();
+
+  glVertexAttribPointer(posLoc,  2, GL_FLOAT, 0, 0, ver);
+  glVertexAttribPointer(colLoc,  4, GL_FLOAT, 0, 0, col);
+
+  glEnableVertexAttribArray(posLoc);
+  glEnableVertexAttribArray(colLoc);
+
+  // Setup Colour values
+  col[0][0] = col[0][3] = col[1][1] = col[1][3] = col[2][2] = col[2][3] = 1.0f;
+  col[0][1] = col[0][2] = col[1][0] = col[1][2] = col[2][0] = col[2][1] = 0.0f;
+
+  // Setup vertex position values
+  ver[0][0] =  0.0f;
+  ver[0][1] =  1.0f;
+  ver[1][0] =  0.87f;
+  ver[1][1] = -0.5f;
+  ver[2][0] = -0.87f;
+  ver[2][1] = -0.5f;
+
+  glDrawArrays(GL_TRIANGLES, 0, 3);
+
+  glDisableVertexAttribArray(posLoc);
+  glDisableVertexAttribArray(colLoc);
+
+  DisableGUIShader();
+
+  g_matrices.PopMatrix();
+
+  theta += 1.0f;
+
+  return true;
+}
+
+void CRenderSystemGLES::ApplyHardwareTransform(const TransformMatrix &finalMatrix)
+{ 
+  if (!m_bRenderCreated)
+    return;
+
+  g_matrices.MatrixMode(MM_MODELVIEW);
+  g_matrices.PushMatrix();
+  GLfloat matrix[4][4];
+
+  for(int i = 0; i < 3; i++)
+    for(int j = 0; j < 4; j++)
+      matrix[j][i] = finalMatrix.m[i][j];
+
+  matrix[0][3] = 0.0f;
+  matrix[1][3] = 0.0f;
+  matrix[2][3] = 0.0f;
+  matrix[3][3] = 1.0f;
+
+  g_matrices.MultMatrixf(&matrix[0][0]);
+}
+
+void CRenderSystemGLES::RestoreHardwareTransform()
+{
+  if (!m_bRenderCreated)
+    return;
+
+  g_matrices.MatrixMode(MM_MODELVIEW);
+  g_matrices.PopMatrix();
+}
+
+void CRenderSystemGLES::CalculateMaxTexturesize()
+{
+  // GLES cannot do PROXY textures to determine maximum size,
+  CLog::Log(LOGINFO, "GLES: Maximum texture width: %u", m_maxTextureSize);
+}
+
+void CRenderSystemGLES::GetViewPort(CRect& viewPort)
+{
+  if (!m_bRenderCreated)
+    return;
+  
+  GLint glvp[4];
+  glGetIntegerv(GL_VIEWPORT, glvp);
+  
+  viewPort.x1 = glvp[0];
+  viewPort.y1 = m_height - glvp[1] - glvp[3];
+  viewPort.x2 = glvp[0] + glvp[2];
+  viewPort.y2 = viewPort.y1 + glvp[3];
+}
+
+// FIXME make me const so that I can accept temporary objects
+void CRenderSystemGLES::SetViewPort(CRect& viewPort)
+{
+  if (!m_bRenderCreated)
+    return;
+
+  glScissor((GLint) viewPort.x1, (GLint) (m_height - viewPort.y1 - viewPort.Height()), (GLsizei) viewPort.Width(), (GLsizei) viewPort.Height());
+  glViewport((GLint) viewPort.x1, (GLint) (m_height - viewPort.y1 - viewPort.Height()), (GLsizei) viewPort.Width(), (GLsizei) viewPort.Height());
+}
+
+void CRenderSystemGLES::SetScissors(const CRect &rect)
+{
+  if (!m_bRenderCreated)
+    return;
+  GLint x1 = MathUtils::round_int(rect.x1);
+  GLint y1 = MathUtils::round_int(rect.y1);
+  GLint x2 = MathUtils::round_int(rect.x2);
+  GLint y2 = MathUtils::round_int(rect.y2);
+  glScissor(x1, m_height - y2, x2-x1, y2-y1);
+}
+
+void CRenderSystemGLES::ResetScissors()
+{
+  SetScissors(CRect(0, 0, (float)m_width, (float)m_height));
+}
+
+void CRenderSystemGLES::InitialiseGUIShader()
+{
+  if (!m_pGUIshader)
+  {
+    m_pGUIshader = new CGUIShader*[SM_ESHADERCOUNT];
+    for (int i = 0; i < SM_ESHADERCOUNT; i++)
+    {
+      m_pGUIshader[i] = new CGUIShader( ShaderNames[i] );
+
+      if (!m_pGUIshader[i]->CompileAndLink())
+      {
+        m_pGUIshader[i]->Free();
+        delete m_pGUIshader[i];
+        m_pGUIshader[i] = NULL;
+        CLog::Log(LOGERROR, "GUI Shader [%s] - Initialise failed", ShaderNames[i]);
+      }
+      else
+      {
+        CLog::Log(LOGDEBUG, "GUI Shader [%s]- Initialise successful : %p", ShaderNames[i], m_pGUIshader[i]);
+      }
+    }
+  }
+  else
+  {
+    CLog::Log(LOGDEBUG, "GUI Shader - Tried to Initialise again. Was this intentional?");
+  }
+}
+
+void CRenderSystemGLES::EnableGUIShader(ESHADERMETHOD method)
+{
+  m_method = method;
+  if (m_pGUIshader[m_method])
+  {
+    m_pGUIshader[m_method]->Enable();
+  }
+  else
+  {
+    CLog::Log(LOGERROR, "Invalid GUI Shader selected - [%s]", ShaderNames[(int)method]);
+  }
+}
+
+void CRenderSystemGLES::DisableGUIShader()
+{
+  if (m_pGUIshader[m_method])
+  {
+    m_pGUIshader[m_method]->Disable();
+  }
+  m_method = SM_DEFAULT;
+}
+
+GLint CRenderSystemGLES::GUIShaderGetPos()
+{
+  if (m_pGUIshader[m_method])
+    return m_pGUIshader[m_method]->GetPosLoc();
+
+  return -1;
+}
+
+GLint CRenderSystemGLES::GUIShaderGetCol()
+{
+  if (m_pGUIshader[m_method])
+    return m_pGUIshader[m_method]->GetColLoc();
+
+  return -1;
+}
+
+GLint CRenderSystemGLES::GUIShaderGetCoord0()
+{
+  if (m_pGUIshader[m_method])
+    return m_pGUIshader[m_method]->GetCord0Loc();
+
+  return -1;
+}
+
+GLint CRenderSystemGLES::GUIShaderGetCoord1()
+{
+  if (m_pGUIshader[m_method])
+    return m_pGUIshader[m_method]->GetCord1Loc();
+
+  return -1;
+}
+
+#endif
diff -Nur xbmc-nightly.org/xbmc/rendering/gles/RenderSystemGLES.h xbmc-nightly/xbmc/rendering/gles/RenderSystemGLES.h
--- xbmc-nightly.org/xbmc/rendering/gles/RenderSystemGLES.h	2014-01-24 22:02:29.153155396 -0800
+++ xbmc-nightly/xbmc/rendering/gles/RenderSystemGLES.h	2014-02-14 18:27:05.156591851 -0800
@@ -26,6 +26,7 @@
 #include "system.h"
 #include "system_gl.h"
 #include "rendering/RenderSystem.h"
+#if HAS_GLES == 2
 #include "xbmc/guilib/GUIShader.h"
 
 enum ESHADERMETHOD
@@ -40,6 +41,7 @@
   SM_TEXTURE_RGBA_BLENDCOLOR,
   SM_ESHADERCOUNT
 };
+#endif
 
 class CRenderSystemGLES : public CRenderSystemBase
 {
@@ -77,6 +79,7 @@
 
   virtual void Project(float &x, float &y, float &z);
   
+#if HAS_GLES == 2
   void InitialiseGUIShader();
   void EnableGUIShader(ESHADERMETHOD method);
   void DisableGUIShader();
@@ -85,6 +88,7 @@
   GLint GUIShaderGetCol();
   GLint GUIShaderGetCoord0();
   GLint GUIShaderGetCoord1();
+#endif
 
 protected:
   virtual void SetVSyncImpl(bool enable) = 0;
@@ -102,8 +106,10 @@
 
   CStdString m_RenderExtensions;
 
+#if HAS_GLES == 2
   CGUIShader  **m_pGUIshader;  // One GUI shader for each method
   ESHADERMETHOD m_method;      // Current GUI Shader method
+#endif
 
   GLfloat    m_view[16];
   GLfloat    m_projection[16];
diff -Nur xbmc-nightly.org/xbmc/settings/AdvancedSettings.cpp xbmc-nightly/xbmc/settings/AdvancedSettings.cpp
--- xbmc-nightly.org/xbmc/settings/AdvancedSettings.cpp	2014-01-24 22:02:29.155155650 -0800
+++ xbmc-nightly/xbmc/settings/AdvancedSettings.cpp	2014-02-14 18:27:05.157591978 -0800
@@ -72,7 +72,11 @@
   m_karaokeAlwaysEmptyOnCdgs = 1;
   m_karaokeUseSongSpecificBackground = 0;
 
+#ifdef HAS_PAPLAYER
   m_audioDefaultPlayer = "paplayer";
+#else
+  m_audioDefaultPlayer = "gstplayer";
+#endif
   m_audioPlayCountMinimumPercent = 90.0f;
   m_audioHost = "default";
 
@@ -93,8 +97,13 @@
   m_videoBlackBarColour = 0;
   m_videoPPFFmpegDeint = "linblenddeint";
   m_videoPPFFmpegPostProc = "ha:128:7,va,dr";
-  m_videoDefaultPlayer = "dvdplayer";
-  m_videoDefaultDVDPlayer = "dvdplayer";
+//#ifdef HAS_DVDPLAYER
+//  m_videoDefaultPlayer = "dvdplayer";
+//  m_videoDefaultDVDPlayer = "dvdplayer";
+//#else
+  m_videoDefaultPlayer = "gstplayer";
+  m_videoDefaultDVDPlayer = "gstplayer";
+//#endif
   m_videoIgnoreSecondsAtStart = 3*60;
   m_videoIgnorePercentAtEnd   = 8.0f;
   m_videoPlayCountMinimumPercent = 90.0f;
@@ -104,7 +113,11 @@
   m_videoAutoScaleMaxFps = 30.0f;
   m_videoAllowMpeg4VDPAU = false;
   m_videoAllowMpeg4VAAPI = false;  
+#if defined(HAS_GLES) && HAS_GLES == 1
+  m_videoDisableBackgroundDeinterlace = true;
+#else
   m_videoDisableBackgroundDeinterlace = false;
+#endif
   m_videoCaptureUseOcclusionQuery = -1; //-1 is auto detect
   m_DXVACheckCompatibility = false;
   m_DXVACheckCompatibilityPresent = false;
@@ -182,7 +195,7 @@
   m_playlistAsFolders = true;
   m_detectAsUdf = false;
 
-  m_fanartRes = 1080;
+  m_fanartRes = 720;
   m_imageRes = 720;
   m_useDDSFanart = false;
 
@@ -309,10 +322,10 @@
 
   m_enableMultimediaKeys = false;
 
-  m_canWindowed = true;
+  m_canWindowed = false;
   m_guiVisualizeDirtyRegions = false;
-  m_guiAlgorithmDirtyRegions = 3;
-  m_guiDirtyRegionNoFlipTimeout = 0;
+  m_guiAlgorithmDirtyRegions = 3 /*2=DIRTYREGION_SOLVER_COST_REDUCTION 1=DIRTYREGION_SOLVER_UNION*/;
+  m_guiDirtyRegionNoFlipTimeout = -1;
   m_logEnableAirtunes = false;
   m_airTunesPort = 36666;
   m_airPlayPort = 36667;
@@ -921,8 +934,8 @@
 
   XMLUtils::GetInt(pRootElement, "remotedelay", m_remoteDelay, 1, 20);
   XMLUtils::GetFloat(pRootElement, "controllerdeadzone", m_controllerDeadzone, 0.0f, 1.0f);
-  XMLUtils::GetUInt(pRootElement, "fanartres", m_fanartRes, 0, 1080);
-  XMLUtils::GetUInt(pRootElement, "imageres", m_imageRes, 0, 1080);
+  XMLUtils::GetUInt(pRootElement, "fanartres", m_fanartRes, 0, 720);
+  XMLUtils::GetUInt(pRootElement, "imageres", m_imageRes, 0, 720);
   XMLUtils::GetBoolean(pRootElement, "useddsfanart", m_useDDSFanart);
 
   XMLUtils::GetBoolean(pRootElement, "playlistasfolders", m_playlistAsFolders);
diff -Nur xbmc-nightly.org/xbmc/settings/GUISettings.cpp xbmc-nightly/xbmc/settings/GUISettings.cpp
--- xbmc-nightly.org/xbmc/settings/GUISettings.cpp	2014-01-24 22:02:29.159156158 -0800
+++ xbmc-nightly/xbmc/settings/GUISettings.cpp	2014-02-14 18:27:05.158592105 -0800
@@ -39,10 +39,14 @@
 #include "powermanagement/PowerManager.h"
 #include "cores/dvdplayer/DVDCodecs/Video/CrystalHD.h"
 #include "cores/AudioEngine/AEFactory.h"
+#ifdef HAS_AUDIOENGINE
 #include "cores/AudioEngine/AEAudioFormat.h"
+#endif
 #include "guilib/GUIFont.h" // for FONT_STYLE_* definitions
 #if defined(TARGET_DARWIN_OSX)
+  #ifdef HAS_AUDIOENGINE
   #include "cores/AudioEngine/Engines/CoreAudio/CoreAudioHardware.h"
+  #endif
 #endif
 #include "guilib/GUIFontManager.h"
 #include "utils/Weather.h"
@@ -394,7 +398,7 @@
 
   // this setting would ideally not be saved, as its value is systematically derived from videoscreen.screenmode.
   // contains a DISPLAYMODE
-#if !defined(TARGET_DARWIN_IOS_ATV2) && !defined(TARGET_RASPBERRY_PI)
+#if !defined(TARGET_DARWIN_IOS_ATV2) && !defined(TARGET_RASPBERRY_PI) && !defined(__sh__)
   AddInt(vs, "videoscreen.screen", 240, 0, -1, 1, 32, SPIN_CONTROL_TEXT);
 #endif
   // this setting would ideally not be saved, as its value is systematically derived from videoscreen.screenmode.
@@ -442,7 +446,7 @@
   vsync.insert(make_pair(13106,VSYNC_DISABLED));
   vsync.insert(make_pair(13107,VSYNC_VIDEO));
   vsync.insert(make_pair(13108,VSYNC_ALWAYS));
-  AddInt(vs, "videoscreen.vsync", 13105, DEFAULT_VSYNC, vsync, SPIN_CONTROL_TEXT);
+  AddInt(vs, "videoscreen.vsync", 13105, VSYNC_ALWAYS, vsync, SPIN_CONTROL_TEXT);
 
   AddString(vs, "videoscreen.guicalibration",214,"", BUTTON_CONTROL_STANDARD);
 #if defined(HAS_GL)
@@ -457,11 +461,11 @@
 
   map<int,int> audiomode;
   audiomode.insert(make_pair(338,AUDIO_ANALOG));
-#if !defined(TARGET_RASPBERRY_PI)
+#if !defined(TARGET_RASPBERRY_PI) && !defined(__sh__)
   audiomode.insert(make_pair(339,AUDIO_IEC958));
 #endif
   audiomode.insert(make_pair(420,AUDIO_HDMI  ));
-#if defined(TARGET_RASPBERRY_PI)
+#if defined(TARGET_RASPBERRY_PI) ||  defined(__sh__)
   AddInt(ao, "audiooutput.mode", 337, AUDIO_HDMI, audiomode, SPIN_CONTROL_TEXT);
 #else
   AddInt(ao, "audiooutput.mode", 337, AUDIO_ANALOG, audiomode, SPIN_CONTROL_TEXT);
@@ -484,18 +488,18 @@
   AddBool(aocat, "audiooutput.dtspassthrough"   , 254, true);
 
 
-#if !defined(TARGET_DARWIN) && !defined(TARGET_RASPBERRY_PI)
+#if !defined(TARGET_DARWIN) && !defined(TARGET_RASPBERRY_PI) && !defined(__sh__)
   AddBool(aocat, "audiooutput.passthroughaac"   , 299, false);
 #endif
-#if !defined(TARGET_DARWIN_IOS) && !defined(TARGET_RASPBERRY_PI)
+#if !defined(TARGET_DARWIN_IOS) && !defined(TARGET_RASPBERRY_PI) && !defined(__sh__)
   AddBool(aocat, "audiooutput.multichannellpcm" , 348, true );
 #endif
-#if !defined(TARGET_DARWIN) && !defined(TARGET_RASPBERRY_PI)
+#if !defined(TARGET_DARWIN) && !defined(TARGET_RASPBERRY_PI) && !defined(__sh__)
   AddBool(aocat, "audiooutput.truehdpassthrough", 349, true );
   AddBool(aocat, "audiooutput.dtshdpassthrough" , 347, true );
 #endif
 
-#if !defined(TARGET_RASPBERRY_PI)
+#if !defined(TARGET_RASPBERRY_PI) && !defined(__sh__)
 #if defined(TARGET_DARWIN)
   #if defined(TARGET_DARWIN_IOS)
     CStdString defaultDeviceName = "Default";
@@ -513,7 +517,7 @@
 #endif
 #endif
 
-#if !defined(TARGET_RASPBERRY_PI)
+#if !defined(TARGET_RASPBERRY_PI) && !defined(__sh__)
   map<int,int> guimode;
   guimode.insert(make_pair(34121, AE_SOUND_IDLE  ));
   guimode.insert(make_pair(34122, AE_SOUND_ALWAYS));
@@ -538,7 +542,7 @@
   AddInt(NULL, "input.appleremotesequencetime", 13603, 500, 50, 50, 1000, SPIN_CONTROL_INT_PLUS, MASK_MS, TEXT_OFF);
   AddSeparator(in, "input.sep1");
 #endif
-  AddBool(in, "input.remoteaskeyboard", 21449, false);
+  AddBool(in, "input.remoteaskeyboard", 21449, true);
 #if defined(TARGET_DARWIN_IOS)
   AddBool(NULL, "input.enablemouse", 21369, true);
 #else
@@ -878,9 +882,9 @@
   AddString(laf, "lookandfeel.font",13303,"Default", SPIN_CONTROL_TEXT);
   AddInt(laf, "lookandfeel.skinzoom",20109, 0, -20, 2, 20, SPIN_CONTROL_INT, MASK_PERCENT);
   AddInt(laf, "lookandfeel.startupwindow",512,1, WINDOW_HOME, 1, WINDOW_PYTHON_END, SPIN_CONTROL_TEXT);
-  AddString(laf, "lookandfeel.soundskin",15108,"SKINDEFAULT", SPIN_CONTROL_TEXT);
+  AddString(laf, "lookandfeel.soundskin",15108,"OFF", SPIN_CONTROL_TEXT);
   AddSeparator(laf, "lookandfeel.sep2");
-  AddBool(laf, "lookandfeel.enablerssfeeds",13305,  true);
+  AddBool(laf, "lookandfeel.enablerssfeeds",13305,  false);
   AddString(laf, "lookandfeel.rssedit", 21450, "", BUTTON_CONTROL_STANDARD);
 
   CSettingsCategory* loc = AddCategory(SETTINGS_APPEARANCE, "locale", 14090);
@@ -1360,6 +1364,7 @@
     LoadFromXML(pRootElement, it, hideSettings);
   }
 
+#if 0
   // check if we are updating to Frodo and need to update from
   // audiooutput.channellayout to audiooutput.channels
   TiXmlNode *channelNode = pRootElement->FirstChild("audiooutput");
@@ -1381,6 +1386,7 @@
       updated = true;
     }
   }
+#endif
 
   // and fix the videoscreen.screenmode if necessary
   std::string screenmode = GetString("videoscreen.screenmode");
diff -Nur xbmc-nightly.org/xbmc/settings/GUIWindowSettingsCategory.cpp xbmc-nightly/xbmc/settings/GUIWindowSettingsCategory.cpp
--- xbmc-nightly.org/xbmc/settings/GUIWindowSettingsCategory.cpp	2014-01-24 22:02:29.162156539 -0800
+++ xbmc-nightly/xbmc/settings/GUIWindowSettingsCategory.cpp	2014-02-14 18:27:05.159592232 -0800
@@ -1989,7 +1989,9 @@
       CAEFactory::SetSoundMode(g_guiSettings.GetInt("audiooutput.guisoundmode"));
     }
 
+#if HAS_AUDIOENGINE
     CAEFactory::OnSettingsChange(strSetting);
+#endif
   }
   else if (strSetting.Equals("pvrparental.enabled"))
   {
@@ -2889,7 +2891,9 @@
 
   int selectedValue = -1;
   AEDeviceList sinkList;
+#if HAS_AUDIOENGINE
   CAEFactory::EnumerateOutputDevices(sinkList, Passthrough);
+#endif
 #if !defined(TARGET_DARWIN)
   if (sinkList.size()==0)
   {
diff -Nur xbmc-nightly.org/xbmc/system_gl.h xbmc-nightly/xbmc/system_gl.h
--- xbmc-nightly.org/xbmc/system_gl.h	2014-01-24 22:02:29.175158192 -0800
+++ xbmc-nightly/xbmc/system_gl.h	2014-02-14 18:27:05.171593758 -0800
@@ -51,4 +51,7 @@
     #include <GLES2/gl2.h>
     #include <GLES2/gl2ext.h>
   #endif
+#elif HAS_GLES == 1
+  #include <GLES/gl.h>
+  #include <GLES/glext.h>
 #endif
diff -Nur xbmc-nightly.org/xbmc/system.h xbmc-nightly/xbmc/system.h
--- xbmc-nightly.org/xbmc/system.h	2014-01-24 22:02:29.175158192 -0800
+++ xbmc-nightly/xbmc/system.h	2014-02-14 18:27:05.173594013 -0800
@@ -86,6 +86,18 @@
   #define HAS_UPNP
 #endif
 
+#ifdef HAVE_DVDPLAYER
+  #define HAS_DVDPLAYER
+#endif
+
+#ifdef HAVE_PAPLAYER
+  #define HAS_PAPLAYER
+#endif
+
+#ifdef HAVE_GSTPLAYER
+  #define HAS_GSTPLAYER
+#endif
+
 /**********************
  * Non-free Components
  **********************/
diff -Nur xbmc-nightly.org/xbmc/threads/Atomics.cpp xbmc-nightly/xbmc/threads/Atomics.cpp
--- xbmc-nightly.org/xbmc/threads/Atomics.cpp	2014-01-24 22:02:29.177158446 -0800
+++ xbmc-nightly/xbmc/threads/Atomics.cpp	2014-02-14 18:27:05.161592487 -0800
@@ -67,7 +67,21 @@
   unsigned int prev;
   #error atomic cas undefined for mips
   return prev;
+#elif defined(__sh__)
+  unsigned int prev;
 
+  __asm__ __volatile__ (
+                "   .align 2               \n"
+                "   mov.l   @%2, %0       \n" /* Load the current value of *pAddr(%2) into prev (%0) */
+                "   cmp/eq  %0,  %3       \n" /* Verify that the current value (%2) == old value (%3) */
+                "   bf      2f             \n" /* Bail if the two values are not equal [not as expected] */
+                "   mov.l   %4,  @%2       \n" /* Attempt to store swapVal (%4) value into *pAddr (%2) [p must still be reserved] */
+                "2:                        \n"
+                : "=&r" (prev), "+m" (*pAddr)                   /* Outputs [prev, *pAddr] */
+                : "r" (pAddr), "r" (expectedVal), "r" (swapVal) /* Inputs [pAddr, expectedVal, swapVal] */
+                );
+  
+  return prev;
 #elif defined(WIN32)
   long prev;
   __asm
@@ -103,7 +117,7 @@
 ///////////////////////////////////////////////////////////////////////////
 long long cas2(volatile long long* pAddr, long long expectedVal, long long swapVal)
 {
-#if defined(__ppc__) || defined(__powerpc__) || defined(__arm__) || defined(__mips__) // PowerPC, ARM, and MIPS
+#if defined(__ppc__) || defined(__powerpc__) || defined(__arm__) || defined(__mips__) || defined(__sh__) // PowerPC, ARM, MIPS and SH
 // Not available/required
 // Hack to allow compilation
   throw "cas2 is not implemented";
@@ -187,7 +201,17 @@
   long val;
   #error AtomicIncrement undefined for mips
   return val;
-
+#elif defined(__sh__)
+  register long val;
+  __asm__ __volatile__ (
+                "   .align 2               \n"
+                "   mov.l   @%1,  %0       \n" //Move the first value to val
+                "   add     #1,   %0       \n" //Increase val by 1
+                "   mov.l   %0,   @%1      \n" //Move val to the first value
+                : "=&r" (val)
+                : "r" (pAddr)
+                );
+  return val;
 #elif defined(WIN32)
   long val;
   __asm
@@ -265,7 +289,17 @@
   long val;
   #error AtomicAdd undefined for mips
   return val;
-
+#elif defined(__sh__)
+  register long val;
+  __asm__ __volatile__ (
+                "   .align 2               \n"
+                "   mov.l   @%1,  %0       \n"
+                "   add     %2,   %0       \n"
+                "   mov.l   %0,   @%1      \n"
+                : "=&r" (val)
+                : "r" (pAddr), "r" (amount)
+  );
+  return val;
 #elif defined(WIN32)
   __asm
   {
@@ -343,7 +377,17 @@
   long val;
   #error AtomicDecrement undefined for mips
   return val;
-
+#elif defined(__sh__)
+  register long val;
+  __asm__ __volatile__ (
+                "   .align 2               \n"
+                "   mov.l   @%1,  %0       \n"
+                "   add     #-1,  %0       \n"
+                "   mov.l   %0,   @%1      \n"
+                : "=&r" (val)
+                : "r" (pAddr)
+  );
+  return val;
 #elif defined(WIN32)
   long val;
   __asm
@@ -421,7 +465,18 @@
 // TODO:
   #error AtomicSubtract undefined for mips
   return val;
-
+#elif defined(__sh__)
+  register long val;
+  amount *= -1;
+  __asm__ __volatile__ (
+                "   .align 2               \n"
+                "   mov.l   @%1,  %0       \n"
+                "   add     %2,   %0       \n"
+                "   mov.l   %0,   @%1      \n"
+                : "=&r" (val)
+                : "r" (pAddr), "r" (amount)
+  );
+  return val;
 #elif defined(WIN32)
   amount *= -1;
   __asm
diff -Nur xbmc-nightly.org/xbmc/threads/Atomics.h xbmc-nightly/xbmc/threads/Atomics.h
--- xbmc-nightly.org/xbmc/threads/Atomics.h	2014-01-24 22:02:29.177158446 -0800
+++ xbmc-nightly/xbmc/threads/Atomics.h	2014-02-14 18:27:05.161592487 -0800
@@ -23,7 +23,7 @@
 
 // TODO: Inline these methods
 long cas(volatile long *pAddr, long expectedVal, long swapVal);
-#if !defined(__ppc__) && !defined(__powerpc__) && !defined(__arm__)
+#if !defined(__ppc__) && !defined(__powerpc__) && !defined(__arm__) && !defined(__sh__)
 long long cas2(volatile long long* pAddr, long long expectedVal, long long swapVal);
 #endif
 long AtomicIncrement(volatile long* pAddr);
diff -Nur xbmc-nightly.org/xbmc/threads/LockFree.cpp xbmc-nightly/xbmc/threads/LockFree.cpp
--- xbmc-nightly.org/xbmc/threads/LockFree.cpp	2014-01-24 22:02:29.178158573 -0800
+++ xbmc-nightly/xbmc/threads/LockFree.cpp	2014-02-14 18:27:05.162592614 -0800
@@ -43,7 +43,7 @@
     top = pStack->top;
     pNode->next.ptr = top.ptr; // Link in the new node
     newTop.ptr = pNode;
-#if defined(__ppc__) || defined(__powerpc__) || defined(__arm__)
+#if defined(__ppc__) || defined(__powerpc__) || defined(__arm__) || defined(__sh__)
   } while(cas((long*)&pStack->top, atomic_ptr_to_long(top), atomic_ptr_to_long(newTop)) != atomic_ptr_to_long(top));
 #else
     newTop.version = top.version + 1;
@@ -61,7 +61,7 @@
     if (top.ptr == NULL)
       return NULL;
     newTop.ptr = ((lf_node*)top.ptr)->next.ptr; // Unlink the current top node
-#if defined(__ppc__) || defined(__powerpc__) || defined(__arm__)
+#if defined(__ppc__) || defined(__powerpc__) || defined(__arm__) || defined(__sh__)
   } while(cas((long*)&pStack->top, atomic_ptr_to_long(top), atomic_ptr_to_long(newTop)) != atomic_ptr_to_long(top));
 #else
     newTop.version = top.version + 1;
@@ -186,7 +186,7 @@
   {
     tail = pQueue->tail;
     next = ((lf_queue_node*)tail.ptr)->next;
-#if defined(__ppc__) || defined(__powerpc__) || defined(__arm__)
+#if defined(__ppc__) || defined(__powerpc__) || defined(__arm__) || defined(__sh__)
     if (atomic_ptr_to_long(tail) == atomic_ptr_to_long(pQueue->tail)) // Check consistency
 #else
     if (atomic_ptr_to_long_long(tail) == atomic_ptr_to_long_long(pQueue->tail)) // Check consistency
@@ -195,7 +195,7 @@
       if (next.ptr == NULL) // Was tail pointing to the last node?
       {
         node.ptr = pNode;
-#if defined(__ppc__) || defined(__powerpc__) || defined(__arm__)
+#if defined(__ppc__) || defined(__powerpc__) || defined(__arm__) || defined(__sh__)
         if (cas((long*)&((lf_queue_node*)tail.ptr)->next, atomic_ptr_to_long(next), atomic_ptr_to_long(node)) == atomic_ptr_to_long(next)) // Try to link node at end
 #else
         node.version = next.version + 1;
@@ -206,7 +206,7 @@
       else // tail was lagging, try to help...
       {
         node.ptr = next.ptr;
-#if defined(__ppc__) || defined(__powerpc__) || defined(__arm__)
+#if defined(__ppc__) || defined(__powerpc__) || defined(__arm__) || defined(__sh__)
         cas((long*)&pQueue->tail, atomic_ptr_to_long(tail), atomic_ptr_to_long(node)); // We don't care if we  are successful or not
 #else
         node.version = tail.version + 1;
@@ -216,7 +216,7 @@
     }
   } while (true); // Keep trying until the enqueue is done
   node.ptr = pNode;
-#if defined(__ppc__) || defined(__powerpc__) || defined(__arm__)
+#if defined(__ppc__) || defined(__powerpc__) || defined(__arm__) || defined(__sh__)
   cas((long*)&pQueue->tail, atomic_ptr_to_long(tail), atomic_ptr_to_long(node)); // Try to swing the tail to the new node
 #else
   node.version = tail.version + 1;
@@ -235,7 +235,7 @@
     head = pQueue->head;
     tail = pQueue->tail;
     next = ((lf_queue_node*)head.ptr)->next;
-#if defined(__ppc__) || defined(__powerpc__) || defined(__arm__)
+#if defined(__ppc__) || defined(__powerpc__) || defined(__arm__) || defined(__sh__)
     if (atomic_ptr_to_long(head) == atomic_ptr_to_long(pQueue->head)) // Check consistency
 #else
     if (atomic_ptr_to_long_long(head) == atomic_ptr_to_long_long(pQueue->head)) // Check consistency
@@ -246,7 +246,7 @@
         if (next.ptr == NULL) // Queue is empty
           return NULL;
         node.ptr = next.ptr;
-#if defined(__ppc__) || defined(__powerpc__) || defined(__arm__)
+#if defined(__ppc__) || defined(__powerpc__) || defined(__arm__) || defined(__sh__)
         cas((long*)&pQueue->tail, atomic_ptr_to_long(tail), atomic_ptr_to_long(node)); // Tail is lagging. Try to advance it.
 #else
         node.version = tail.version + 1;
@@ -257,7 +257,7 @@
       {
         pVal = ((lf_queue_node*)next.ptr)->value;
         node.ptr = next.ptr;
-#if defined(__ppc__) || defined(__powerpc__) || defined(__arm__)
+#if defined(__ppc__) || defined(__powerpc__) || defined(__arm__) || defined(__sh__)
         if (cas((long*)&pQueue->head, atomic_ptr_to_long(head), atomic_ptr_to_long(node)) == atomic_ptr_to_long(head))
 #else
         node.version = head.version + 1;
diff -Nur xbmc-nightly.org/xbmc/threads/LockFree.h xbmc-nightly/xbmc/threads/LockFree.h
--- xbmc-nightly.org/xbmc/threads/LockFree.h	2014-01-24 22:02:29.179158700 -0800
+++ xbmc-nightly/xbmc/threads/LockFree.h	2014-02-14 18:27:05.163592741 -0800
@@ -30,7 +30,7 @@
 // A unique-valued pointer. Version is incremented with each write.
 union atomic_ptr
 {
-#if !defined(__ppc__) && !defined(__powerpc__) && !defined(__arm__)
+#if !defined(__ppc__) && !defined(__powerpc__) && !defined(__arm__) && !defined(__sh__)
   long long d;
   struct {
     void* ptr;
@@ -44,7 +44,7 @@
 #endif
 };
 
-#if defined(__ppc__) || defined(__powerpc__) || defined(__arm__)
+#if defined(__ppc__) || defined(__powerpc__) || defined(__arm__) || defined(__sh__)
   #define atomic_ptr_to_long(p) (long) *((long*)&p)
 #else
   // This is ugly but correct as long as sizeof(void*) == sizeof(long)...
diff -Nur xbmc-nightly.org/xbmc/utils/CPUInfo.cpp xbmc-nightly/xbmc/utils/CPUInfo.cpp
--- xbmc-nightly.org/xbmc/utils/CPUInfo.cpp	2014-01-24 22:02:31.721481820 -0800
+++ xbmc-nightly/xbmc/utils/CPUInfo.cpp	2014-02-14 18:27:05.163592741 -0800
@@ -322,7 +322,11 @@
           m_cores[nCurrId].m_strSerial.Trim();
         }
       }
+#if defined(__sh__)
+      else if (strncmp(buffer, "cpu type", strlen("cpu type"))==0)
+#else
       else if (strncmp(buffer, "model name", strlen("model name"))==0)
+#endif
       {
         char *needle = strstr(buffer, ":");
         if (needle && strlen(needle)>3)
@@ -490,7 +494,11 @@
   rewind(m_fCPUInfo);
   fflush(m_fCPUInfo);
   while (fgets(buf, 256, m_fCPUInfo) != NULL) {
+#if defined(__sh__)
+    if (strncmp(buf, "bogomips", 8) == 0) {
+#else
     if (strncmp(buf, "cpu MHz", 7) == 0) {
+#endif
       needle = strchr(buf, ':');
       sscanf(++needle, "%f", &mhz);
       break;
@@ -816,7 +824,7 @@
   #endif
 #elif defined(LINUX)
 // empty on purpose, the implementation is in the constructor
-#elif !defined(__powerpc__) && !defined(__ppc__) && !defined(__arm__)
+#elif !defined(__powerpc__) && !defined(__ppc__) && !defined(__arm__)&& !defined(__sh__)
   m_cpuFeatures |= CPU_FEATURE_MMX;
 #elif defined(__powerpc__) || defined(__ppc__)
   m_cpuFeatures |= CPU_FEATURE_ALTIVEC;
diff -Nur xbmc-nightly.org/xbmc/utils/fastmemcpy.c xbmc-nightly/xbmc/utils/fastmemcpy.c
--- xbmc-nightly.org/xbmc/utils/fastmemcpy.c	2014-01-24 22:02:31.755486143 -0800
+++ xbmc-nightly/xbmc/utils/fastmemcpy.c	2014-02-14 18:27:05.165592996 -0800
@@ -21,7 +21,7 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA 02110-1301, USA.
  *****************************************************************************/
-#if !defined(_WIN32) && !defined(__ppc__) && !defined(__powerpc__) && !defined(__arm__) 
+#if !defined(_WIN32) && !defined(__ppc__) && !defined(__powerpc__) && !defined(__arm__) && !defined(__sh__) 
 #define HAVE_MMX2
 #define HAVE_SSE
 
diff -Nur xbmc-nightly.org/xbmc/utils/fastmemcpy.h xbmc-nightly/xbmc/utils/fastmemcpy.h
--- xbmc-nightly.org/xbmc/utils/fastmemcpy.h	2014-01-24 22:02:31.755486143 -0800
+++ xbmc-nightly/xbmc/utils/fastmemcpy.h	2014-02-14 18:27:05.165592996 -0800
@@ -23,7 +23,7 @@
 extern "C" {
 #endif
 
-#if !defined(_WIN32) && !defined(__ppc__) && !defined(__powerpc__) && !defined(TARGET_ANDROID) && !defined(TARGET_DARWIN_IOS)
+#if !defined(_WIN32) && !defined(__ppc__) && !defined(__powerpc__) && !defined(__sh__) && !defined(TARGET_ANDROID) && !defined(TARGET_DARWIN_IOS)
 void * fast_memcpy(void * to, const void * from, size_t len);
 //#define fast_memcpy memcpy
 #else
diff -Nur xbmc-nightly.org/xbmc/utils/GLUtils.cpp xbmc-nightly/xbmc/utils/GLUtils.cpp
--- xbmc-nightly.org/xbmc/utils/GLUtils.cpp	2014-01-24 22:02:31.726482457 -0800
+++ xbmc-nightly/xbmc/utils/GLUtils.cpp	2014-02-14 18:27:05.166593123 -0800
@@ -85,11 +85,13 @@
   else
     CLog::Log(LOGNOTICE, "GL_VERSION = NULL");
 
+#if defined(HAS_GL) || (defined(HAS_GLES) && HAS_GLES == 2)
   s = glGetString(GL_SHADING_LANGUAGE_VERSION);
   if (s)
     CLog::Log(LOGNOTICE, "GL_SHADING_LANGUAGE_VERSION = %s", s);
   else
     CLog::Log(LOGNOTICE, "GL_SHADING_LANGUAGE_VERSION = NULL");
+#endif
 
   //GL_NVX_gpu_memory_info extension
 #define GL_GPU_MEMORY_INFO_DEDICATED_VIDMEM_NVX          0x9047
diff -Nur xbmc-nightly.org/xbmc/utils/MathUtils.h xbmc-nightly/xbmc/utils/MathUtils.h
--- xbmc-nightly.org/xbmc/utils/MathUtils.h	2014-01-24 22:02:31.735483601 -0800
+++ xbmc-nightly/xbmc/utils/MathUtils.h	2014-02-14 18:27:05.167593250 -0800
@@ -34,6 +34,7 @@
 
 #if defined(__ppc__) || \
     defined(__powerpc__) || \
+    defined(__sh__) || \
    (defined(__APPLE__) && defined(__arm__) && defined(__llvm__)) || \
    (defined(__ANDROID__) && defined(__arm__)) || \
     defined(TARGET_RASPBERRY_PI)
@@ -42,6 +43,7 @@
 
 #if defined(__ppc__) || \
     defined(__powerpc__) || \
+    defined(__sh__) || \
    (defined(__APPLE__) && defined(__llvm__)) || \
    (defined(__ANDROID__) && defined(__arm__)) || \
     defined(TARGET_RASPBERRY_PI)
diff -Nur xbmc-nightly.org/xbmc/utils/Screenshot.cpp xbmc-nightly/xbmc/utils/Screenshot.cpp
--- xbmc-nightly.org/xbmc/utils/Screenshot.cpp	2014-01-24 22:02:31.741484364 -0800
+++ xbmc-nightly/xbmc/utils/Screenshot.cpp	2014-02-14 18:27:05.167593250 -0800
@@ -124,7 +124,7 @@
   unsigned char* surface = new unsigned char[m_stride * m_height];
 
   //read pixels from the backbuffer
-#if HAS_GLES == 2
+#if HAS_GLES == 2 || HAS_GLES == 1
   glReadPixels(viewport[0], viewport[1], viewport[2], viewport[3], GL_RGBA, GL_UNSIGNED_BYTE, (GLvoid*)surface);
 #else
   glReadPixels(viewport[0], viewport[1], viewport[2], viewport[3], GL_BGRA, GL_UNSIGNED_BYTE, (GLvoid*)surface);
diff -Nur xbmc-nightly.org/xbmc/video/windows/GUIWindowFullScreen.cpp xbmc-nightly/xbmc/video/windows/GUIWindowFullScreen.cpp
--- xbmc-nightly.org/xbmc/video/windows/GUIWindowFullScreen.cpp	2014-01-24 22:02:31.790490594 -0800
+++ xbmc-nightly/xbmc/video/windows/GUIWindowFullScreen.cpp	2014-02-14 18:27:05.168593377 -0800
@@ -639,7 +639,7 @@
 {
   CGUIWindow::OnWindowLoaded();
   // override the clear colour - we must never clear fullscreen
-  m_clearBackground = 0;
+  //m_clearBackground = 1;
 
   CGUIProgressControl* pProgress = (CGUIProgressControl*)GetControl(CONTROL_PROGRESS);
   if(pProgress)
diff -Nur xbmc-nightly.org/xbmc/windowing/egl/EGLNativeTypeStgles.cpp xbmc-nightly/xbmc/windowing/egl/EGLNativeTypeStgles.cpp
--- xbmc-nightly.org/xbmc/windowing/egl/EGLNativeTypeStgles.cpp	1969-12-31 16:00:00.000000000 -0800
+++ xbmc-nightly/xbmc/windowing/egl/EGLNativeTypeStgles.cpp	2014-02-14 18:27:05.168593377 -0800
@@ -0,0 +1,385 @@
+/*
+ *      Copyright (C) 2011-2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+#include "system.h"
+#include <EGL/egl.h>
+#include "EGLNativeTypeStgles.h"
+#include <stdlib.h>
+#include "utils/StringUtils.h"
+#include "guilib/gui3d.h"
+
+CEGLNativeTypeStgles::CEGLNativeTypeStgles()
+{
+}
+
+CEGLNativeTypeStgles::~CEGLNativeTypeStgles()
+{
+}
+
+bool CEGLNativeTypeStgles::CheckCompatibility()
+{
+  return true;
+}
+
+void CEGLNativeTypeStgles::Initialize()
+{
+  return;
+}
+void CEGLNativeTypeStgles::Destroy()
+{
+  return;
+}
+
+bool CEGLNativeTypeStgles::CreateNativeDisplay()
+{
+  m_nativeDisplay = EGL_DEFAULT_DISPLAY;
+  return true;
+}
+
+bool CEGLNativeTypeStgles::CreateNativeWindow()
+{
+  return true;
+}
+
+bool CEGLNativeTypeStgles::GetNativeDisplay(XBNativeDisplayType **nativeDisplay) const
+{
+  if (!nativeDisplay)
+    return false;
+  *nativeDisplay = (XBNativeDisplayType*) &m_nativeDisplay;
+  return true;
+}
+
+bool CEGLNativeTypeStgles::GetNativeWindow(XBNativeWindowType **nativeWindow) const
+{
+  if (!nativeWindow)
+    return false;
+  *nativeWindow = (XBNativeWindowType*) &m_nativeWindow;
+  return true;
+}
+
+bool CEGLNativeTypeStgles::DestroyNativeDisplay()
+{
+  return true;
+}
+
+bool CEGLNativeTypeStgles::DestroyNativeWindow()
+{
+  free(m_nativeWindow);
+  return true;
+}
+
+bool CEGLNativeTypeStgles::GetNativeResolution(RESOLUTION_INFO *res) const
+{
+  char mode[256] = {0};
+  get_sysfs_str("/proc/stb/video/videomode", mode, 255);
+  return ModeToResolution(mode, res);
+}
+
+bool CEGLNativeTypeStgles::SetNativeResolution(const RESOLUTION_INFO &res)
+{
+  if (res.iScreenWidth == 1920 && res.iScreenHeight == 1080)
+  {
+    if (res.dwFlags & D3DPRESENTFLAG_INTERLACED)
+    {
+      if ((int)res.fRefreshRate == 60)
+        SetDisplayResolution("1080i50");
+      else
+        SetDisplayResolution("1080i50");
+    }
+    else
+    {
+      if ((int)res.fRefreshRate == 60)
+        SetDisplayResolution("1080p60");
+      else if ((int)res.fRefreshRate == 59)
+        SetDisplayResolution("1080p59");
+      else if ((int)res.fRefreshRate == 30)
+        SetDisplayResolution("1080p30");
+      else if ((int)res.fRefreshRate == 25)
+        SetDisplayResolution("1080p25");
+      else if ((int)res.fRefreshRate == 24)
+        SetDisplayResolution("1080p24");
+      else
+        SetDisplayResolution("1080p50");
+    }
+  }
+  else if (res.iScreenWidth == 1280 && res.iScreenHeight == 720)
+  {
+    if ((int)res.fRefreshRate == 60)
+      SetDisplayResolution("720p60");
+    else
+      SetDisplayResolution("720p50");
+  }
+  else if (res.iScreenWidth == 720  && res.iScreenHeight == 576)
+  {
+    if (res.dwFlags & D3DPRESENTFLAG_INTERLACED)
+    {
+      SetDisplayResolution("576i50");
+    } else {
+      SetDisplayResolution("576p50");
+    }
+  }
+  return true;
+}
+
+bool CEGLNativeTypeStgles::ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions)
+{
+  char valstr[256] = {0};
+  get_sysfs_str("/proc/stb/video/videomode_choices", valstr, 255);
+  std::vector<CStdString> probe_str;
+  StringUtils::SplitString(valstr, " ", probe_str);
+
+  resolutions.clear();
+  RESOLUTION_INFO res;
+  for (size_t i = 0; i < probe_str.size(); i++)
+  {
+    if(ModeToResolution(probe_str[i].c_str(), &res))
+      resolutions.push_back(res);
+  }
+  return resolutions.size() > 0;
+
+}
+
+bool CEGLNativeTypeStgles::GetPreferredResolution(RESOLUTION_INFO *res) const
+{
+  res->iWidth = 1280;
+  res->iHeight= 720;
+  res->fRefreshRate = 50;
+  res->dwFlags= D3DPRESENTFLAG_PROGRESSIVE;
+  res->iScreen       = 0;
+  res->bFullScreen   = true;
+  res->iSubtitles    = (int)(0.965 * res->iHeight);
+  res->fPixelRatio   = 1.0f;
+  res->iScreenWidth  = res->iWidth;
+  res->iScreenHeight = res->iHeight;
+  res->strMode.Format("%dx%d @ %.2f%s - Full Screen", res->iScreenWidth, res->iScreenHeight, res->fRefreshRate,
+     res->dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "");
+  return true;
+}
+
+bool CEGLNativeTypeStgles::ShowWindow(bool show)
+{
+  std::string blank_framebuffer = "/proc/stb/video/alpha";
+  set_sysfs_int(blank_framebuffer.c_str(), show ? 255 : 0);
+  return true;
+}
+
+int CEGLNativeTypeStgles::get_sysfs_str(const char *path, char *valstr, const int size) const
+{
+  int fd = open(path, O_RDONLY);
+  if (fd >= 0)
+  {
+    int len = read(fd, valstr, size - 1);
+    if (len != -1 )
+      valstr[len] = '\0';
+    close(fd);
+  }
+  else
+  {
+    sprintf(valstr, "%s", "fail");
+    return -1;
+  }
+  return 0;
+}
+
+int CEGLNativeTypeStgles::set_sysfs_str(const char *path, const char *val) const
+{
+  int fd = open(path, O_CREAT | O_RDWR | O_TRUNC, 0644);
+  if (fd >= 0)
+  {
+    write(fd, val, strlen(val));
+    close(fd);
+    return 0;
+  }
+  return -1;
+}
+
+int CEGLNativeTypeStgles::set_sysfs_int(const char *path, const int val) const
+{
+  char bcmd[16];
+  int fd = open(path, O_CREAT | O_RDWR | O_TRUNC, 0644);
+  if (fd >= 0)
+  {
+    sprintf(bcmd, "%d", val);
+    write(fd, bcmd, strlen(bcmd));
+    close(fd);
+    return 0;
+  }
+  return -1;
+}
+
+int CEGLNativeTypeStgles::get_sysfs_int(const char *path) const
+{
+  int val = 0;
+  char bcmd[16];
+  int fd = open(path, O_RDONLY);
+  if (fd >= 0)
+  {
+    read(fd, bcmd, sizeof(bcmd));
+    val = strtol(bcmd, NULL, 16);
+    close(fd);
+  }
+  return val;
+}
+
+bool CEGLNativeTypeStgles::SetDisplayResolution(const char *resolution)
+{
+  CStdString modestr = resolution;
+  // switch display resolution
+  set_sysfs_str("/proc/stb/video/videomode", modestr.c_str());
+  usleep(250 * 1000);
+
+  return true;
+}
+
+bool CEGLNativeTypeStgles::ModeToResolution(const char *mode, RESOLUTION_INFO *res) const
+{
+  if (!res)
+    return false;
+
+  res->iWidth = 0;
+  res->iHeight= 0;
+
+  if(!mode)
+    return false;
+
+  CStdString fromMode = mode;
+  fromMode.Trim();
+  // strips, for example, 720p* to 720p
+  if (fromMode.Right(1) == "*")
+    fromMode = fromMode.Left(std::max(0, (int)fromMode.size() - 1));
+
+  if (fromMode.Equals("720p60"))
+  {
+    res->iWidth = 1280;
+    res->iHeight= 720;
+    res->iScreenWidth  = res->iWidth;
+    res->iScreenHeight = res->iHeight;
+    res->fRefreshRate = 60;
+    res->dwFlags= D3DPRESENTFLAG_PROGRESSIVE;
+  }
+  else if (fromMode.Equals("720p50"))
+  {
+    res->iWidth = 1280;
+    res->iHeight= 720;
+    res->iScreenWidth  = res->iWidth;
+    res->iScreenHeight = res->iHeight;
+    res->fRefreshRate = 50;
+    res->dwFlags= D3DPRESENTFLAG_PROGRESSIVE;
+  }
+  else if (fromMode.Equals("1080p60"))
+  {
+    res->iWidth = 1280;
+    res->iHeight= 720;
+    res->iScreenWidth  = 1920;
+    res->iScreenHeight = 1080;
+    res->fRefreshRate = 60;
+    res->dwFlags= D3DPRESENTFLAG_PROGRESSIVE;
+  }
+  else if (fromMode.Equals("1080p59"))
+  {
+    res->iWidth = 1280;
+    res->iHeight= 720;
+    res->iScreenWidth  = 1920;
+    res->iScreenHeight = 1080;
+    res->fRefreshRate = 59;
+    res->dwFlags= D3DPRESENTFLAG_PROGRESSIVE;
+  }
+  else if (fromMode.Equals("1080p50"))
+  {
+    res->iScreenWidth = 1920;
+    res->iScreenHeight= 1080;
+    res->iWidth = 1280;
+    res->iHeight= 720;
+    res->fRefreshRate = 50;
+    res->dwFlags= D3DPRESENTFLAG_PROGRESSIVE;
+  }
+  else if (fromMode.Equals("1080p30"))
+  {
+    res->iWidth = 1280;
+    res->iHeight= 720;
+    res->iScreenWidth  = 1920;
+    res->iScreenHeight = 1080;
+    res->fRefreshRate = 30;
+    res->dwFlags= D3DPRESENTFLAG_PROGRESSIVE;
+  }
+  else if (fromMode.Equals("1080p25"))
+  {
+    res->iWidth = 1280;
+    res->iHeight= 720;
+    res->iScreenWidth  = 1920;
+    res->iScreenHeight = 1080;
+    res->fRefreshRate = 25;
+    res->dwFlags= D3DPRESENTFLAG_PROGRESSIVE;
+  }
+  else if (fromMode.Equals("1080p140"))
+  {
+    res->iWidth = 1280;
+    res->iHeight= 720;
+    res->iScreenWidth  = 1920;
+    res->iScreenHeight = 1080;
+    res->fRefreshRate = 24;
+    res->dwFlags= D3DPRESENTFLAG_PROGRESSIVE;
+  }
+  else if (fromMode.Equals("1080i60"))
+  {
+    res->iScreenWidth = 1920;
+    res->iScreenHeight= 1080;
+    res->iWidth = 1280;
+    res->iHeight= 720;
+    res->fRefreshRate = 60;
+    res->dwFlags= D3DPRESENTFLAG_INTERLACED;
+  }
+  else if (fromMode.Equals("1080i50"))
+  {
+    res->iWidth = 1920;
+    res->iHeight= 1080;
+    res->iScreenWidth = 1280;
+    res->iScreenHeight= 720;
+    res->fRefreshRate = 50;
+    res->dwFlags= D3DPRESENTFLAG_INTERLACED;
+  }
+  else if (fromMode.Equals("576i50"))
+  {
+    res->iWidth = 720;
+    res->iHeight= 576;
+    res->iScreenWidth = 1280;
+    res->iScreenHeight= 720;
+    res->fRefreshRate = 50;
+    res->dwFlags= D3DPRESENTFLAG_INTERLACED;
+  }
+  else if (fromMode.Equals("576p50"))
+  {
+    res->iWidth = 720;
+    res->iHeight= 576;
+    res->iScreenWidth = 1280;
+    res->iScreenHeight= 720;
+    res->fRefreshRate = 50;
+    res->dwFlags= D3DPRESENTFLAG_PROGRESSIVE;
+  }
+
+  res->iScreen       = 0;
+  res->bFullScreen   = true;
+  res->iSubtitles    = (int)(0.965 * res->iHeight);
+  res->fPixelRatio   = 1.0f;
+  res->strMode.Format("%dx%d @ %.2f%s - Full Screen", res->iScreenWidth, res->iScreenHeight, res->fRefreshRate,
+    res->dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "");
+
+  return res->iWidth > 0 && res->iHeight> 0;
+}
+
diff -Nur xbmc-nightly.org/xbmc/windowing/egl/EGLNativeTypeStgles.h xbmc-nightly/xbmc/windowing/egl/EGLNativeTypeStgles.h
--- xbmc-nightly.org/xbmc/windowing/egl/EGLNativeTypeStgles.h	1969-12-31 16:00:00.000000000 -0800
+++ xbmc-nightly/xbmc/windowing/egl/EGLNativeTypeStgles.h	2014-02-14 18:27:05.168593377 -0800
@@ -0,0 +1,58 @@
+#pragma once
+
+/*
+ *      Copyright (C) 2011-2012 Team XBMC
+ *      http://www.xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "EGLNativeType.h"
+class CEGLNativeTypeStgles : public CEGLNativeType
+{
+public:
+  CEGLNativeTypeStgles();
+  virtual ~CEGLNativeTypeStgles();
+  virtual std::string GetNativeName() const { return "stgles"; };
+  virtual bool  CheckCompatibility();
+  virtual void  Initialize();
+  virtual void  Destroy();
+  virtual int   GetQuirks() { return EGL_QUIRK_NONE; };
+
+  virtual bool  CreateNativeDisplay();
+  virtual bool  CreateNativeWindow();
+  virtual bool  GetNativeDisplay(XBNativeDisplayType **nativeDisplay) const;
+  virtual bool  GetNativeWindow(XBNativeWindowType **nativeWindow) const;
+
+  virtual bool  DestroyNativeWindow();
+  virtual bool  DestroyNativeDisplay();
+
+  virtual bool  GetNativeResolution(RESOLUTION_INFO *res) const;
+  virtual bool  SetNativeResolution(const RESOLUTION_INFO &res);
+  virtual bool  ProbeResolutions(std::vector<RESOLUTION_INFO> &resolutions);
+  virtual bool  GetPreferredResolution(RESOLUTION_INFO *res) const;
+
+  virtual bool  ShowWindow(bool show);
+
+protected:
+  int get_sysfs_str(const char *path, char *valstr, const int size) const;
+  int set_sysfs_str(const char *path, const char *val) const;
+  int set_sysfs_int(const char *path, const int val) const;
+  int get_sysfs_int(const char *path) const;
+
+  bool SetDisplayResolution(const char *resolution);
+  bool ModeToResolution(const char *mode, RESOLUTION_INFO *res) const;
+};
diff -Nur xbmc-nightly.org/xbmc/windowing/egl/EGLWrapper.cpp xbmc-nightly/xbmc/windowing/egl/EGLWrapper.cpp
--- xbmc-nightly.org/xbmc/windowing/egl/EGLWrapper.cpp	2014-01-24 22:02:31.828495424 -0800
+++ xbmc-nightly/xbmc/windowing/egl/EGLWrapper.cpp	2014-02-14 18:27:05.169593504 -0800
@@ -26,6 +26,7 @@
 #include "EGLNativeTypeAndroid.h"
 #include "EGLNativeTypeAmlogic.h"
 #include "EGLNativeTypeRaspberryPI.h"
+#include "EGLNativeTypeStgles.h"
 #include "EGLWrapper.h"
 
 #define CheckError() m_result = eglGetError(); if(m_result != EGL_SUCCESS) CLog::Log(LOGERROR, "EGL error in %s: %x",__FUNCTION__, m_result);
@@ -84,6 +85,20 @@
     }
   }
 
+  if (!ret)
+  {
+    delete nativeGuess;
+    nativeGuess = new CEGLNativeTypeStgles;
+    if (nativeGuess->CheckCompatibility())
+    {
+      if(implementation == nativeGuess->GetNativeName() || implementation == "auto")
+      {
+        m_nativeTypes = nativeGuess;
+        ret = true;
+      }
+    }
+  }
+
   if (ret && m_nativeTypes)
     m_nativeTypes->Initialize();
 
@@ -194,7 +209,7 @@
   if (!m_nativeTypes->GetNativeDisplay((XBNativeDisplayType**)&nativeDisplay))
     return false;
 
-  *display = eglGetDisplay(*nativeDisplay);
+  *display = eglGetDisplay((int)*nativeDisplay);
   CheckError();
   if (*display == EGL_NO_DISPLAY) 
   {
diff -Nur xbmc-nightly.org/xbmc/windowing/egl/Makefile xbmc-nightly/xbmc/windowing/egl/Makefile
--- xbmc-nightly.org/xbmc/windowing/egl/Makefile	2014-01-24 22:02:31.829495551 -0800
+++ xbmc-nightly/xbmc/windowing/egl/Makefile	2014-02-14 18:27:05.169593504 -0800
@@ -4,6 +4,7 @@
 SRCS+= EGLNativeTypeAmlogic.cpp
 SRCS+= EGLNativeTypeAndroid.cpp
 SRCS+= EGLNativeTypeRaspberryPI.cpp
+SRCS+= EGLNativeTypeStgles.cpp
 SRCS+= EGLWrapper.cpp
 
 LIB = windowing_egl.a
